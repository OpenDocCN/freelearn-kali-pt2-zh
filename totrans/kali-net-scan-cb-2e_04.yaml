- en: Port Scanning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter includes the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Port scanning with Scapy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Port scanning with Nmap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Port scanning with Metasploit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Port scanning with hping3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Port scanning with DMitry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Port scanning with Netcat
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Port scanning with masscan
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Identifying open ports on a target system is the next step to defining the attack
    surface of a target. Open ports correspond to the networked services that are
    running on a system. Programming errors or implementation flaws can make these
    services vulnerable to attack and can sometimes lead to total system compromise.
    To determine the possible attack vectors, one must first enumerate the open ports
    on all of the remote systems within the project's scope. These open ports correspond
    to services that may be addressed with either UDP or TCP traffic. Both TCP and
    UDP are transport protocols. **Transmission Control Protocol** (**TCP**) is the
    more commonly used of the two and provides connection-oriented communication.
    **User Datagram Protocol** (**UDP**) is a non connection-oriented protocol that
    is sometimes used with services for which speed of transmission is more important
    than data integrity. The penetration testing technique used to enumerate these
    services is called **port scanning**. Unlike host discovery, which was discussed
    in the previous chapter, these techniques should yield enough information to identify
    whether a service is associated with a given port on the device or server. Prior
    to addressing the specific recipes listed, we will discuss some of the underlying
    principles that should be understood about port scanning.
  prefs: []
  type: TYPE_NORMAL
- en: UDP port scanning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Because TCP is a more commonly used transport-layer protocol, services that
    operate over UDP are frequently forgotten. Despite the natural tendency to overlook
    UDP services, it is absolutely critical that these services be enumerated to acquire
    a complete understanding of the attack surface of any given target. UDP scanning
    can often be challenging, tedious, and time consuming. The first three recipes
    in this chapter will cover how to perform a UDP port scan with different tools
    in Kali Linux. To understand how these tools work, it is important to understand
    the two different approaches to UDP scanning that will be used. One technique,
    which will be addressed in the first recipe, is to rely exclusively on ICMP port-unreachable
    responses. This type of scanning relies on the assumption that any UDP ports that
    are not associated with a live service will return an ICMP port-unreachable response,
    and a lack of this response is interpreted as an indication of a live service.
    While this approach can be effective in some circumstances, it can also return
    inaccurate results in cases where the host is not generating port-unreachable
    responses or the port-unreachable replies are rate limited or are filtered by
    a firewall. An alternative approach, which is addressed in the second and third
    recipes, is to use service-specific probes to attempt to solicit a response, which
    would indicate that the expected service is running on the targeted port. While
    this approach can be highly effective, it can also be very time consuming.
  prefs: []
  type: TYPE_NORMAL
- en: TCP port scanning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Throughout this chapter, several different approaches to TCP scanning will
    be addressed. These techniques include stealth scanning, connect scanning, and
    zombie scanning. To understand how these scanning techniques work, it is important
    to understand how TCP connections are established and maintained. TCP is a connection-oriented
    protocol, and data is only transported over TCP after a connection has been established
    between two systems. The process associated with establishing a TCP connection
    is often referred to as the three-way handshake. This name alludes to the three
    steps involved in the connection process. The following diagram illustrates this
    process in graphical form:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00420.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A TCP **SYN** packet is sent from the device that wishes to establish a connection
    with a port of the device that it desires to connect with. If the service associated
    with the receiving port accepts the connection, it will reply to the requesting
    system with a TCP packet that has both the **SYN** and **ACK** bits activated.
    The connection is established only when the requesting system responds with a
    TCP **ACK** response. This three-step process establishes a TCP session between
    the two systems. All of the TCP port scanning techniques will perform some variation
    of this process to identify live services on remote hosts.
  prefs: []
  type: TYPE_NORMAL
- en: Both connect scanning and stealth scanning are fairly easy to understand. Connect
    scanning is used to establish a full TCP connection for each port that is scanned.
    This is to say that for each port that is scanned, the full three-way handshake
    is completed. If a connection is successfully established, the port is then determined
    to be open. On the other hand, stealth scanning does not establish a full connection.
    Stealth scanning is also referred to as SYN scanning or half-open scanning. For
    each port that is scanned, a single SYN packet is sent to the destination port,
    and all ports that reply with a SYN+ACK packet are assumed to be running live
    services. Since no final ACK is sent from the initiating system, the connection
    is left half open. This is referred to as stealth scanning because logging solutions
    that only record established connections will not record any evidence of the scan.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final method of TCP scanning that will be discussed in this chapter is
    a technique called **zombie scanning**. The purpose of zombie scanning is to map
    open ports on a remote system without producing any evidence that you have interacted
    with that system. The principles behind how zombie scanning works are somewhat
    complex. Carry out the process of zombie scanning with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Identify a remote system for your zombie. This system should have the following
    characteristics:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is idle and does not communicate actively with other systems on the network
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It uses an incremental IPID sequence
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Send a SYN+ACK packet to this zombie host and record the initial IPID value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Send a SYN packet with a spoofed source IP address of the zombie system to the
    scan target system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Depending on the status of the port on the scan target, one of the following
    two things will happen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the port is open, the scan target will return a SYN+ACK packet to the zombie
    host, which it believes sent the original SYN request. In this case, the zombie
    host will respond to this unsolicited SYN+ACK packet with an RST packet and thereby
    increment its IPID value by one.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the port is closed, the scan target will return an RST response to the zombie
    host, which it believes sent the original SYN request. This RST packet will solicit
    no response from the zombie, and the IPID will not be incremented.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Send another SYN+ACK packet to the zombie host, and evaluate the final IPID
    value of the returned RST response. If this value has incremented by one, then
    the port on the scan target is closed, and if the value has incremented by two,
    then the port on the scan target is open.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following diagram shows the interactions that take place when a zombie
    host is used to scan an open port:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00345.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: To perform a zombie scan, an initial **SYN/ACK** request should be sent to the
    zombie system to determine the current **IPID** value in the returned **RST**
    packet. Then, a spoofed **SYN** packet is sent to the scan target with a source
    IP address of the zombie system. If the port is open, the scan target will send
    a **SYN/ACK** response back to the zombie. Since the zombie did not actually send
    the initial **SYN** request, it will interpret the **SYN/ACK** response as unsolicited
    and send an **RST** packet back to the target, thereby incrementing its **IPID**
    by one. Finally, another **SYN/ACK** packet should be sent to the zombie, which
    will return an **RST** packet and increment the **IPID** one more time. An **IPID**
    that has incremented by two from the initial response is indicative of the fact
    that all of these events have transpired and that the destination port on the
    scanned system is open. Alternatively, if the port on the scan target is closed,
    a different series of events will transpire, which will only cause the final **RST**
    response **IPID** value to increment by one.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram is an illustration of the sequence of events associated
    with the zombie scan of a closed port:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00426.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If the destination port on the scan target is closed, an **RST** packet will
    be sent to the zombie system in response to the initially spoofed **SYN** packet.
    Since the **RST** packet solicits no response, the **IPID** value of the zombie
    system will not be incremented. As a result, the final **RST** packet returned
    to the scanning system in response to the **SYN/ACK** packet will have the **IPID**
    incremented by only one. This process can be performed for each port that is to
    be scanned, and it can be used to map open ports on a remote system without leaving
    any evidence that a scan was performed by the scanning system.
  prefs: []
  type: TYPE_NORMAL
- en: Port scanning with Scapy (UDP, stealth, connect, and zombie)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scapy is a tool that can be used to craft and inject custom packets into a network.
    We will begin by using Scapy to scan for active UDP services. This can be done
    by sending an empty UDP packet to destination ports and then identifying the ports
    that do not respond with an ICMP port-unreachable response.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will use Scapy to perform a TCP stealth scan. A TCP port stealth scan
    performs a partial, three-way TCP handshake on target ports to identify whether
    the ports are accepting connections or not. This type of scan is referred to as
    a stealth scan, SYN scan, or half-open scan.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will use Scapy to perform a TCP connect scan. Generally, TCP connect
    scanning is an easier process than SYN scanning. This is because TCP connect scanning
    does not require the elevated privileges that are needed to generate and inject
    the raw packets used in SYN scanning. Scapy is the one major exception to this.
    It is actually very difficult and impractical to perform a full, three-way TCP
    handshake with Scapy. However, for the sake of understanding the process better,
    we will see how to use Scapy to perform a connect scan.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will use Scapy to perform zombie scans. It is possible to identify
    the open ports on a target system without ever giving that system any indication
    that you interacted with it. This extremely stealthy form of scanning is referred
    to as zombie scanning and can only be performed if another system exists on the
    network that has low network activity and incremental IPID sequencing.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To use Scapy to perform UDP scanning, you will need to have a remote system
    that is running network services over UDP. In the examples provided, an instance
    of Metasploitable2 is used to perform this task. To use Scapy to perform stealth
    and connect TCP scans, you will need to have a remote system that is running accessible
    network services over TCP. In the examples provided, an instance of Metasploitable2
    is used to perform this task. To use Scapy to perform a zombie scan, you will
    need to have a remote system that is running TCP services and another remote system
    that has incremental IPID sequencing. In the examples provided, an installation
    of Metasploitable2 is used as a scan target, and an installation of Windows XP
    is used as an incremental IPID zombie.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on how to set up Metasploitable2, refer to [Chapter 1](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426),
    *Getting Started*. Additionally, this section will require a script to be written
    to the filesystem using a text editor such as Vim or GNU nano. For more information
    on how to write scripts, refer to the *Using text editors (Vim and GNU nano)*
    recipe in [Chapter 1](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426), *Getting
    Started*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start with UDP port scanning with Scapy.
  prefs: []
  type: TYPE_NORMAL
- en: UDP port scanning with Scapy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using Scapy, we can quickly develop an understanding of the underlying principles
    of UDP scanning. To positively confirm the existence of a UDP service on any given
    port, we will need to solicit a reply from that service. This can prove to be
    very difficult, as many UDP services will only reply to service-specific requests.
    Knowledge of any particular service can make it easier to positively identify
    that service; however, there are general techniques that can be used to determine,
    with a reasonable amount of accuracy, whether a service is running on a given
    UDP port. The technique that we will use with Scapy is to identify closed UDP
    ports with ICMP port-unreachable replies:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To send a UDP request to any given port, we first need to build layers of that
    request. The first layer that we will need to construct is the IP layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00430.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To build the IP layer of our request, we need to assign the `IP` object to
    the `i` variable. By calling the `display()` function, we can identify the attribute
    configurations of the object. By default, both the sending and receiving addresses
    are set to the loopback address, `127.0.0.1`. These values can be modified by
    changing the destination address, by setting `i.dst` to be equal to the string
    value of the address we wish to scan. On calling the `display()` function again,
    we see that not only has the destination address been updated, but Scapy also
    automatically updates the source IP address to the address associated with the
    default interface. Now that we have constructed the IP layer of the request, we
    can proceed to the UDP layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00399.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To build the UDP layer of our request, we use the same technique we used for
    the IP layer. In the example provided, the UDP object was assigned to the `u`
    variable. As mentioned previously, the default configurations can be identified
    by calling the `display()` function. Here, we can see that the default value for
    both the source and destination ports are listed as `domain`. As you might likely
    suspect, this is to indicate the DNS service associated with port the `53`. DNS
    is a common service that can often be discovered on networked systems. To confirm
    this, one can call the value directly by referencing the variable name and attribute.
    This can then be modified by setting the attribute equal to the new port destination
    value, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00419.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding example, the destination port is set to `123`, which is the
    **Network Time Protocol** (**NTP**) port. Now that we have created both the IP
    and UDP layers, we need to construct the request by stacking these layers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00438.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can stack the IP and UDP layers by separating the variables with a forward
    slash. These layers can then be set equal to a new variable that will represent
    the entire request. We can then call the `display()` function to view the configurations
    for the request. Once the request has been built, it can be passed to the `sr1()`
    function so that we can analyze the response:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00441.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This same request can be performed without independently building and stacking
    each layer. Instead, we can use a single one-line command by calling the functions
    directly and passing them the appropriate arguments, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00444.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Note that the response for these requests includes an ICMP packet that has
    the type field indicating that the host is unreachable and code field indicating
    that the port is unreachable. This response is commonly returned if the UDP port
    is closed. Now, we should attempt to modify the request so that it is sent to
    a destination port that corresponds to an actual service on the remote system.
    To do this, we change the destination port back to the port `53` and then send
    the request again, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00328.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'When the same request is sent to an actual service, no reply is received. This
    is because the DNS service running on the system''s UDP port `53` will only respond
    to service-specific requests. Knowledge of this discrepancy can be used to scan
    for ICMP host-unreachable replies, and we can then identify potential services
    by flagging the non-responsive ports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The provided Python script sends a UDP request to each of the first hundred
    ports in sequence. In case no response is received, the port is identified as
    being open. Make sure you modify the permissions of the file by running `chmod
    777 udp_scan.py`. By running this script, we can identify all the ports that don''t
    return an ICMP host-unreachable reply:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00450.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A timeout of 5 seconds is used to adjust for latent responses that result from
    ICMP host-unreachable rate limiting. Even with this rather large response acceptance
    window, scanning in this fashion can still be unreliable at times. It is for this
    reason that UDP probing scans are often a more effective alternative.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Stealth scanning with Scapy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following steps demonstrate scanning with Scapy:'
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate how a SYN scan is performed, we craft a TCP SYN request using
    Scapy and identify the responses associated with an open port, closed port, and
    non-responsive system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To send a TCP SYN request to any given port, we first need to build the layers
    of this request. The first layer that we need to construct is the IP layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00494.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: To build the IP layer for our request, we need to assign the `IP` object to
    the `i` variable. By calling the `display()` function, we identify the attribute
    configurations for the object. By default, both the sending and receiving addresses
    are set to the loopback address, `127.0.0.1`. These values can be modified by
    changing the destination address, by setting `i.dst` equal to the string value
    of the address that we wish to scan. By calling the `display()` function again,
    we see that not only has the destination address been updated, but Scapy also
    automatically updates the source IP address to the address associated with the
    default interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that we have constructed the IP layer for the request, we can proceed to
    the TCP layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00457.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: To build the TCP layer for our request, we use the same technique that we used
    for the IP layer. In the example provided, the `TCP` object was assigned to the
    `t` variable. As mentioned previously, we can identify the default configurations
    by calling the `display()` function. Here, we can see that the default value for
    the destination port is the HTTP port `80`. For our initial scan, we leave the
    default TCP configuration as is.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that we have created both the IP and TCP layers, we need to construct the
    request by stacking these layers as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00624.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can stack the IP and TCP layers by separating the variables with a forward
    slash. These layers can then be set equal to a new variable that will represent
    the entire request. We can then call the `display()` function to view the configurations
    for the request. Once the request has been built, it can then be passed to the
    `sr1()` function so that we can analyze the response, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00016.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can perform this same request without independently building and stacking
    each layer. Instead, we can use a single, one-line command by calling the functions
    directly and passing them the appropriate arguments, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00030.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Note that when a SYN packet is sent to the TCP port `80` of a target web server,
    which is running an HTTP service on that port, the response has a TCP flag value
    of `SA`, which indicates that both the SYN and ACK flag bits are activated. This
    response indicates that the specified destination port is open and accepting connections.
    A different response will be returned if the same type of packet is sent to a
    port that is not accepting connections:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00356.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'When a SYN request is sent to a closed port, a response is returned with a
    TCP flag value of `RA`, which indicates that both the RST and ACK flag bits are
    activated. The ACK bit is merely used to acknowledge that the request was received,
    and the RST bit is used to discontinue the communication because the port is not
    accepting connections. Alternatively, if a SYN packet is sent to a system that
    is down or behind a firewall that is filtering such requests, it is likely that
    no response will be received. Due to this, a timeout option should always be used
    when the `sr1()` function is used in a script, to ensure that the script does
    not get hung up on unresponsive hosts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00056.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If the timeout value is not specified when this function is used against an
    unresponsive host, the function will continue indefinitely. In the demonstration,
    a timeout value of 1 second was provided for the completion of the function. The
    response value can be evaluated to determine whether a reply was received. Let's
    check that out.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Using Python makes it easy to test the variable to identify whether a value
    has been assigned to it by the `sr1()` function. This can be used as a preliminary
    check to determine whether any responses are being received. For responses that
    are received, subsequent checks can be performed to determine whether the response
    is indicating a port that is open or closed. All of this can easily be sequenced
    in a Python script, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the provided Python script, the user is prompted to enter an IP address,
    and the script then performs a SYN scan on the defined port sequence. The script
    then evaluates the response from each connection attempt to determine whether
    the response has the SYN and ACK TCP flags activated. The TCP flag for SYN+ACK
    is 0x12, which translates to 18 in decimal. If these flags, and only these flags,
    are present in the response, the corresponding port number received is then output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00069.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Upon running the script, the output will indicate any of the first `100` ports
    that are open on the system by providing the IP address:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00082.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Connect scanning with Scapy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps to run the connect scan with Scapy:'
  prefs: []
  type: TYPE_NORMAL
- en: It can be difficult to run a full connect scan with Scapy because the system
    kernel remains unaware of your packet meddling with Scapy and attempts to prevent
    you from establishing a full three-way handshake with the remote system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can see this activity in action by sending a SYN request and sniffing the
    associated traffic with Wireshark or TCP dump.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When you receive a SYN+ACK response from the remote system, the Linux kernel
    will interpret it as an unsolicited response because it remains unaware of your
    request made in Scapy, and the system will automatically respond with a TCP RST
    packet, thereby discontinuing the handshake process. Consider the following example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This Python script can be used as a proof of concept to demonstrate the problem
    of the system breaking the three-way handshake. The script assumes that you are
    directing it toward a live system with an open port and therefore assumes that
    a SYN+ACK reply will be returned in response to the initial SYN request. Even
    though the final ACK reply is sent to complete the handshake, the RST packet prevents
    the connection from being established.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can demonstrate this further by viewing the packets being sent and received:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In this Python script, each sent packet is displayed prior to transmission,
    and each received packet is displayed when it arrives. On examining the TCP flags
    that are activated in each packet, it becomes clear that the three-way handshake
    has failed. Consider the output that is generated by the script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00098.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In the output from the script, four packets can be seen. The first packet is
    the sent SYN request, the second packet is the received SYN+ACK reply, the third
    packet is the sent ACK reply, and an RST packet is then received in response to
    the final ACK reply. It is this final packet that indicates that a problem was
    encountered when establishing the connection. It is possible to perform a full
    three-way handshake with Scapy, but it requires some tampering with the local
    iptables on the system. Specifically, you can only complete the handshake if you
    suppress the RST packets that are sent to the remote system that you are trying
    to connect with. By establishing a filtering rule using iptables, it is possible
    to drop the RST packets to complete the three-way handshake without interference
    from the system (this configuration is not recommended for continued functional
    usage).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To demonstrate the successful completion of the full three-way handshake, we
    establish a listening TCP service using Netcat and then attempt to connect to
    the open socket using Scapy:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00111.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the example provided, a listening service was opened on the TCP port `4444`.
    We can then modify the script that was discussed previously to attempt to connect
    to the Netcat TCP service on the port `4444`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this script, a SYN request was sent to the listening port, and then an ACK
    reply was sent in response to the anticipated SYN+ACK reply. To validate that
    the connection attempt is still interrupted by a system-generated RST packet,
    this script should be executed while Wireshark is being run to capture the request
    sequence.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We apply a filter to Wireshark to isolate the connection attempt sequence.
    The filter used was `tcp && (ip.src == 172.16.69.128 || ip.dst == 172.16.69.128)`.
    This filter is used to only display the TCP traffic going to or from the system
    being scanned. This is shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00375.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have identified the exact problem, we can establish a filter that
    will allow us to suppress this system-generated RST response. This filter can
    be established by modifying the local iptables, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modifying the local iptables in the following manner will impair the way your
    system handles the TCP/IP transactions with the destination system by blocking
    all outbound RST responses. Ensure that the created iptables rule is removed upon
    completion of this recipe, or flush the iptables afterward with the following
    command: `iptables --flush`.![](../images/00135.jpeg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the example provided, the local iptables were modified to suppress all TCP
    RST packets going to the destination address of our scanned host. The `--list`
    option can then be used to view the iptable entries and verify that a configuration
    change has been made. To perform another connection attempt, we need to ensure
    that Netcat is still listening on the port `4444` of our target, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00148.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The same Python script that was introduced previously should be run again,
    with Wireshark capturing the traffic in the background. Using the previously discussed
    display filter, we can easily focus on the traffic we need. Note that all of the
    steps of the three-way handshake have now been completed without any interruption
    by system-generated RST packets, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00164.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Additionally, if we take a look at our Netcat service, which is running on the
    target system, we notice that a connection has been established. This is further
    evidence to confirm that a successful connection was established.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'While this is a useful exercise to understand and troubleshoot TCP connections,
    it is important not to leave the iptable entry in place. RST packets are an important
    component of TCP communications, and suppressing these responses altogether can
    drastically impair proper communication functionality. The following commands
    can be used to flush our iptables rules and verify that the flush was successful:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00179.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As is demonstrated in the example provided, the `--flush` option should be used
    to clear the iptable entries that were made. We can verify that the iptable entries
    have been removed using the `--list` option one more time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Zombie scanning with Scapy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A value that exists in all IP packets is an ID number. Depending on the system,
    this ID number might be generated randomly, might always be zeroed out, or might
    increment by one with each IP packet that is sent. If a host with incremental
    IPID sequencing is discovered and that host is not interacting with other networked
    systems, it can be used as a means to identify open ports on other systems. We
    can identify the IPID sequencing patterns of a remote system by sending a series
    of IP packets and analyzing the responses:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00391.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If we send two IP packets to an idle Windows system, we can examine the integer
    value of the ID attribute under the IP layer of the response.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the reply to the first request had the ID `61`, and the reply to the
    second request had the ID `62`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This host does, indeed, have incremental IPID sequencing, and assuming it remains
    idle, it can be used as an effective zombie for zombie scanning:'
  prefs: []
  type: TYPE_NORMAL
- en: To perform a zombie scan, an initial SYN+ACK request must be sent to the zombie
    system to determine the current IPID value in the returned RST packet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, a spoofed SYN packet is sent to the scan target with the source IP address
    of the zombie system. If the port is open, the scan target will send a SYN+ACK
    response back to the zombie. Since the zombie did not actually send the initial
    SYN request, it will interpret the SYN+ACK request as unsolicited and send an
    RST packet back to the target, thereby incrementing its IPID by one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, another SYN+ACK packet should be sent to the zombie, which will return
    an RST packet and increment the IPID one more time. An IPID that has incremented
    by two from the initial response indicates that all of these events have transpired
    and that the destination port on the scanned system is open.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Alternatively, if the port on the scan target is closed, a different series
    of events will transpire, which will only cause the final RST response to be incremented
    by one. If the destination port on the scan target is closed, an RST packet will
    be sent to the zombie system in response to the initially spoofed SYN packet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since an RST packet solicits no response, the IPID value of the zombie system
    is not incremented. As a result, the final RST packet returned to the scanning
    system in response to the SYN+ACK packet will have incremented by only one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To streamline this process, the following script can be written in Python,
    which will both identify a usable zombie system and also perform the zombie scan
    against the scan target:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Upon executing this script, the user is prompted with two options. By selecting
    option `1`, we can scan or evaluate a target's IPID sequence to determine whether
    the host is a usable zombie. Assuming that the host is idle and has incremental
    IPID sequencing, the host will be flagged as a zombie, and the user will be asked
    to use the zombie to perform a scan.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If the scan is performed, the previously discussed process will be executed
    for each of the first 100 TCP port addresses, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00394.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, UDP scanning is performed by identifying the ports that do not
    respond with ICMP port-unreachable responses. This process can be highly time
    consuming as ICMP port-unreachable responses are often throttled. It can also,
    at times, be an unreliable approach as some systems do not generate these responses,
    and ICMP is often filtered by firewalls.
  prefs: []
  type: TYPE_NORMAL
- en: Stealth scans are performed by sending an initial SYN packet request to a target
    TCP port on a remote system, and the status of this port is determined by the
    type of response that is returned. If the remote system returns a SYN+ACK response,
    then it is prepared to establish a connection, and one can assume that the port
    is open. If the service returns an RST packet, it is an indication that the port
    is closed and not accepting connections. Furthermore, if no response is returned,
    then a firewall might be present between the scanning system and remote system
    that is dropping the requests. This could also be an indication that the machine
    is down or that there is no system associated with the destination IP address.
  prefs: []
  type: TYPE_NORMAL
- en: TCP connect scans operate by performing a full three-way handshake to establish
    a connection with all of the scanned ports on the remote target system. A port's
    status is determined based on whether a connection was established or not. If
    a connection was established, the port is determined to be open. If a connection
    could not be established, the port is determined to be closed.
  prefs: []
  type: TYPE_NORMAL
- en: Zombie scanning is a stealthy way to enumerate open ports on a target system
    without leaving any trace of interaction with it. Using a combination of spoofed
    requests sent to the target system and legitimate requests sent to the zombie
    system, we can map the open ports on the target system by evaluating the IPID
    values of the responses from the zombie.
  prefs: []
  type: TYPE_NORMAL
- en: Port scanning with Nmap (UDP, stealth, connect, zombie)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nmap can be utilized to perform UDP, TCP stealth, TCP connect, and zombie scans.
    In this section, we will discuss how to conduct each of these types of scans.
    The Nmap approach to UDP scanning is more complex and attempts to identify live
    services by injecting service-specific probe requests in an effort to solicit
    a positive response that confirms the existence of a given service. We will also
    discuss how Nmap handles stealth and TCP connect scanning. Finally, we will look
    at a highly effective scanning mode Nmap has for zombie scanning.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To use Nmap to perform UDP, TCP stealth, TCP connect, or zombie scans, you will
    need to have a remote system that is running network services over UDP and TCP.
    In the examples provided, an instance of Metasploitable2 is used as a scan target,
    and an installation of Windows XP is used as an incremental IPID zombie. In the
    examples provided, a combination of Linux and Windows systems is used.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on how to set up systems in a local lab environment, refer
    to the *Installing Metasploitable2* and *Installing Windows Server* recipes in
    [Chapter 1](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426), *Getting Started*.
    Additionally, this section will require a script to be written to the filesystem
    using a text editor such as Vim or GNU nano. For more information on how to write
    scripts, refer to the *Using text editors (Vim and GNU nano)* recipe in [Chapter
    1](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426), *Getting Started*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start with UDP scanning with Nmap.
  prefs: []
  type: TYPE_NORMAL
- en: UDP scanning with Nmap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: UDP scanning can often be challenging, time consuming, and tedious. Many systems
    will rate-limit ICMP host-unreachable replies and can drastically increase the
    amount of time required to scan a large number of ports and/or systems. Fortunately,
    the developers of Nmap have a more complex and much more effective tool to identify
    UDP services on remote systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'To perform a UDP scan with Nmap, the `-sU` option should be used with the IP
    address of the host that is to be scanned:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00396.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Although Nmap is built to solicit replies from UDP ports with custom payloads
    for many services, it still requires a large amount of time to even scan the default
    1,000 ports when no other arguments are used to specify the destination ports.
    As you can see from the scan metadata at the bottom of the output, the default
    scan required nearly 20 minutes to complete. Alternatively, we can shorten the
    required scan time by performing targeted scans, as shown in the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00239.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The amount of time required to perform UDP scans can be drastically reduced
    if we specify the particular ports that need to be scanned. This can be done by
    performing a UDP scan and specifying the port with the `-p` option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the preceding example, we are performing a scan only on the port `53` to
    attempt to identify a DNS service. A scan can also be performed on multiple specified
    ports, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00404.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In the example provided, a scan was performed on the first 100 ports. This was
    done using dash notation and specifying both the first and last port to be scanned.
    Nmap then spins up multiple processes that will be used to simultaneously scan
    all of the ports between and including these two values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On some occasions, a UDP analysis will need to be performed on multiple systems.
    A range of hosts can be scanned with Nmap using dash notation and by defining
    the range of values for the last octet, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00407.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In the example provided, scans were performed on all live hosts within the `172.16.69.0/24`
    range. Each host was scanned to identify whether a DNS service was running on
    the port `53`. Another alternative option would be to scan multiple hosts using
    an input list of IP addresses.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To do this, the `-iL` option should be used, and it should be passed as either
    the name of a file in the same directory or the full path of a file in a separate
    directory. An example of the former is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00412.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In the example provided, a scan was performed to determine whether an NTP service
    was running on the port `123` on any of the systems within the `iplist.txt` file
    in the execution directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Stealth scanning with Nmap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As with most scanning requirements, Nmap has an option that simplifies and
    streamlines the process of performing TCP stealth scans:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To perform TCP stealth scans with Nmap, the `-sS` option should be used with
    the IP address of the host that is to be scanned:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00297.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the example provided, a SYN scan was performed on the TCP port `80` of the
    specified IP address. Similar to the technique explained with Scapy, Nmap listens
    for a response and identifies the open ports by analyzing the TCP flags that are
    activated in any responses received. We can also use Nmap to perform scans on
    multiple specified ports by passing a comma-delimited list of port numbers, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00312.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the example provided, a SYN scan was performed on the ports `21`, `80`,
    and `443` of the specified target IP address. We can also use Nmap to scan a sequential
    series of hosts by indicating the first and last port numbers to be scanned, separated
    using dash notation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00329.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the example provided, a SYN scan was performed on the TCP ports `20` through
    `25`. In addition to providing us with the ability to specify the ports to be
    scanned, Nmap also has a preconfigured list of 1,000 commonly used ports. We can
    perform a scan on these ports by running Nmap without supplying any port specifications:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00423.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In the example provided, the 1,000 common ports defined by Nmap were scanned
    to identify a large number of open ports on the Metasploitable2 system. Although
    this technique is effective in identifying most services, it might fail to identify
    obscure services or uncommon port associations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If a scan is to be performed on all possible TCP ports, all of the possible
    port address values need to be scanned. The portions of the TCP header that define
    the source and destination port addresses are both 16 bits in length. Moreover,
    each bit can retain a value of 1 or 0\. As such, there are 2^(16), or 65,536,
    possible TCP port addresses. For the total possible address space to be scanned,
    a port range of 0 to 65535 needs to be supplied, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00361.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the example provided, all of the 65,536 possible TCP addresses were scanned
    on the Metasploitable2 system. Take note of the fact that more services were identified
    in this scan than were identified in the standard Nmap 1,000 scan. This is evidence
    of the fact that a full scan is always best practice when attempting to identify
    all of the possible attack surface on a target. Nmap can also be used to scan
    TCP ports on a sequential series of hosts, using dash notation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00381.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the example provided, a SYN scan of the TCP port `80` was performed on all
    of the hosts within the range of addresses specified. Although this particular
    scan was only performed on a single port, Nmap also has the ability to scan multiple
    ports and ranges of ports on multiple systems simultaneously. Additionally, Nmap
    can also be configured to scan hosts based on an input list of IP addresses. This
    can be done using the `-iL` option and then specifying either the filename, if
    the file exists in the execution directory, or the path of the file. Nmap then
    cycles through each address in the input list and performs the specified scan
    against that address:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00434.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Connect scanning with Nmap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Nmap has an option that simplifies and streamlines the process of performing
    TCP connect scans:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To perform TCP connect scans with Nmap, the `-sT` option should be used with
    the IP address of the host to be scanned, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00436.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the example provided, a TCP connect scan was performed on the TCP port `80`
    of the specified IP address. Similar to the technique used with Scapy, Nmap listens
    for a response and identifies open ports by analyzing the TCP flags that are activated
    in any responses received. We can also use Nmap to perform scans on multiple specified
    ports by passing a comma-delimited list of port numbers, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00439.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the example provided, a TCP connect scan was performed on the ports `21`,
    `80`, and `443` of the specified target IP address. We can also use Nmap to scan
    a sequential series of hosts by indicating the first and last port numbers to
    be scanned, separated using dash notation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00455.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the example provided, a TCP connect scan was performed on the TCP ports
    `20` through `25`. In addition to providing the ability to specify the ports to
    be scanned, Nmap also has a preconfigured list of 1,000 commonly used ports. We
    can scan these ports by running Nmap without supplying any port specifications:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00274.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In the example provided, the 1,000 common ports defined by Nmap were scanned
    to identify a large number of open ports on the Metasploitable2 system. Although
    this technique is effective in identifying most services, it might fail to identify
    obscure services or uncommon port associations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To scan all of the possible TCP ports, all possible port address values must
    be scanned. The portions of the TCP header that define the source and destination
    port addresses are both 16 bits in length. Furthermore, each bit can retain a
    value of 1 or 0\. As such, there are 2^(16), or 65,536, possible TCP port addresses.
    For the total possible address space to be scanned, a port range of `0-65535`
    needs to be supplied, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00447.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the example provided, all of the possible 65,536 TCP addresses were scanned
    on the Metasploitable2 system. Take note of the fact that more services were identified
    in this scan than in the standard Nmap 1,000 scan. This is evidence of the fact
    that a full scan is always best practice when attempting to identify all of the
    possible attack surfaces on a target. Nmap can also be used to scan TCP ports
    on a sequential series of hosts using dash notation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00446.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In the example provided, a TCP connect scan of the TCP port `80` was performed
    on all hosts within the range of hosts specified. Although this particular scan
    was only performed on a single port, Nmap can also scan multiple ports and ranges
    of ports on multiple systems simultaneously. Additionally, Nmap can also be configured
    to scan hosts based on an input list of IP addresses.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This can be done using the `-iL` option and then by specifying either the filename,
    whether the file exists in the execution directory, or the path of the file. Nmap
    then cycles through each address in the input list and performs the specified
    scan against that address, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00453.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Zombie scanning with Nmap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These steps will help you to perform a zombie scan on the Nmap:'
  prefs: []
  type: TYPE_NORMAL
- en: Zombie scans can also be performed with an option in Nmap. However, prior to
    using the Nmap zombie scan, we can quickly find any viable zombie candidates by
    sweeping an entire address range and assessing the IPID sequencing patterns with
    Metasploit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To do this, we need to open Metasploit with the `msfconsole` command and then
    select the IPID sequencing `auxiliary` module for use, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00583.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This `auxiliary` module can be used to perform a scan on a sequential series
    of host addresses or on a network range, as defined by the CIDR notation. For
    the speed of the scan to be increased, the `THREADS` variable should be increased
    to the desired number of concurrent tasks, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00460.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the desired values for the required variables have been populated, we
    can verify the configurations of the scan again using the `show options` command.
    The IPID sequence scan can then be executed using the `run` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00557.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As the IPID sequence scanning module sweeps through the provided network range,
    it will identify the IPID sequencing patterns of discovered hosts and indicate
    whether they are zeros, randomized, or incremental.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'An ideal candidate for zombie scanning is a host that has both incremental
    IPID sequencing and is not interacting heavily with other systems on the network.
    Once an incremental idle host has been identified, we can perform the zombie scan
    in Nmap using the `-sI` option and by passing it the IP address of the zombie
    host that needs to be used for scanning:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00137.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In the example provided, a zombie scan was performed on the first 100 TCP ports
    of the scan target, `172.16.69.128`. The idle host at `172.16.69.128` was used
    as the zombie, and the `-Pn` option was used to prevent Nmap from attempting to
    ping the scan target.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this demonstration, we identified and enumerated all of the listed open ports
    and never interacted directly with the scanned target. Instead, source-spoofed
    packets were sent to the scan target, and the only direct interaction was between
    the scanning system and the zombie host.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While Nmap still has to contend with many of the same challenges associated
    with UDP scanning, it is still a highly effective solution because it is optimized
    to use a combination of the most effective and quickest techniques possible to
    identify live services.
  prefs: []
  type: TYPE_NORMAL
- en: The underlying principle behind how SYN scanning is performed with Nmap is the
    same as has already been discussed. However, with multithreaded capabilities,
    Nmap is a fast and highly effective way to perform these types of scans.
  prefs: []
  type: TYPE_NORMAL
- en: Tools that perform TCP connect scans operate by performing a full three-way
    handshake to establish a connection with all scanned ports on the remote target
    system. A port's status is determined based on whether a connection was established
    or not. If a connection was established, the port is determined to be open. If
    a connection could not be established, the port is determined to be closed.
  prefs: []
  type: TYPE_NORMAL
- en: The underlying principle behind zombie scanning is the same as was discussed
    when performing this task with Scapy in the previous recipe. However, using the
    Nmap zombie-scanning mode allows us to use an integrated and well-known tool to
    perform this same task quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Port scanning with Metasploit (UDP, stealth, and connect)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Metasploit has auxiliary modules that can be used to perform UDP, SYN, and TCP
    connect scanning. Using Metasploit for scanning as well as exploitation can be
    an effective way to cut down on the total number of tools required to complete
    a penetration test. This specific recipe demonstrates how we can use Metasploit
    to perform port scanning.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To use Metasploit to perform UDP, TCP stealth, and TCP full connect scans, you
    will need to have a remote system that is running network services over UDP and
    TCP. In the examples provided, an instance of Metasploitable2 is used to perform
    this task. For more information on how to set up Metasploitable2, refer to [Chapter
    1](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426), *Getting Started*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start with UDP scanning with Metasploit.
  prefs: []
  type: TYPE_NORMAL
- en: UDP scanning with Metasploit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Prior to defining the module to be run, Metasploit needs to be opened:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To open Metasploit in Kali Linux, we use the `msfconsole` command in a Terminal
    session, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00215.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To run the UDP sweep module in Metasploit, we call the `use` command with the
    relative path of the `auxiliary` module. Once the module has been selected, the
    `show options` command can be used to identify and/or modify scan configurations.
    This command will display four column headers to include: `Name`, `Current Setting`,
    `Required`, and `Description`. The `Name` column identifies the name of each configurable
    variable. The `Current Setting` column lists the existing configuration for any
    given variable. The `Required` column identifies whether a value is required for
    any given variable. The `Description` column describes the function of each variable.
    The value for any given variable can be changed using the `set` command and by
    providing the new value as an argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00286.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the example provided, the `RHOSTS` value was changed to the IP address of
    the remote system that we wish to scan. Additionally, the number of threads has
    changed to `20`. The `THREADS` value defines the number of concurrent tasks that
    will be performed in the background. Determining thread values consists of finding
    a good balance that will noticeably improve the speed of the task without overly
    depleting system resources. For most systems, `20` threads is a fast and reasonably
    safe number of concurrent processes. After the necessary variables have been updated,
    the configurations can be verified using the `show options` command again. Once
    the desired configurations have been verified, the scan can be launched, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00469.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `run` command is used in Metasploit to execute the selected `auxiliary`
    module. In the example provided, the `run` command executed a UDP sweep against
    the specified IP address. The `udp_sweep` module can also be run against a sequential
    series of addresses using dash notation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00621.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the example provided, a UDP scan was performed against ten host addresses
    that were specified by the `RHOSTS` variable. Similarly, `RHOSTS` can be used
    to define a network range using the CIDR notation, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00475.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Stealth scanning with Metasploit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Metasploit has an `auxiliary` module that can be used to perform SYN scans
    on specified TCP ports:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To open up Metasploit in Kali Linux, we use the `msfconsole` command in a Terminal
    session, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00642.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To run the SYN scan module in Metasploit, call the `use` command with the relative
    path of the `auxiliary` module. Once the module has been selected, the `show options`
    command can be used to identify and/or modify scan configurations. This command
    will display four column headers to include `Name`, `Current Setting`, `Required`,
    and `Description`. The `Name` column identifies the name of each configurable
    variable. The `Current Setting` column lists the existing configuration for any
    given variable. The `Required` column identifies whether a value is required for
    any given variable. Finally, the `Description` column describes the function of
    each variable. The value for any given variable can be changed using the `set`
    command and by providing the new value as an argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00646.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the example provided, the `RHOSTS` value was changed to the IP address of
    the remote system that we wish to scan. Additionally, the number of threads is
    changed to `20`. The `THREADS` value defines the number of concurrent tasks that
    will be performed in the background. Determining thread values consists of finding
    a good balance that will noticeably improve the speed of the task without overly
    depleting system resources. For most systems, `20` threads is a fast and reasonably
    safe number of concurrent processes. The `PORTS` value is set to the TCP port
    `80` (HTTP). After the necessary variables have been updated, the configurations
    can again be verified using the `show options` command. Once the desired configurations
    have been verified, the scan can be launched as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00481.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `run` command is used in Metasploit to execute the selected `auxiliary`
    module. In the example provided, the `run` command executed a TCP SYN scan against
    the port `80` of the specified IP address. We can also run this TCP SYN scan module
    against a sequential series of TCP ports by supplying the first and last values,
    separated using dash notation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00669.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the example provided, a TCP SYN scan was performed on the first 100 TCP
    port addresses of the remote host that was specified. Although this scan identified
    multiple services on the target system, we cannot possibly be sure that all services
    have been identified unless all of the possible port addresses have been scanned.
    The portions of the TCP header that define the source and destination port addresses
    are both 16 bits in length. Furthermore, each bit can retain a value of 1 or 0\.
    As such, there are 2^(16), or 65,536, possible TCP port addresses. For the total
    possible address space to be scanned, a port range of 0 to 65535 needs to be supplied,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00154.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the example provided, all of the open TCP ports on the remote system were
    identified by scanning all of the possible TCP port addresses. We can also modify
    the scan configurations to scan a sequential series of addresses using dash notation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00014.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the example provided, a TCP SYN scan was performed on the port `80` against
    all of the host addresses specified by the `RHOSTS` variable. Similarly, `RHOSTS`
    can be used to define a network range using CIDR notation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00303.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Connect scanning with Metasploit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Metasploit has an `auxiliary` module that can be used to perform TCP connect
    scans on specified TCP ports:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To open up Metasploit in Kali Linux, use the `msfconsole` command in a Terminal
    session, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00389.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To call the TCP connect scan module in Metasploit, use the `use` command with
    the relative path of the `auxiliary` module. Once the module has been selected,
    the `show options` command can be used to identify and/or modify scan configurations.
    This command will display four column headers to include: `Name`, `Current Setting`,
    `Required`, and `Description`. The `Name` column identifies the name of each configurable
    variable. The `Current Setting` column lists the existing configuration for any
    given variable. The `Required` column identifies whether a value is required for
    any given variable. Finally, the `Description` column describes the function of
    each variable. We can change the value for any given variable using the `set`
    command and by providing the new value as an argument, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00474.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In the example provided, the `RHOSTS` value was changed to the IP address of
    the remote system that we wish to scan. The `PORTS` value is set to the TCP port
    `80` (HTTP). After the necessary variables have been updated, the configurations
    can be verified again using the `show options` command. Once the desired configurations
    have been verified, the scan is launched. The `run` command is used in Metasploit
    to execute the selected `auxiliary` module. In the example provided, the `run`
    command executes a TCP connect scan against the port `80` of the specified IP
    address.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This TCP connect scan can also be performed against a sequential series of
    TCP ports by supplying the first and last values, separated by a dash:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00497.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the example provided, the first 100 TCP port addresses were set to be scanned.
    Additionally, the number of threads was changed to `20.` The `THREADS` value defines
    the number of concurrent tasks that will be performed in the background. Determining
    thread values consists of finding a good balance that will noticeably improve
    the speed of the task without overly depleting system resources. For most systems,
    `20` threads is a fast and reasonably safe number of concurrent processes. Although
    this scan identified multiple services on the target system, one cannot be sure
    that all services have been identified unless all of the possible port addresses
    have been scanned. The portions of the TCP header that define the source and destination
    port addresses are both 16 bits in length. Moreover, each bit can retain a value
    of 1 or 0\. As such, there are 2^(16), or 65,536, possible TCP port addresses.
    For the total possible address space to be scanned, a port range of 0 to 65535
    needs to be supplied, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00079.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the example provided, all of the open TCP ports on the remote system were
    identified by scanning all of the possible TCP port addresses. We can also modify
    the scan configurations to scan a sequential series of addresses using dash notation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00657.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the example provided, a TCP connect scan is performed on the ports `22`,
    `80`, and `443` on all of the host addresses specified by the `RHOSTS` variable.
    Similarly, `RHOSTS` can be used to define a network range using CIDR notation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00506.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: UDP scanning with the Metasploit `auxiliary` module is less comprehensive than
    UDP scanning with Nmap. It only targets a limited number of services, but it is
    highly effective at identifying live services on these ports and faster than most
    other available UDP scanning solutions.
  prefs: []
  type: TYPE_NORMAL
- en: The underlying principle behind Metasploit's SYN scan the `auxiliary` module
    is essentially the same as any other SYN scanning tool. For each port that is
    scanned, a SYN packet is sent, and the SYN+ACK responses are used to identify
    live services. Using Metasploit might be more appealing to some because of the
    interactive console and also because it is a tool that is already well known by
    most penetration testers.
  prefs: []
  type: TYPE_NORMAL
- en: The underlying principle that defines how a TCP connect scan is performed by
    Metasploit is the same as previously discussed with other tools. The advantage
    of performing this type of scan using Metasploit is that it can cut down on the
    total number of tools that one needs to familiarize oneself with.
  prefs: []
  type: TYPE_NORMAL
- en: Port scanning with hping3 (stealth)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to the discovery techniques that we've learned, the `hping3` command
    can also be used to perform port scans. This specific recipe demonstrates how
    we can use the `hping3` command to perform a TCP stealth scan.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To use the `hping3` command to perform a TCP stealth scan, you will need to
    have a remote system that is running accessible network services over TCP. In
    the examples provided, an instance of Metasploitable2 is used to perform this
    task. For more information on how to set up Metasploitable2, refer to [Chapter
    1](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426), *Getting Started*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In addition to the discovery capabilities that have already been mentioned,
    the `hping3` command can also be used to perform a TCP port scan:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To perform a port scan with `hping3`, we need to use the `--scan` mode with
    an integer value to indicate the port number to be scanned:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00121.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the example provided, a SYN scan was performed against the TCP port `80`
    of the IP address indicated. The `-S` option identifies the TCP flags activated
    in the packet sent to the remote system. The table indicates the attributes of
    the packet received in response. As indicated by the output, a SYN+ACK response
    was received, thereby indicating that port `80` is open on the target host. Additionally,
    we can scan multiple ports by passing a comma-delimited series of port numbers,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00511.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the scan output provided, you can see that the results are only displayed
    if a SYN+ACK response is received. Note that the response associated with the
    SYN request sent to the port `443` is not displayed. As indicated in the output,
    we can view all of the responses by increasing the verbosity with the `-v` option.
    Additionally, a sequential range of ports can be scanned by passing the first
    and last port address values separated with dash notation, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00513.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the example provided, the 100-port scan was sufficient to identify several
    services on the Metasploitable2 system. However, to perform a scan of all possible
    TCP ports, all of the possible port address values need to be scanned. The portions
    of the TCP header that define the source and destination port addresses are both
    16 bits in length, and each bit can retain a value of 1 or 0\. As such, there
    are 2^(16), or 65,536 possible TCP port addresses. For the total possible address
    space to be scanned, a port range of 0 to 65535 needs to be supplied, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00324.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `hping3` utility differs from some of the other tools that have been mentioned
    since it doesn't have a SYN scanning mode, but rather it allows you to specify
    the TCP flag bits that are activated when the TCP packets are sent. In the example
    provided in this recipe, the `-S` option instructed `hping3` to use the SYN flag
    for the TCP packets that were sent.
  prefs: []
  type: TYPE_NORMAL
- en: Port scanning with DMitry (connect)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another alternative tool that can be used to perform TCP connect scans on remote
    systems is DMitry. Unlike Nmap and Metasploit, DMitry is a very simple tool that
    we can use to perform quick and easy scans without the overhead of managing configurations.
    This specific recipe demonstrates how we can use DMitry to perform a TCP connect
    scan.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To use the `dmitry` command to perform a full connect scan, you will need to
    have a remote system that is running network services over TCP. In the examples
    provided, an instance of Metasploitable2 is used to perform this task. For more
    information on how to set up Metasploitable2, refer to [Chapter 1](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426),
    *Getting Started*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'DMitry is a multipurpose tool that can be used to perform a TCP scan on a target
    system. Its capabilities are somewhat limited, but it is a simple tool that can
    be used quickly and effectively:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To view the options available for the `dmitry` command, we execute the following
    program in a Terminal without any arguments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00517.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As indicated in the usage output, the `-p` option can be used to perform a
    TCP port scan. To do this, we use this option with the IP address of the system
    to be scanned. DMitry has 150 commonly used preconfigured ports that it will scan
    for. Out of these ports, it will display any that it finds open. Consider the
    following example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00492.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'There is not much customization available for TCP port scanning with DMitry,
    but it can be a quick and effective way to assess the commonly used services on
    a single host. We can also output the results of a DMitry scan to a text file
    using the `-o` option and by specifying the name of the file to be output in the
    execution directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00522.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The underlying principle that defines how a TCP connect scan is performed by
    the `dmitry` command is the same as was previously discussed with other tools.
    The usefulness of DMitry mostly lies in its simplicity in comparison with other
    tools. Rather than managing several configuration options, as we need to with
    Nmap or Metasploit, we can easily launch DMitry by specifying the appropriate
    mode and passing it the target IP address. It quickly scans the most commonly
    used 150 ports and outputs the values of all of the open ports among these.
  prefs: []
  type: TYPE_NORMAL
- en: Port scanning with Netcat (connect)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since Netcat is a network socket connection and management utility, it can easily
    be transformed into a TCP port-scanning utility. This specific recipe demonstrates
    how we can use Netcat to perform a TCP connect scan.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To use Netcat to perform a full connect scan, you will need to have a remote
    system that is running network services over TCP. In the examples provided, an
    instance of Metasploitable2 is used to perform this task. For more information
    on how to set up Metasploitable2, refer to [Chapter 1](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426),
    *Getting Started*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Netcat is an extremely useful, multipurpose networking utility that can be
    used for a plethora of purposes. One effective use of Netcat is to perform port
    scans:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To identify the usage options, Netcat (`nc`) should be called with the `-h`
    option, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00225.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As indicated by the usage output, the `-z` option can effectively be used for
    scanning. To scan the TCP port `80` on a target system, we use the `-n` option
    to indicate that an IP address will be used, the `-v` option for verbose output,
    and the `-z` option for scanning, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00671.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Performing a scan attempt against an open port will return the IP address,
    port address, and port status. Performing the same scan against a closed port
    on a live host will indicate that the connection was refused. We can automate
    this in a loop, as shown in the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00527.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'A sequential series of port numbers can be passed through a loop, and all of
    the ports can be scanned easily and quickly. However, in the example provided,
    the output for both open and closed ports is included. This is acceptable only
    if a small number of ports are being scanned. However, if a large number of ports
    are being scanned, it might be inconvenient to sort through all of the closed
    ports to find the ones that are open. As such, we can instinctively try to pipe
    over the output and grep out the lines associated with the open ports, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00124.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'However, in attempting to pipe over the output and grepping from it, the total
    output is still returned. This is because Netcat outputs to `STDERR` instead of
    `STDOUT`. To effectively grep from the output of this tool, one must redirect
    the output to `STDOUT` with `2>&1`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00532.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'By passing the output to `STDOUT` and then grepping from that output, we are
    able to isolate the lines of output that provide details on the open ports. We
    can be even more concise by only extracting the information that we need from
    these lines. If a single host is being scanned, we will likely only benefit from
    the third and fourth fields:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00543.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To extract these fields from the output, the `cut` function can be used to
    separate the line with a space delimiter and then by specifying the fields to
    be output. However, there is also an effective way to specify a range of ports
    within Netcat without passing the tool through a loop. By passing `nc` as a sequential
    series of port address values, Netcat will automatically display only the open
    ports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00536.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Just the same, however, we need to pass its output to `STDOUT` to be able to
    pipe it over to the `cut` function. By displaying fields `2` through `4`, we can
    limit the output to the IP address, port address, and associated service, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00325.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Using a loop function in bash, we can scan multiple sequential host addresses
    with Netcat and then extract the same details to identify which ports are open
    on the various scanned IP addresses:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00343.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tools that perform TCP connect scans operate by performing a full three-way
    handshake to establish a connection with all of the scanned ports on the remote
    target system. A port's status is determined based on whether a connection was
    established or not. If a connection was established, the port is determined to
    be open. If a connection could not be established, the port is determined to be
    closed.
  prefs: []
  type: TYPE_NORMAL
- en: Port scanning with masscan (stealth)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `masscan` utility is the fastest Internet port scanner; in fact, it is capable
    of scanning the entire Internet in under 6 minutes. This obviously requires adequate
    hardware and network bandwidth. The `masscan` utility runs using asynchronous
    transmission, which is what allows it to scan so quickly. One thing to be aware
    of with masscan is that it utilizes its own custom TCP/IP stack, so some care
    needs to be taken to avoid conflicts with the local TCP/IP stack. This specific
    recipe demonstrates how we can use the `masscan` command to perform a TCP stealth
    scan.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To use the `masscan` command to perform a stealth scan, you will need to have
    a remote system that is running network services over TCP. In the examples provided,
    an instance of Metasploitable2 is used to perform this task. For more information
    on how to set up Metasploitable2, refer to [Chapter 1](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426),
    *Getting Started*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow along to stealth scan using the `masscan` command:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `masscan` utility is an extraordinarily fast port scanner. To see the `masscan`
    help file, the `masscan` command should be called with the `-h` option, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00368.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The makers of masscan did their best to make the usage similar to Nmap. To
    see `masscan` usage options, call the `masscan` command followed by the `--nmap`
    option, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00387.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'When using `masscan` instead of `nmap`, you can think of it as if the `-sS`
    flag were permanently set. So we do not need to tell it we are doing a stealth
    scan. One difference between `masscan` and `nmap` is there are no default ports
    set, so we must define what ports we want to check. A masscan scan will use the `masscan`
    command, the IP address of the host to be scanned, and `-p` (port/s) to be scanned,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00172.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the example provided, a SYN scan was performed on the TCP port `80` of the
    specified IP address. Similar to the technique explained with Nmap, `masscan`
    listens for a response and identifies the open ports by analyzing the TCP flags
    that are activated in any responses received. We can also use the `masscan` command to
    perform scans on multiple specified ports by passing a comma-delimited list of
    port numbers, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00425.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the example provided, a SYN scan was performed on the ports `21`, `80`,
    and `443` of the specified target IP address. We can also use Nmap to scan a sequential
    series of hosts by indicating the first and last port numbers to be scanned, separated
    using dash notation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00443.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If a scan is to be performed on all possible TCP ports, all of the possible
    port address values need to be scanned. The portions of the TCP header that define
    the source and destination port addresses are both 16 bits in length. Moreover,
    each bit can retain a value of 1 or 0\. As such, there are 2^(16), or 65,536,
    possible TCP port addresses. For the total possible address space to be scanned,
    a port range of 0 to 65535 needs to be supplied, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00180.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the example provided, all of the 65,536 possible TCP addresses were scanned
    on the Metasploitable2 system. A full scan is always best practice when attempting
    to identify all of the possible attack surface on a target. The `masscan` command can
    also be used to scan TCP ports on a sequential series of hosts using dash notation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00183.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the example provided, a SYN scan of the TCP port `80` was performed on all
    of the hosts within the range of addresses specified. Although this particular
    scan was only performed on a single port, `masscan` also has the ability to scan
    multiple ports and ranges of ports on multiple systems simultaneously. Additionally,
    masscan can also be configured to scan hosts based on an input list of IP addresses.
    This can be done using the `-iL` option and then specifying either the filename,
    if the file exists in the execution directory, or the path of the file. The `masscan`
    utility then cycles through each address in the input list and performs the specified
    scan against that address:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00487.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The underlying principle behind SYN scanning with `masscan` is the same as has
    already been discussed. However, with asynchronous mode, `masscan` is a fast and
    highly effective way to perform these types of scans. The `masscan` utility provides
    you with the fastest way to scan the Internet and collect information. It uses
    a custom TCP/IP stack to avoid conflicts and offer you the best compatibility
    and flexibility.
  prefs: []
  type: TYPE_NORMAL
