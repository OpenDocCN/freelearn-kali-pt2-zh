<html><head></head><body>
  <div id="_idContainer169" class="Basic-Text-Frame">
    <h1 class="chapterNumber">4</h1>
    <h1 id="_idParaDest-117" class="chapterTitle">Vulnerability Assessment</h1>
    <p class="normal">The goal of passive and active reconnaissance is to identify an exploitable target, and the goal of vulnerability assessment is to find the security flaws that are most likely to support the tester’s or attacker’s objective (unauthorized access, modification of data, or denial of service). The vulnerability assessment during the exploit phase of the kill chain focuses on creating the access to achieve the objective mapping of the vulnerabilities to line up the exploits and maintain persistent access to the target.</p>
    <p class="normal">Thousands of exploitable vulnerabilities have been identified, and most are associated with at least one proof-of-concept code file or technique to allow the system to be compromised. Nevertheless, the underlying principles that govern success are the same across networks, operating systems, and applications.</p>
    <p class="normal">In this chapter, you will learn about the following:</p>
    <ul>
      <li class="bulletList">Using online and local vulnerability resources</li>
      <li class="bulletList">Vulnerability scanning with Nmap</li>
      <li class="bulletList">Lua scripting</li>
      <li class="bulletList">Writing your own Nmap script using the <strong class="keyWord">Nmap Scripting Engine</strong> (<strong class="keyWord">NSE</strong>)</li>
      <li class="bulletList">Selecting and customizing multiple vulnerability scanners</li>
      <li class="bulletList">Installing Nessus in Kali and exploring Qualys’ online community scanner</li>
      <li class="bulletList">Web- and application-specific scanners </li>
      <li class="bulletList">Threat modeling in general</li>
    </ul>
    <h1 id="_idParaDest-118" class="heading-1">Vulnerability nomenclature</h1>
    <p class="normal">Vulnerability scanning employs automated processes and applications to identify vulnerabilities <a id="_idIndexMarker432"/>in a network, system, operating system, or application that may be exploitable.</p>
    <p class="normal">When performed correctly, a vulnerability scan delivers an inventory of devices (both authorized and rogue devices), known vulnerabilities that have been actively scanned for, and usually a confirmation of how compliant the devices are with various policies and regulations.</p>
    <p class="normal">Unfortunately, vulnerability scans are loud; they deliver multiple packets that are easily detected by most network controls and make stealth almost impossible to achieve. They also suffer <a id="_idIndexMarker433"/>from the following limitations:</p>
    <ul>
      <li class="bulletList">For the most part, vulnerability scanners are signature-based; they can only detect known vulnerabilities, and only if there is an existing recognition signature that the scanner can apply to the target. To a penetration tester, the most effective scanners are open source; they allow the tester to rapidly modify code to detect new vulnerabilities.</li>
      <li class="bulletList">Scanners produce large volumes of output, frequently containing false-positive results that can lead a tester astray; in particular, networks with different operating systems can produce false positives with a rate as high as 70 percent.</li>
      <li class="bulletList">Scanners may have a negative impact on the network; they can create network latency or cause the failure of some devices. It is recommended to tweak the scan by removing denial-of-service type plugins during initial scans.</li>
      <li class="bulletList">In certain jurisdictions, scanning is considered hacking, and may constitute an illegal act.</li>
    </ul>
    <p class="normal">There are multiple commercial and open-source products that perform vulnerability scans. </p>
    <h1 id="_idParaDest-119" class="heading-1">Local and online vulnerability databases</h1>
    <p class="normal">Together, passive <a id="_idIndexMarker434"/>and active reconnaissance identify the attack surface of the target, that is, the total number of points that can be assessed for vulnerabilities. A server with just an operating system installed can only be exploited if there are vulnerabilities in that particular operating system; however, the number of potential vulnerabilities increases with each application that is installed.</p>
    <p class="normal">Penetration testers and attackers must find the particular exploits that will compromise known and suspected vulnerabilities. The first place to start the search is at vendor sites; most hardware and application vendors release vulnerability information when they release patches and upgrades. If an exploit for a particular weakness is known, most vendors <a id="_idIndexMarker435"/>will highlight this to their customers. </p>
    <p class="normal">Although their intent is to allow customers to test for the presence of the vulnerability themselves, attackers and penetration testers will take advantage of this information as well.</p>
    <p class="normal">Other online sites that collect, analyze, and share information about vulnerabilities are as follows:</p>
    <ul>
      <li class="bulletList">The National Vulnerability Database, which consolidates all public vulnerability <a id="_idIndexMarker436"/>data released by the US Government, available at <a href="http://web.nvd.nist.gov/view/vuln/search"><span class="url">http://web.nvd.nist.gov/view/vuln/search</span></a></li>
      <li class="bulletList">Packet Storm Security, available <a id="_idIndexMarker437"/>at <a href="https://packetstormsecurity.com/"><span class="url">https://packetstormsecurity.com/</span></a></li>
      <li class="bulletList">SecurityFocus, available <a id="_idIndexMarker438"/>at <a href="http://www.securityfocus.com/vulnerabilities"><span class="url">http://www.securityfocus.com/vulnerabilities</span></a></li>
      <li class="bulletList">The Exploit database <a id="_idIndexMarker439"/>maintained by Offensive Security, available at <a href="https://www.exploit-db.com/"><span class="url">https://www.exploit-db.com/</span></a></li>
      <li class="bulletList">For some <a id="_idIndexMarker440"/>0-day vulnerabilities, penetration testers can also keep an eye on <a href="https://0day.today/"><span class="url">https://0day.today/</span></a></li>
    </ul>
    <p class="normal">The Exploit database is also copied locally to Kali, and it can be found in the <code class="inlineCode">/usr/share/exploitdb</code> directory.</p>
    <p class="normal">To search the local copy of <code class="inlineCode">exploitdb</code>, open a Terminal window and enter <code class="inlineCode">searchsploit</code> and the desired search term(s) in the command prompt. This will invoke a script that searches a database file (<code class="inlineCode">.csv</code>) that contains a list of all exploits. The search will return a description of known vulnerabilities as well as the path to a relevant exploit. The exploit can be extracted, compiled, and run against specific vulnerabilities. Take a look at <em class="italic">Figure 4.1</em>, which shows the description of the <code class="inlineCode">exchange windows</code> vulnerabilities:</p>
    <figure class="mediaobject"><img src="../Images/B17765_04_01.png" alt=""/></figure>
    <p class="packt_figref">Figure 4.1: Searching in searchsploit with keywords</p>
    <p class="normal">The search script scans for each line in the CSV file from left to right, so the order of the search terms <a id="_idIndexMarker441"/>is important; a search for <code class="inlineCode">Oracle 10g</code> will return several exploits, but <code class="inlineCode">10g Oracle</code> will not return any. </p>
    <p class="normal">Also, the script is weirdly case sensitive; although you are instructed to use lowercase characters in the search term, a search for <code class="inlineCode">vsFTPd</code> returns no hits, but <code class="inlineCode">vs FTPd</code> returns more hits with a space between <code class="inlineCode">vs</code> and <code class="inlineCode">FTPd</code>. More effective searches of the CSV file can be conducted using the <code class="inlineCode">grep</code> command or a search tool such as <code class="inlineCode">KWrite</code> (<code class="inlineCode">apt-get install kwrite</code>).</p>
    <p class="normal">A search of the local database may identify several possible exploits with a description and a path listing; however, these will have to be customized to your environment, and then compiled prior to use. Copy the exploit to the <code class="inlineCode">/tmp</code> directory (the given path does not take into account that the <code class="inlineCode">/windows/remote</code> directory resides in the <code class="inlineCode">/platforms</code> directory).</p>
    <p class="normal">Exploits presented as scripts such as Perl, Ruby, and PHP authentication are relatively easy to implement. For example, if the target is a Microsoft Exchange 2019 server that may be vulnerable to remote code execution using valid credentials, copy the exploit to the <code class="inlineCode">root</code> directory and then execute as a standard Python file, as shown in <em class="italic">Figure 4.2</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_04_02.png" alt=""/></figure>
    <p class="packt_figref">Figure 4.2: Running the Python script from exploit-db for the Microsoft exchange server vulnerability</p>
    <p class="normal">Many of the exploits are available as source code that must be compiled before use. For example, a search for Windows RPC-specific vulnerabilities identifies several possible exploits.</p>
    <p class="normal">The RPC DCOM vulnerability identified as <code class="inlineCode">76.c</code> is known from practice to be relatively stable. So, we will <a id="_idIndexMarker442"/>use it as an example. To compile this exploit, copy it from the storage directory to the <code class="inlineCode">/tmp</code> directory. In that location, compile it using GCC with the command that follows:</p>
    <pre class="programlisting con"><code class="hljs-con">root@kali:~# gcc 76.c -o exploit
</code></pre>
    <p class="normal">This will use the GNU Compiler Collection application to compile <code class="inlineCode">76.c</code> to a file with the output (<code class="inlineCode">-o</code>) name of <code class="inlineCode">76.exe</code>, as shown in <em class="italic">Figure 4.3</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_04_03.png" alt=""/></figure>
    <p class="packt_figref">Figure 4.3: Compiling the c file to create the exploit executable</p>
    <p class="normal">Although we get some warnings and a note, the compilation was successful without any error messages. When you invoke the application against the target, you must call the executable (which is not stored in the <code class="inlineCode">/tmp</code> directory) using a symbolic link as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">root@kali:~# ./exploit
</code></pre>
    <p class="normal">The source code for this exploit is well documented and the required parameters are clear at execution, as shown in <em class="italic">Figure 4.4</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_04_04.png" alt=""/></figure>
    <p class="packt_figref">Figure 4.4: Running the compiled exploit</p>
    <p class="normal">Unfortunately, not all <a id="_idIndexMarker443"/>exploits from the Exploit database and other public sources compile as readily as <code class="inlineCode">76.c</code>. There are several issues that make the use of such exploits problematic, even dangerous, for penetration testers, which are listed as follows:</p>
    <ul>
      <li class="bulletList">Deliberate errors or incomplete source code are commonly encountered as experienced developers attempt to keep exploits away from inexperienced users, especially beginners who are trying to compromise systems without knowing the risks that go with their actions.</li>
      <li class="bulletList">Exploits are not always sufficiently documented; after all, there is no standard that governs the creation and use of code intended to be used to compromise a data system. As a result, they can be difficult to use, particularly for testers who lack expertise in application development.</li>
      <li class="bulletList">Inconsistent behaviors due to changing environments (new patches applied to the target system and language variations in the target application) may require significant alterations to the source code; again, this may require a skilled developer.</li>
      <li class="bulletList">There is always the risk of freely available code containing malicious functionalities. A penetration tester may think that they are conducting a <strong class="keyWord">proof of concept</strong> (<strong class="keyWord">POC</strong>) exercise and will be unaware that the exploit has also <a id="_idIndexMarker444"/>created a backdoor in the application being tested that could be used by the developer.</li>
    </ul>
    <p class="normal">To ensure <a id="_idIndexMarker445"/>consistent results and create a community of coders who follow consistent practices, several exploit frameworks have been developed. The most popular exploitation framework is the Metasploit framework, and we will explore more about Metasploit in <em class="chapterRef">Chapter 10</em>, <em class="italic">Exploitation</em>.</p>
    <p class="normal">Next, let’s explore the different tools that penetration testers can leverage during vulnerability scanning.</p>
    <h1 id="_idParaDest-120" class="heading-1">Vulnerability scanning with Nmap</h1>
    <p class="normal">There are no security operating distributions without Nmap. So far, we have discussed how to <a id="_idIndexMarker446"/>utilize Nmap during active reconnaissance, but <a id="_idIndexMarker447"/>attackers don’t just use Nmap to find open ports and services, but also engage Nmap to perform the vulnerability assessment. As of December 21, 2021, the latest version of Nmap is 7.92 and it ships with 600+ NSE scripts, as shown in <em class="italic">Figure 4.5</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_04_05.png" alt=""/></figure>
    <p class="packt_figref">Figure 4.5: Viewing all the scripts in the /usr/share/nmap/scripts folder</p>
    <p class="normal">Penetration <a id="_idIndexMarker448"/>testers utilize Nmap’s most powerful <a id="_idIndexMarker449"/>and flexible features, which allow them to write their own scripts and also automate them to simplify the exploitation. Primarily, the NSE was developed for the following reasons:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Network discovery</strong>: The <a id="_idIndexMarker450"/>primary purpose that attackers utilize Nmap for is network discovery, as we learned in the active reconnaissance section in <em class="chapterRef">Chapter 3</em>, <em class="italic">Active Reconnaissance of External and Internal Networks</em>.</li>
      <li class="bulletList"><strong class="keyWord">Classier version detection of a service</strong>: There are thousands of services with multiple <a id="_idIndexMarker451"/>version details for the same service, so Nmap makes it easier to identify the service.</li>
      <li class="bulletList"><strong class="keyWord">Vulnerability detection</strong>: To automatically identify vulnerability in a vast network <a id="_idIndexMarker452"/>range; however, Nmap cannot be a full vulnerability scanner in itself.</li>
      <li class="bulletList"><strong class="keyWord">Backdoor detection</strong>: Some of the scripts are written to identify the pattern of backdoors. If <a id="_idIndexMarker453"/>there are any worms infecting the network, it makes the attacker’s job easy to narrow down and focus on taking over the machine remotely.</li>
      <li class="bulletList"><strong class="keyWord">Vulnerability exploitation</strong>: Attackers can also potentially utilize Nmap to perform <a id="_idIndexMarker454"/>exploitation in combination with other tools, such as Metasploit, or write custom reverse shell code and combine Nmap’s capability with them for exploitation.</li>
    </ul>
    <p class="normal">Before <a id="_idIndexMarker455"/>firing up Nmap to perform a vulnerability scan, penetration testers must update the Nmap script database to see whether <a id="_idIndexMarker456"/>there are any new scripts added to the database, so that they don’t miss the vulnerability identification:</p>
    <pre class="programlisting con"><code class="hljs-con">sudo nmap --script-updatedb
</code></pre>
    <p class="normal">Use the following to run all the scripts against the target host:</p>
    <pre class="programlisting con"><code class="hljs-con">sudo nmap -T4 -A -sV -v3 -d -oA Target output --script all --script-argsvulns.showall target.com
</code></pre>
    <h2 id="_idParaDest-121" class="heading-2">Introduction to Lua scripting</h2>
    <p class="normal">Lua is a lightweight embeddable scripting language that is built on top of the C programming <a id="_idIndexMarker457"/>language, was created in Brazil in 1993, and is still actively developed. It is a powerful and fast programming language mostly used in gaming applications and image processing. The complete source code, manual, and binaries for some platforms do not go beyond 1.44 MB (which is less than a floppy disk). Some of the security tools that are developed in Lua are Nmap, Wireshark, and Snort 3.0.</p>
    <p class="normal">One of the reasons why Lua was chosen to be the scripting language in information security is its compactness, no buffer overflows and format string vulnerabilities, and because it can be interpreted.</p>
    <p class="normal">Lua can be installed directly in Kali Linux by issuing the <code class="inlineCode">sudo apt install lua5.4</code> command in the terminal. The following code extract is the sample script to read the file and print the first line:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">#!/usr/bin/lua </span>
<span class="hljs-built_in">local</span> file = io.open(<span class="hljs-string">"/etc/shadow"</span>, <span class="hljs-string">"r"</span>)
contents = file:<span class="hljs-built_in">read</span>()
file:close()
<span class="hljs-built_in">print</span> (contents)
</code></pre>
    <p class="normal">Lua is similar <a id="_idIndexMarker458"/>to any other scripting, such as Bash and Perl scripting. The preceding script should produce the output shown in <em class="italic">Figure 4.6</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_04_06.png" alt=""/></figure>
    <p class="packt_figref">Figure 4.6: Running a Lua script to display the /etc/shadow file</p>
    <h2 id="_idParaDest-122" class="heading-2">Customizing NSE scripts</h2>
    <p class="normal">To achieve maximum effectiveness, the customization of scripts helps penetration testers to <a id="_idIndexMarker459"/>find the right vulnerabilities in a timely fashion. However, most of the time, attackers do not have the time to write one. The following code extract is a Lua NSE script to identify a specific file location that we will search for on the entire subnet using Nmap:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in">local</span> http=require <span class="hljs-string">'http'</span> 
description = [[ This is my custom discovery on the network ]] 
categories = {<span class="hljs-string">"safe"</span>,<span class="hljs-string">"discovery"</span>} 
require(<span class="hljs-string">"http"</span>)
<span class="hljs-keyword">function</span> portrule(host, port) 
  <span class="hljs-built_in">return</span> port.number == 80 
end
 
<span class="hljs-keyword">function</span> action(host, port) 
  <span class="hljs-built_in">local</span> response 
  response = http.get(host, port, <span class="hljs-string">"/config.php"</span>) 
  <span class="hljs-keyword">if</span> response.status and response.status ~= 404 
    <span class="hljs-keyword">then</span> 
    <span class="hljs-built_in">return</span> <span class="hljs-string">"successful"</span> 
  end 
end
</code></pre>
    <p class="normal">Save the file <a id="_idIndexMarker460"/>into the <code class="inlineCode">/usr/share/nmap/scripts/</code> folder. Finally, your script is ready to be tested, as shown in <em class="italic">Figure 4.7</em>; you must be able to run your own NSE script without any problems:</p>
    <figure class="mediaobject"><img src="../Images/B17765_04_07.png" alt=""/></figure>
    <p class="packt_figref">Figure 4.7: Running our newly created Nmap script</p>
    <p class="normal">To completely understand the preceding NSE script, here is a description of what is in the code:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">local http: require'http'</code>: This calls the right library from Lua; this line calls the HTTP script and makes it a local request.</li>
      <li class="bulletList"><code class="inlineCode">description</code>: This is where testers/researchers can enter the description of the script.</li>
      <li class="bulletList"><code class="inlineCode">categories</code>: This typically has two variables, one of which declares whether it is safe or intrusive.</li>
    </ul>
    <h1 id="_idParaDest-123" class="heading-1">Web application vulnerability scanners</h1>
    <p class="normal">Vulnerability scanners suffer from the common shortcomings of all scanners (scanners can only <a id="_idIndexMarker461"/>detect the signature of a known vulnerability; they cannot determine if the vulnerability can actually be exploited; there is a high incidence of false-positive reports). Furthermore, web vulnerability scanners cannot identify complex errors in business logic, and they do not accurately simulate the complex chained attacks used by hackers.</p>
    <p class="normal">In an effort to increase reliability, most penetration testers use multiple tools to scan web services. When multiple tools report that a particular vulnerability may exist, this consensus will direct the tester to areas that may require manually verifying the findings.</p>
    <p class="normal">Kali comes with an extensive number of vulnerability scanners for web services and provides a stable platform for installing new scanners and extending their capabilities. This allows penetration testers to increase the effectiveness of testing by selecting scanning tools that do the following:</p>
    <ul>
      <li class="bulletList">Maximize the completeness (the total number of vulnerabilities that are identified) and accuracy (the vulnerabilities that are real and not false-positive results) of testing.</li>
      <li class="bulletList">Minimize the time required to obtain usable results.</li>
      <li class="bulletList">Minimize the negative impacts on the web services being tested. This can include slowing down the system due to an increase in traffic throughput. For example, one of the most common negative effects is a result of testing forms that input data to a database, and then emailing an individual providing an update of the change that has been made; uncontrolled testing of such forms can result in more than 30,000 emails being sent!</li>
    </ul>
    <p class="normal">There is significant complexity in choosing the most effective tool. In addition to the factors already listed, some vulnerability scanners will also launch the appropriate exploit and support post-exploit activities. For our purposes, we will consider all tools that scan for exploitable weaknesses to be vulnerability scanners. Kali provides access to several <a id="_idIndexMarker462"/>different vulnerability scanners, including the following:</p>
    <ul>
      <li class="bulletList">Scanners that extend the functionality of traditional vulnerability scanners to include websites and associated services (for example, the Metasploit framework and Websploit)</li>
      <li class="bulletList">Scanners that extend the functionality of non-traditional applications, such as web browsers, to support web service vulnerability scanning (OWASP Mantra)</li>
      <li class="bulletList">Scanners that are specifically developed to support reconnaissance and exploit detection in websites and web services (Arachni, Nikto, Skipfish, WPScan, joomscan, and so on)</li>
    </ul>
    <h2 id="_idParaDest-124" class="heading-2">Nikto</h2>
    <p class="normal">Nikto is one <a id="_idIndexMarker463"/>of the most utilized active web <a id="_idIndexMarker464"/>application scanners. It performs comprehensive tests against web servers. Its basic functionality is to check for 6,700+ potentially dangerous files or programs, along with outdated versions of servers and vulnerabilities specific to versions of over 270 servers. Nikto identifies server misconfiguration, index files, and HTTP methods, and also finds the installed web server and the software version. Nikto is released based <a id="_idIndexMarker465"/>on Open-General Public License versions (<a href="https://opensource.org/licenses/gpl-license"><span class="url">https://opensource.org/licenses/gpl-license</span></a>).</p>
    <p class="normal">Nikto is a Perl-based open-source scanner that allows IDS evasion and user changes to scan modules; however, this original web scanner is beginning to show its age and is not as accurate as some of the more modern scanners.</p>
    <p class="normal">Most testers start testing a website by using Nikto, a simple scanner (particularly concerning reporting) that generally provides accurate but limited results; a sample output of this scan is shown in <em class="italic">Figure 4.8</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_04_08.png" alt=""/></figure>
    <p class="packt_figref">Figure 4.8: Running Nikto against the target on port 80</p>
    <h2 id="_idParaDest-125" class="heading-2">Customizing Nikto </h2>
    <p class="normal">The latest <a id="_idIndexMarker466"/>version of Nikto is 2.1.6. The community allowed developers to debug and call specific plugins. These plugins can be customized accordingly from the previous version. You can acquire a listing of all the plugins, and then you specify a specific plugin to perform the scan. There are currently around 35 plugins that can be utilized by penetration testers; <em class="italic">Figure 4.9</em> provides the list of plugins that are currently available in the latest version of Nikto:</p>
    <figure class="mediaobject"><img src="../Images/B17765_04_09.png" alt=""/></figure>
    <p class="packt_figref">Figure 4.9: Listing all the plugins in Nikto</p>
    <p class="normal">For example, if attackers <a id="_idIndexMarker467"/>find banner information denoting Apache server 2.4.0, Nikto can be customized to run specific plugins for Apache user enumeration by running the following command:</p>
    <pre class="programlisting con"><code class="hljs-con">sudo nikto -h target.com -Plugins "apacheusers(enumerate,dictionary:users.txt);report_xml" -output apacheusers.xml
</code></pre>
    <p class="normal">Penetration testers should be able to see the following information:</p>
    <figure class="mediaobject"><img src="../Images/B17765_04_10.png" alt=""/></figure>
    <p class="packt_figref">Figure 4.10: Running Nikto with a specific plugin</p>
    <p class="normal">When the Nikto plugin is run successfully, the <code class="inlineCode">apacheusers.xml</code> output file should include the <a id="_idIndexMarker468"/>active users on the target host.</p>
    <p class="normal">Attackers can also point Nikto scans to Burp or any proxy tool with <code class="inlineCode">nikto.pl -host &lt;hostaddress&gt; -port &lt;hostport&gt; -useragentnikto -useproxy http://127.0.0.1:8080</code>.</p>
    <p class="normal">The next step is to use more advanced scanners that scan a larger number of vulnerabilities; in turn, they can take significantly longer to run to completion. It is not uncommon for complex vulnerability scans (as determined by the number of pages to be scanned as well as the site’s complexity, which can include multiple pages that permit user input, such as search functions or forms that gather data from the user for a backend database) to take several days to be completed.</p>
    <h2 id="_idParaDest-126" class="heading-2">OWASP ZAP</h2>
    <p class="normal">One of the <a id="_idIndexMarker469"/>most effective scanners <a id="_idIndexMarker470"/>based on the number of verified vulnerabilities discovered is OWASP ZAP. This tool is not preinstalled in Kali Linux 2021. This tool is based on the fork from the Paros proxy tool. The latest version is 2.11.1 and was released on 11 December 2021. It can be installed by running <code class="inlineCode">sudo apt install zaproxy</code> from a terminal and opened by running <code class="inlineCode">zaproxy</code>, which should lead us to <em class="italic">Figure 4.11</em>:</p>
    <p class="packt_figref"><img src="../Images/B17765_04_11.png" alt="Graphical user interface, application  Description automatically generated"/></p>
    <figure class="mediaobject">Figure 4.11: Loading the OWASP ZAP 2.11.1</figure>
    <p class="normal">Once the application is launched, it should ask if you want the session to be persistent or temporary. Make the most appropriate choice for your situation. One of the features of this scanner is that it can be used as a standalone automatic scanner and as a proxy tool to test only the relevant sections of the web application under test. Update all the plugins before we kick off the scanning activity to maximize the output. If you choose to use the automated scanner, the tool should present you with the following screen to enter the target URL and the option to use the traditional spider and/or the AJAX Spider. If the AJAX Spider is chosen, then the application is going to use the browser to crawl through every <a id="_idIndexMarker471"/>link on the website and capture them for the next phase: performing an active scan. Use the manual/proxy approach to keep the network traffic/web requests <a id="_idIndexMarker472"/>low and focus the testing without creating huge noise at the target web server logs, which can trigger alarms or cause denial of service. Unlike any other scanners, this tool may produce false positives:</p>
    <figure class="mediaobject"><img src="../Images/B17765_04_12.png" alt="Graphical user interface, text, application, email  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 4.12: Initiating an OWASP ZAP automated scan</p>
    <p class="normal">To test for specific vulnerabilities, you can choose which modules to enable by navigating to <strong class="screenText">Analyse and Scan Policy Manager</strong> from the main menu. This should bring you to the <strong class="screenText">Scan Policy Manager</strong> window. Select <strong class="screenText">Default Policy</strong> and click on <strong class="screenText">Modify</strong>, which should bring you to <em class="italic">Figure 4.13</em>. You should now be able to modify the relevant attacks:</p>
    <figure class="mediaobject"><img src="../Images/B17765_04_13.png" alt=""/></figure>
    <p class="packt_figref">Figure 4.13: Customizing the scan policy for the automated scan</p>
    <p class="normal">ZAP scans <a id="_idIndexMarker473"/>a target and classifies <a id="_idIndexMarker474"/>the vulnerabilities as high, medium, low, and informational in the form of alerts. You can click on the identified results to drill down to specific findings. OWASP ZAP can help you find vulnerabilities such as reflected cross-site scripting, stored cross-site scripting, SQL injection, and remote OS command injection. Once the scan is complete, you should be able to see the following screen with the folder structure of the target, alerts, and other activities (active scan/spider/AJAX Spider) that are performed by the scanner:</p>
    <figure class="mediaobject"><img src="../Images/B17765_04_14.png" alt=""/></figure>
    <p class="packt_figref">Figure 4.14: Listing all the vulnerabilities identified by OWASP ZAP in the Alerts section</p>
    <p class="normal">Also, OWASP ZAP provides special features in the <strong class="screenText">Proxy</strong> section, which allow penetration <a id="_idIndexMarker475"/>testers to query the request <a id="_idIndexMarker476"/>and observe the response to perform the validation, which we call manual PoC.</p>
    <p class="normal">Tools such as OWASP DirBuster can <a id="_idIndexMarker477"/>also be utilized by the attackers to define their own user agent or mimic any well-known user agent headers, such as an IRC bot or Googlebot, and also configure the maximum number of total descendants and sub-processes, and the number of paths that can be traversed. For example, if the spider reveals <code class="inlineCode">www.target.com/admin/</code>, there is a dictionary to add to the URL as <code class="inlineCode">www.target.com/admin/secret/</code>, and the maximum by default is set to <code class="inlineCode">16</code>, which means the tool will scan up to 16 folder possibilities. But attackers would be able to drill down by utilizing other tools to maximize the effectiveness of the tool and would select precisely the right number of paths. Also, if any protection mechanisms were in place, such as WAF or network-level IPS, penetration testers can select to scan the target with a small number of connections per second to send to the target.</p>
    <p class="normal">Other tools <a id="_idIndexMarker478"/>include Burp Suite Community Edition, which is <a id="_idIndexMarker479"/>preinstalled in Kali Linux and is considered one of the best proxy tools. It has <a id="_idIndexMarker480"/>a variety of options that can be utilized by testers. However, the free version of the tool lacks the ability to scan and save the output. The commercial version of the tool allows testers to add additional plugins and perform passive scans while exploring web applications.</p>
    <h1 id="_idParaDest-127" class="heading-1">Vulnerability scanners for mobile applications</h1>
    <p class="normal">Penetration testers often ignore mobile applications in app stores (Apple, Google, and others); however, these applications also serve as a network entry point. In this section, we will <a id="_idIndexMarker481"/>run through how quickly one can set <a id="_idIndexMarker482"/>up a mobile application scanner and how one can combine the results from this mobile application scanner and utilize the information to identify more vulnerabilities and achieve the goal of the penetration test.</p>
    <p class="normal"><strong class="keyWord">Mobile Security Framework</strong> (<strong class="keyWord">MobSF</strong>) is an <a id="_idIndexMarker483"/>open-source, automated penetration testing framework for all the mobile platforms, including Android, iOS, and Windows. The entire framework is written in the Django Python framework.</p>
    <p class="normal">This framework <a id="_idIndexMarker484"/>can be directly downloaded from <a href="https://github.com/MobSF/Mobile-Security-Framework-MobSF"><span class="url">https://github.com/MobSF/Mobile-Security-Framework-MobSF</span></a>, or it can be cloned in Kali Linux by issuing the <code class="inlineCode">git clone https://github.com/MobSF/Mobile-Security-Framework-MobSF</code> command.</p>
    <p class="normal">Once the framework is cloned, use the following steps to bring up the mobile application scanner:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1"><code class="inlineCode">cd</code> into the <code class="inlineCode">Mobile-Security-Framework-MobSF</code> folder:
        <pre class="programlisting con"><code class="hljs-con">cd Mobile-Security-Framework-MobSF/
</code></pre>
      </li>
      <li class="numberedList">Install the dependencies using the following command:
        <pre class="programlisting con"><code class="hljs-con">sudo apt install python3-venv
sudo python3 -m pip install -r requirements.txt
sudo ./setup.sh
sudo ./run.sh
</code></pre>
        <div class="note">
          <p class="normal">Testers might get a <code class="inlineCode">python3:No module named pip</code> error message if they are running this for the first time. To fix the error, simply run <code class="inlineCode">sudo apt install python3-pip</code> from your terminal and continue with the steps.</p>
        </div>
      </li>
      <li class="numberedList">Once all <a id="_idIndexMarker485"/>the installation is complete, check <a id="_idIndexMarker486"/>the configuration settings by entering <code class="inlineCode">sudo ./setup.sh</code> or <code class="inlineCode">sudo python3 setup.py install</code>. That should set up all the prerequisites and also do all the migration seeding to the database.</li>
      <li class="numberedList">Run the vulnerability scanner using <code class="inlineCode">sudo ./run.sh yourIPaddress:portnumber</code>, as shown in <em class="italic">Figure 4.15</em>:<figure class="mediaobject"><img src="../Images/B17765_04_15.png" alt=""/></figure>
        <p class="packt_figref">Figure 4.15: Running the MobSF framework on port 8080 </p>
      </li>
      <li class="numberedList">Access the URL <code class="inlineCode">http://yourIPaddress:Portnumber</code> in the browser and upload any mobile applications found during the reconnaissance to the scanner to identify the entry points.</li>
      <li class="numberedList">Once the files are uploaded, penetration testers can identify the disassembled file in the scanner, along with all the other important information:<figure class="mediaobject"><img src="../Images/B17765_04_16.png" alt=""/></figure>
        <p class="packt_figref">Figure 4.16: Successful installation and execution of the MobSF scanner on a sample APK file</p>
      </li>
    </ol>
    <p class="normal">The scan <a id="_idIndexMarker487"/>output will provide all the mobile <a id="_idIndexMarker488"/>application configuration information, such as activities, services, receivers, and providers. Sometimes, this configuration information provides hardcoded credentials or cloud API keys that can be utilized on other identified services and vulnerabilities. During a penetration testing exercise, we found a developer account username and Base64 password in one of the Java files that was commented on the target’s mobile application, and that allowed access to the external VPN of the organization.</p>
    <p class="normal">The more important portions of the mobile security framework are in the URLs, malware, and strings.</p>
    <h1 id="_idParaDest-128" class="heading-1">The OpenVAS network vulnerability scanner</h1>
    <p class="normal"><strong class="keyWord">Open Vulnerability Assessment System</strong> (<strong class="keyWord">OpenVAS</strong>) is <a id="_idIndexMarker489"/>an open-source <a id="_idIndexMarker490"/>vulnerability assessment scanner and also a vulnerability management tool often utilized by attackers to scan a wide range of networks, which includes 80,000+ vulnerabilities in its database. However, this is considered a slow network vulnerability scanner compared with other commercial tools, such as Nessus, Nexpose, and Qualys.</p>
    <p class="normal">This tool is not preinstalled within Kali Linux 2021.4, hence it needs to be installed manually. Ensure your Kali is up to date and install the latest version of OpenVAS by running the <code class="inlineCode">sudo apt install gvm </code>command. Once this is done, run the <code class="inlineCode">sudo gvm-setup</code> command to set up OpenVAS. This setup will run all the relevant vulnerability databases (SCAP/NVT/CERT) and, once the script has successfully executed, it should create <a id="_idIndexMarker491"/>an admin user and generate a random password, as shown in <em class="italic">Figure 4.17</em>: </p>
    <figure class="mediaobject"><img src="../Images/B17765_04_17.png" alt=""/></figure>
    <p class="packt_figref">Figure 4.17: Confirmation of admin user creation and the temporary password during the installation</p>
    <p class="normal">Finally, to make sure the installation is OK, run the <code class="inlineCode">sudo gvm-check-setup</code> command and it will list the top 10 items that are required to run OpenVAS effectively. Once the installation is successful, testers should be able to see the following:</p>
    <figure class="mediaobject"><img src="../Images/B17765_04_18.png" alt=""/></figure>
    <p class="packt_figref">Figure 4.18: Successful installation of the OpenVAS vulnerability scanner</p>
    <p class="normal">The next task is to start up the OpenVAS scanner by running the <code class="inlineCode">sudo gvm-start</code> command <a id="_idIndexMarker492"/>from the prompt. Depending on bandwidth and computer resources, this could take a while. Once the installation and update are complete, penetration testers should be able to access the OpenVAS server on port <code class="inlineCode">9392</code> with SSL (<a href="https://localhost:9392"><span class="url">https://localhost:9392</span></a>) by entering the username and password. </p>
    <p class="normal">One of the important things to check is that you have the latest feeds of the vulnerabilities by navigating to <code class="inlineCode">Administration-&gt;Feedstatus</code> from the main menu, and you should see what’s shown in <em class="italic">Figure 4.19</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_04_19.png" alt=""/></figure>
    <p class="packt_figref">Figure 4.19: Checking the feed status of OpenVAS to update the current feeds</p>
    <p class="normal">Attackers <a id="_idIndexMarker493"/>are now set to utilize OpenVAS by entering the target information by navigating to <strong class="screenText">Configuration</strong>, clicking on <strong class="screenText">Targets</strong>, and then clicking on <strong class="screenText">New Target</strong>. Once the details of the new target are entered, attackers can navigate to <strong class="screenText">Scans</strong>, click on <strong class="screenText">Tasks</strong>, click on <strong class="screenText">New task</strong>, enter the details, see the scan targets as entered previously, set the scanner and scan configuration, and save. Finally, you are all ready to fire the scan by clicking on the name of the task and then clicking <strong class="screenText">Start Scan</strong> from the scanner portal.</p>
    <h2 id="_idParaDest-129" class="heading-2">Customizing OpenVAS</h2>
    <p class="normal">Unlike <a id="_idIndexMarker494"/>other scanners, OpenVAS is also customizable for scan configuration: it allows testers to add credentials, disable particular plugins, set the maximum and minimum number of connections that can be made, and so on. To stop this service, testers can run <code class="inlineCode">sudo gvm-stop</code>.</p>
    <h1 id="_idParaDest-130" class="heading-1">Commercial vulnerability scanners</h1>
    <p class="normal">Most threat actors utilize open-source tools to launch attacks; however, commercial vulnerability scanners <a id="_idIndexMarker495"/>come with their own advantages and disadvantages in the penetration testing process. In this section, we will learn how to install Nessus and Nexpose in Kali Linux, and since these scanners are backed up by respectable companies, they have comprehensive documentation, so we will not be taking a deep dive into configuring these tools.</p>
    <h2 id="_idParaDest-131" class="heading-2">Nessus</h2>
    <p class="normal">Nessus is one <a id="_idIndexMarker496"/>of the old vulnerability scanners that was started by Renaud Deraison in 1998. It was an open-source project till 2005 when the project was taken over by Tenable Network Security (co-founded by Renaud). Nessus is one of the most commonly used commercial vulnerability scanners in the security community for network infrastructure scanning. Note that Tenable has multiple security products. In this section, we will explore the installation of Nessus Essential.</p>
    <p class="normal">The following <a id="_idIndexMarker497"/>provides step-by-step instructions on how <a id="_idIndexMarker498"/>to install Nessus on Kali Linux:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Register as a normal user by visiting <a href="https://www.tenable.com/try"><span class="url">https://www.tenable.com/try</span></a> and selecting <strong class="screenText">TRY NESSUS PRO FOR FREE</strong>.</li>
      <li class="numberedList">Download <a id="_idIndexMarker499"/>the right version of Nessus from <a href="https://www.tenable.com/downloads/"><span class="url">https://www.tenable.com/downloads/</span></a>.</li>
      <li class="numberedList">Once Nessus is downloaded, run the installer, as shown in the following command:
        <pre class="programlisting con"><code class="hljs-con">sudo dpkg -i Nessus-8.14.0-debian6_amd64.deb
</code></pre>
      </li>
      <li class="numberedList">The next step is to start the <code class="inlineCode">nessus</code> service by running <code class="inlineCode">sudo systemctl start nessusd.service</code>, which should bring Nessus up on our system.</li>
      <li class="numberedList">By default, the Nessus scanner runs on port <code class="inlineCode">8834</code> over SSL. Following a successful installation, attackers should be able to see the following:<figure class="mediaobject"><img src="../Images/B17765_04_20.png" alt=""/></figure>
        <p class="packt_figref">Figure 4.20: Successful installation of Nessus on our Kali Linux</p>
      </li>
      <li class="numberedList">Add a <a id="_idIndexMarker500"/>new user and activate the license; your <a id="_idIndexMarker501"/>scanner will download all the relevant plugins, based on your license.</li>
      <li class="numberedList">Finally, you should be able to see Nessus up and running, as shown in <em class="italic">Figure 4.21</em>, where it is ready to launch a scan against the target system/network:<figure class="mediaobject"><img src="../Images/B17765_04_21.png" alt=""/></figure>
        <p class="packt_figref">Figure 4.21: Selecting the policy to launch the Nessus scans</p>
      </li>
    </ol>
    <p class="normal">Attackers <a id="_idIndexMarker502"/>can leverage all of Nessus’ capabilities to quickly identify <a id="_idIndexMarker503"/>the vulnerabilities that can be utilized to select the right target for exploitation. We will explore other commercial and specialized scanners in a later section.</p>
    <h2 id="_idParaDest-132" class="heading-2">Qualys</h2>
    <p class="normal">Qualys is another <a id="_idIndexMarker504"/>player in the vulnerability management commercial market. They also provide a community edition of the online scanner that can certainly be handy during a penetration test/RTE. </p>
    <p class="normal">Penetration testers can get the free community edition by accessing <a href="https://www.qualys.com/community-edition/"><span class="url">https://www.qualys.com/community-edition/</span></a> once the registration is complete. The testers should have their own custom portal with login credentials, and the free edition should allow us to scan up to 16 IP addresses. A sample external completed scan in Qualys will be as shown in <em class="italic">Figure 4.22</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_04_22.png" alt=""/></figure>
    <p class="packt_figref">Figure 4.22: Successfully launching the scan using Qualys community edition</p>
    <p class="normal">You should <a id="_idIndexMarker505"/>note that the scans will originate from the Qualys-hosted public IP address, and it is recommended you customize the scan policy, such as disabling the denial-of-service type checks, before initiating the Qualys scan.</p>
    <h1 id="_idParaDest-133" class="heading-1">Specialized scanners</h1>
    <p class="normal">The exploitation phase of the kill chain is the most dangerous one for the penetration tester or attacker; they are directly interacting with the target network or system, and there is a high <a id="_idIndexMarker506"/>chance that their activity will be logged or their identity discovered. Again, stealth must be employed to minimize the risks to the tester. Although no specific methodology or tool is undetectable, there are some configuration changes and specific tools that will make detection more difficult.</p>
    <p class="normal">In the <a id="_idIndexMarker507"/>previous editions, we discussed the <strong class="keyWord">Web Application Attack and Audit Framework</strong> (<strong class="keyWord">w3af</strong>) scanner, a Python-based open-source web application security scanner, which is no longer available in the Kali Linux distribution due to a lack of updates to the product.</p>
    <p class="normal">Kali also includes some application-specific vulnerability scanners such as WPScan and VoIP Hopper. Let us explore WPScan, commonly known as the WordPress security scanner, which can be utilized by attackers to automatically detect 22,800+ WordPress vulnerabilities. </p>
    <p class="normal">This application is written in Ruby and it is preinstalled on Kali. The scan can be <a id="_idIndexMarker508"/>simply initiated by running <code class="inlineCode">wpscan --url target.com</code> as shown in <em class="italic">Figure 4.23</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_04_23.png" alt="A screenshot of a computer  Description automatically generated with medium confidence"/></figure>
    <p class="packt_figref">Figure 4.23: Scanning a web application using WPScan</p>
    <h1 id="_idParaDest-134" class="heading-1">Threat modeling</h1>
    <p class="normal">The passive and active reconnaissance phases map the target network and system and identify vulnerabilities that may be exploitable to achieve the attacker’s objective. During this stage <a id="_idIndexMarker509"/>of the attacker’s kill chain, there is a strong desire for action; testers want to immediately launch exploits and demonstrate that they can compromise the target. However, an unplanned attack may not be the most effective means of achieving the objective, and it may sacrifice the stealth that is needed to achieve it.</p>
    <p class="normal">Penetration testers have adopted (formally or informally) a process known as threat modeling, which was originally developed by network planners to develop defensive countermeasures against an attack.</p>
    <p class="normal">Penetration testers and attackers have turned this defensive threat modeling methodology on its head to improve the success of an attack. Offensive threat modeling is a formal approach that combines the results of reconnaissance and research to develop an attack strategy. An attacker has to consider the available targets and identify the types of targets, listed as follows:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Primary targets</strong>: These <a id="_idIndexMarker510"/>are the primary <a id="_idIndexMarker511"/>entry point targets to any organization, and when compromised, they serve the objective of a penetration test</li>
      <li class="bulletList"><strong class="keyWord">Secondary targets</strong>: These <a id="_idIndexMarker512"/>targets may provide information (security <a id="_idIndexMarker513"/>controls, password and logging policies, and local and domain administrator names and passwords) to support an attack or allow access to a primary target</li>
      <li class="bulletList"><strong class="keyWord">Tertiary targets</strong>: These <a id="_idIndexMarker514"/>targets may be unrelated <a id="_idIndexMarker515"/>to the testing or attack objective, but are relatively easy to compromise and may provide information or a distraction from the actual attack</li>
    </ul>
    <p class="normal">For each target type, you have to determine the approach to use. A single vulnerability can be attacked using stealth techniques, or multiple targets can be attacked using a volume of attacks to rapidly exploit a target. If a large-scale attack is implemented, the noise in the defender’s control devices will frequently cause them to minimize logging on the router and firewall or even fully disable it.</p>
    <p class="normal">The approach to be used will guide the selection of the exploit. Generally, attackers follow an attack tree methodology when creating a threat model, shown in <em class="italic">Figure 4.24</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_04_24.png" alt=""/></figure>
    <p class="packt_figref">Figure 4.24: A sample attack tree for an objective</p>
    <p class="normal">The attack tree approach allows <a id="_idIndexMarker516"/>the tester to easily visualize the attack options that are available and the alternative options that can be employed if a selected attack is not successful. Once an attack tree has been generated, the next step of the exploit phase is to identify the exploits that may be used to compromise vulnerabilities in the target. In the preceding attack tree, we visualize the objective of obtaining engineering documents, which are crucial for organizations that provide engineering services.</p>
    <p class="normal">Penetration testers <a id="_idIndexMarker517"/>can also utilize pytm, a Python-based tool that can be very handy during the exploitation of web applications, helping you understand how to infiltrate a specific organization from their exposed servers. This tool comes with 100 predefined web-based threats <a id="_idIndexMarker518"/>that also provide the capability to create a <strong class="keyWord">Data Flow Diagram </strong>(<strong class="keyWord">DFD</strong>) within a few minutes, which can be utilized as typical entry points. This can be directly downloaded from GitHub or by running <code class="inlineCode">git clone https://github.com/izar/pytm</code>. Once downloaded, install all the dependencies to run the program:</p>
    <pre class="programlisting con"><code class="hljs-con">git clone https://github.com/izar/pytm
cd pytm
sudo pip3 install –r requirements.txt
sudo python3 setup.py install
sudo python3 tm.py -–list 
sudo python3 tm.py --dfd | dot -Tpng -o sample.png 
</code></pre>
    <p class="normal">Penetration <a id="_idIndexMarker519"/>testers should see the <a id="_idIndexMarker520"/>DFD generated for the web server on the cloud by pytm as shown in <em class="italic">Figure 4.25</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_04_25.png" alt=""/></figure>
    <p class="packt_figref">Figure 4.25: Sample DFD generated by pytm</p>
    <p class="normal">This DFD can be utilized by the attackers to identify the right entry points of the application, identify the vulnerabilities, and take advantage of them.</p>
    <h1 id="_idParaDest-135" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, we focused on multiple vulnerability assessment tools and techniques. We learned how to write our own vulnerability script for Nmap using NSE, and how to use a tool that can convert the findings from active reconnaissance into a defined action that establishes access for the tester to the target. We also learned how to install the OpenVAS, Nessus, and Nexpose vulnerability scanners on Kali Linux and utilize the community edition of Qualys in the cloud.</p>
    <p class="normal">Kali provides several tools to facilitate the development, selection, and activation of exploits, including the internal exploit-db (<code class="inlineCode">searchsploit</code>), as well as several frameworks that simplify the use and management of exploits. We also explored the application-specific WordPress security scanner (WPScan) and discussed the basic principles of threat modeling. Additionally, we learned how to create a threat DFD using pytm, which helps penetration testers identify most entry points and infiltrate a web application. </p>
    <p class="normal">The next chapter focuses on the most important part of the attacker’s kill chain, the exploitation phase. Physical security is one method to gain access to data systems (if you can boot, you’ve got root!). Physical access is also closely tied to social engineering, the art of hacking humans and taking advantage of their trust. This is the part of the attack where the attackers achieve their objective. Typical exploitation activities include horizontal escalation by taking advantage of poor access controls, and vertical escalation by theft of user credentials.</p>
  </div>
</body></html>