<html><head></head><body>
        <section id="3279U1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Discovery</h1>
            

            <article>
                
<p class="calibre5">This chapter will include the following recipes:</p>
<ul class="calibre18">
<li class="calibre19">Using Scapy to perform host discovery (layers 2/3/4)</li>
<li class="calibre19">Using Nmap to perform host discovery (layers 2/3/4)</li>
<li class="calibre19">Using ARPing to perform host discovery (layer 2)</li>
<li class="calibre19">Using netdiscover to perform host discovery <span>(layer 2)</span></li>
<li class="calibre19">Using Metasploit to perform host discovery <span>(layer 2)</span></li>
<li class="calibre19">Using ICMP to perform host discovery</li>
<li class="calibre19">Using fping to perform host discovery</li>
<li class="calibre19">Using hping3 to perform host discovery (layers 3/4)</li>
</ul>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="335QG1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Introduction</h1>
            

            <article>
                
<p class="calibre5"><strong class="calibre1">Discovery scanning</strong> is the process of identifying live hosts on a network. In the context of<br class="title-page-name"/>
penetration testing, this is usually performed to identify potential targets for attack. The<br class="title-page-name"/>
objective here is not to exhaust resources in gathering information about targets, but instead, to merely find out where the targets are logically located. The final product of our discovery should be a list of IP addresses that we can then use for further analysis. In this chapter, we will discuss how to discover hosts on a network by using protocols operating at layer 2, layer 3, and layer 4 of the OSI model.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section>

            <header id="344B22-cf89710d791c4a3bb78ec273d9322426">
                </header><h1 class="header-title" id="calibre_pb_0">Knowing the OSI model</h1>
            

            <article>
                
<p class="calibre5">Prior to addressing each of the scanning techniques specifically, we should address a few underlying principles. The <strong class="calibre1">Open Systems Interconnection</strong> (<strong class="calibre1">OSI</strong>) model is an <strong class="calibre1">International Organization for Standardization</strong> (<strong class="calibre1">ISO</strong>) standard that defines how networked systems communicate. This model is divided into seven layers that define how application content can be sent by one system and/or received by another. The upper layers (5-7) of the OSI model primarily function to interact with the user, whereas the lower layers (1-4) deal with encoding, formatting, and transmission. These layers consist of the following:</p>
<table class="calibre29">
<tbody class="calibre12">
<tr class="calibre13">
<td class="calibre14"><strong class="calibre1">OSI model</strong></td>
<td class="calibre14"><strong class="calibre1">Layer description</strong></td>
<td class="calibre14"><strong class="calibre1">Protocols</strong></td>
</tr>
<tr class="calibre13">
<td class="calibre14">Layer 7: Application</td>
<td class="calibre14">
<p class="calibre5">This layer involves the application software that is sending and receiving data</p>
</td>
<td class="calibre14">HTTP, FTP,<br class="title-page-name"/>
and Telnet</td>
</tr>
<tr class="calibre13">
<td class="calibre14">Layer 6: Presentation</td>
<td class="calibre14">This layer defines how data is formatted or organized</td>
<td class="calibre14">ASCII, JPEG, PDF, PNG, and DOCX</td>
</tr>
<tr class="calibre13">
<td class="calibre14">Layer 5: Session</td>
<td class="calibre14">This layer involves application session control, management, synchronization, and termination</td>
<td class="calibre14">NetBIOS, PPTP, RPC, and SOCKS</td>
</tr>
<tr class="calibre13">
<td class="calibre14">Layer 4: Transport</td>
<td class="calibre14">This layer involves end-to-end communication services</td>
<td class="calibre14">TCP and UDP</td>
</tr>
<tr class="calibre13">
<td class="calibre14">Layer 3: Network</td>
<td class="calibre14">This layer involves logical system addressing</td>
<td class="calibre14">IPv4, IPv6, ICMP, and IPSec</td>
</tr>
<tr class="calibre13">
<td class="calibre14">Layer 2: Data link</td>
<td class="calibre14">This layer involves physical system addressing</td>
<td class="calibre14">ARP</td>
</tr>
<tr class="calibre13">
<td class="calibre14">Layer 1: Physical</td>
<td class="calibre14">This layer involves the data stream that is passed over the wire</td>
<td class="calibre14"/>
</tr>
</tbody>
</table>
<p class="calibre5">The lower layers of the OSI model are largely used to ensure that network traffic successfully arrives at its intended destination. Many of the commonly used protocols at these lower layers necessitate a response from the destination system and, as such, can be leveraged by potential attackers to identify live systems. Techniques discussed in the remainder of this section will leverage protocols used in layers 2, 3, and 4 to discover live network systems. Prior to addressing each of the specific recipes, we will briefly discuss the protocols used and how they can be leveraged for discovery.</p>
<p class="calibre5">The pros and cons of layer 2 discovery with ARP are as follows:</p>
<ul class="calibre18">
<li class="calibre19"><strong class="calibre1">Pros</strong>:
<ul class="calibre30">
<li class="calibre19">Very fast</li>
<li class="calibre19">Highly reliable</li>
</ul>
</li>
<li class="calibre19"><strong class="calibre1">Cons</strong>:
<ul class="calibre30">
<li class="calibre19">Cannot discover remote systems (non-routable protocol)</li>
</ul>
</li>
</ul>
<p class="calibre5">Layer 2 discovery scanning is performed using <strong class="calibre1">Address Resolution Protocol</strong> (<strong class="calibre1">ARP</strong>) traffic. ARP is a layer 2 protocol that primarily serves the function of translating logical layer 3 IP addresses to physical layer 2 MAC addresses. When a system needs to locate the physical address that corresponds to a destination IP address, it will broadcast an ARP request packet on the local network segment. This ARP request simply asks the entire network, "Who has this IP address?" The system with the specified IP address will then directly respond to the inquiring system with an ARP reply that contains its layer 2 MAC address. The inquiring system will update its ARP cache, which is a temporary record of IP address and MAC address associations, and will then initiate its communications with the host. ARP can be useful in discovering live hosts on a network, because it does not employ any form of identification or authorization prior to responding to requests.</p>
<p class="calibre5">As a result of this, it is possible and even trivial for an intruder to connect to a local network and enumerate live hosts. This can be performed by sending a series of ARP requests for a comprehensive list of IP addresses and then recording a list of queried IP addresses for which responses were received. ARP discovery has both advantages and disadvantages. It is useful in discovery scanning because it is the fastest and most reliable discovery protocol. Unfortunately, it is also a non-routable protocol and can only be used to discover hosts on the local subnet.</p>
<p class="calibre5">The pros and cons of layer 3 discovery with ICMP are as follows:</p>
<ul class="calibre18">
<li class="calibre19"><strong class="calibre1">Pros</strong>:
<ul class="calibre30">
<li class="calibre19">Can discover remote systems (routable protocol)</li>
<li class="calibre19">Still relatively fast</li>
</ul>
</li>
<li class="calibre19"><strong class="calibre1">Cons</strong>:
<ul class="calibre30">
<li class="calibre19">Slower than ARP discovery</li>
<li class="calibre19">Often filtered by firewalls</li>
</ul>
</li>
</ul>
<p class="calibre5">Layer 3 discovery is probably the most commonly known and used discovery technique among network administrators and technicians. The famous ping command-line utility, which is found natively on both Windows and *nix systems, uses layer 3 discovery. This form of discovery makes use of Internet Control Message Protocol (ICMP). While ICMP has several functions, one that can be particularly useful to identify live systems is the use of echo request and echo response messages. An ICMP echo request is the technical equivalent of one system asking another system, "Are you there?" An ICMP echo response is how the receiving system can answer, "Yes I am." To determine whether a host exists at a particular IP address, a system can send an ICMP echo request to that address. If there is a host with that IP address and everything works as desired, the host will then return an ICMP echo reply. This protocol can be leveraged in the host discovery by performing this sequence in a loop for a comprehensive list of IP addresses.</p>
<p class="calibre5">The output would consist of a list of only the IP addresses for which a reply was received. Layer 3 discovery is effective because it uses a routable protocol to identify live hosts. However, there are also certain disadvantages associated with its use. ICMP discovery is not as fast as ARP discovery. Also, ICMP discovery is not as reliable as ARP discovery, as some hosts are intentionally configured to not respond to ICMP traffic, and firewalls are frequently configured to drop ICMP traffic. Nonetheless, it is a fast and commonly used approach to discovering potential targets on a remote address range.</p>
<p class="calibre5">Layer 4 discovery is highly effective because publicly routable systems are usually only in the public IP space, as they host networked services that are available over <strong class="calibre1">Transmission Control Protocol</strong> (<strong class="calibre1">TCP</strong>) or <strong class="calibre1">User Datagram Protocol</strong> (<strong class="calibre1">UDP</strong>). In poorly secured environments, a reply can often be solicited from a remote server by sending nearly any UDP or TCP request to its IP address. However, if stateful filtering is employed, it may be possible to only solicit a response from a remote service with a SYN request directed to a port address associated with a live service. Even in highly secure environments with advanced filtering, discovery is possible in most cases if the right request is supplied. However, with 65,536 possible port addresses for both UDP and TCP services, a fully comprehensive discovery process can be very time consuming. The best approach to layer 4 discovery with both TCP and UDP techniques is to find the right balance between thoroughness and expediency.</p>
<p class="calibre5">The pros and cons of layer 4 discovery with TCP are as follows:</p>
<ul class="calibre18">
<li class="calibre19"><strong class="calibre1">Pros</strong>:
<ul class="calibre30">
<li class="calibre19">Can discover remote systems (routable protocol)</li>
<li class="calibre19">More reliable than ICMP (filters are less common or selectively implemented)</li>
</ul>
</li>
<li class="calibre19"><strong class="calibre1">Cons</strong>:
<ul class="calibre30">
<li class="calibre19">Stateful firewall filters can produce unreliable results</li>
<li class="calibre19">Thorough discovery can be time consuming</li>
</ul>
</li>
</ul>
<p class="calibre5">Layer 4 discovery with TCP consists of sending TCP packets to potential destination addresses with various TCP flag bits activated. Different flag configurations can trigger various responses that can be used to identify live hosts. Unsolicited TCP finish (<strong class="calibre1">FIN</strong>) or <strong class="calibre1">acknowledge</strong> (<strong class="calibre1">ACK</strong>) packets can often trigger <strong class="calibre1">reset</strong> (<strong class="calibre1">RST</strong>) responses from a remote server. The <strong class="calibre1">synchronize</strong> (<strong class="calibre1">SYN</strong>) packets sent to a remote server can commonly trigger SYN+ACK or RST responses, depending on the status of the service. The intention is not to solicit a particular response, but instead to solicit any response. Any response from a given IP address is a confirmation that a live system is present.</p>
<p class="calibre5">The pros and cons of layer 4 discovery with UDP are as follows:</p>
<ul class="calibre18">
<li class="calibre19"><strong class="calibre1">Pros</strong>:
<ul class="calibre30">
<li class="calibre19">Can discover remote systems (routable protocol)</li>
<li class="calibre19">Can even discover remote hosts with all TCP services filtered</li>
</ul>
</li>
<li class="calibre19"><strong class="calibre1">Cons</strong>:
<ul class="calibre30">
<li class="calibre19">Inconsistent use and filtering of ICMP port-unreachable responses makes indiscriminate discovery unreliable</li>
<li class="calibre19">Service-specific probe techniques limit thoroughness and increase the required scan time</li>
</ul>
</li>
</ul>
<p class="calibre5">UDP discovery involves sending UDP probe packets to various destination ports in an attempt to solicit a response from live hosts. UDP discovery can sometimes be effective in identifying live hosts that have all TCP services filtered. However, UDP discovery can be tricky because while some UDP services will reply to UDP packets with ICMP port-unreachable responses, others will only reply to unique requests that specifically correspond to a running service. Additionally, ICMP traffic is commonly filtered by egress restrictions on firewalls, making it difficult to perform indiscriminate UDP discovery. As such, effective UDP discovery scanning often requires unique techniques that vary from service to service.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="352RK1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Using Scapy to perform host discovery (layers 2/3/4)</h1>
            

            <article>
                
<p class="calibre5">Scapy is a powerful interactive tool that can be used to capture, analyze, manipulate, and even create protocol-compliant network traffic, which can then be injected into the network. Scapy is also a library that can be used in Python, thereby offering the capability to create highly effective scripts to perform network traffic handling and manipulation. We will demonstrate here how to use Scapy to perform discovery in layers 2, 3, and 4:</p>
<ol class="calibre20">
<li value="1" class="calibre19">First, we will use Scapy and Python to perform ARP discovery in layer 2.</li>
<li value="2" class="calibre19">Next, we will use Scapy to inject and analyze ICMP traffic in layer 3.</li>
<li value="3" class="calibre19">Finally, we will use Scapy and Python to perform layer 4 discovery using both UDP and TCP.</li>
</ol>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="361C61-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre5">To use Scapy to perform ARP discovery, you will need to have at least one system on the <strong class="calibre1">local area network</strong> (<strong class="calibre1">LAN</strong>) that will respond to ARP requests. In the examples provided, a combination of Linux and Windows systems are used. For more information on setting up systems in a local lab environment, refer to the <em class="calibre15">Installing Metasploitable2</em> and <em class="calibre15">Installing Windows Server</em> recipes in <a href="part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426" target="_blank" class="calibre6"><span>Chapter 1</span></a>, <em class="calibre15">Getting Started</em>.</p>
<p class="calibre5">Using Scapy to perform layer 3 and layer 4 discovery does not require a lab environment, as many systems on the Internet will reply to ICMP echo requests as well as both TCP and UDP traffic. However, it is highly recommended that you perform any type of network scanning exclusively in your own lab unless you are thoroughly familiar with the legal regulations imposed by any governing authorities to whom you are subject. If you wish to perform this technique within your lab, you will need to have at least one system that will respond to ICMP, TCP, and UDP requests. In the examples provided, a combination of Linux and Windows systems are used. For more information on setting up systems in a local lab environment, refer to the <em class="calibre15">Installing Metasploitable2</em> and <em class="calibre15">Installing Windows Server</em> recipes in <a href="part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426" target="_blank" class="calibre6"><span>Chapter 1</span></a>, <em class="calibre15">Getting Started</em>.</p>
<p class="calibre5">Additionally, this section will require a script to be written to the filesystem, using a text editor such as Vim or <span>GNU n</span>ano. For more information on writing scripts, refer to the <em class="calibre15">Using text editors (Vim and <span>GNU n</span>ano)</em> recipe in <a href="part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426" target="_blank" class="calibre6"><span>Chapter 1</span></a><em class="calibre15">, Getting Started</em>.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="36VSO1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it…</h1>
            

            <article>
                
<p class="calibre5">Let's go through the discovery steps layer by layer. In this layer, we will use Scapy to perform discovery at layers 2, 3, and 4.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section>

            <header id="37UDA2-cf89710d791c4a3bb78ec273d9322426">
                </header><h1 class="header-title" id="calibre_pb_0">Layer 2 discovery - ARP</h1>
            

            <article>
                
<p class="calibre5">To understand how ARP discovery works, we will start by using Scapy to craft custom packets that will allow us to identify hosts on the LAN using ARP:</p>
<ol class="calibre20">
<li value="1" class="calibre19">To begin using Scapy in Kali Linux, enter the <kbd class="calibre16"><span>scapy</span></kbd> command from the Terminal. You can then use the <kbd class="calibre16"><span>display()</span></kbd> function to see the default configurations for any ARP object created in Scapy in the following manner:</li>
</ol>
<div class="p"><img class="alignnone18" src="../images/00576.jpeg"/></div>
<ol start="2" class="calibre20">
<li value="2" class="calibre19">Notice that both the IP and MAC source addresses are automatically configured to the values associated with the host on which Scapy is being run. Except in the case that you are spoofing an alternate source address, these values will never have to be changed for any Scapy object. The default opcode value for ARP is automatically set to <kbd class="calibre16"><span>who-has</span></kbd>, which designates that the packet will be requesting an IP and MAC association. In this case, the only value we need to supply is the destination IP address. To do this, we can create an object using the ARP function by setting it equal to a variable. The name of the variable is irrelevant (in the example provided, the variable name, <kbd class="calibre16"><span>arp_request</span></kbd>, is used).</li>
</ol>
<p class="calibre27">   Have a look at the following commands:</p>
<div class="p"><img class="alignnone19" src="../images/00635.jpeg"/></div>
<ol start="3" class="calibre20">
<li value="3" class="calibre19">Notice that the <kbd class="calibre16"><span>display()</span></kbd> function can also be applied to the created ARP object to verify that the configuration values have been updated. For this exercise, use a destination IP address that corresponds to a live machine in your lab network. The <kbd class="calibre16"><span>sr1()</span></kbd> function can then be used to send the request over the wire and return the first response:</li>
</ol>
<div class="p"><img class="alignnone20" src="../images/00004.jpeg"/></div>
<ol start="4" class="calibre20">
<li value="4" class="calibre19">Alternatively, you can perform the same task by calling the function directly and passing any special configurations as arguments to it, as shown in the following screenshot. This can avoid the clutter of using unnecessary variables and can also allow the completion of the entire task in a single line of code.</li>
</ol>
<div class="p"><img class="alignnone21" src="../images/00132.jpeg"/></div>
<ol start="5" class="calibre20">
<li value="5" class="calibre19">Notice that in each of these cases, a response is returned, indicating that the IP address of <kbd class="calibre16"><span>172.16.69.128</span></kbd> is at the MAC address of <kbd class="calibre16"><span>00:0C:29:96:81:f2</span></kbd>. If you perform the same task, but instead assign a destination IP address that does not correspond to a live host on your lab network, you will not receive any response, and the function will continue to analyze the incoming traffic on the local interface indefinitely.</li>
<li value="6" class="calibre19">You can forcibly terminate the function using <em class="calibre15">Ctrl </em>+ <em class="calibre15">C</em>. Alternatively, you can specify a timeout argument to avoid this problem. Using timeouts will become critical when Scapy is employed in Python scripting. To use a timeout, an additional argument should be supplied to the send/receive function, specifying the number of seconds to wait for an incoming response:</li>
</ol>
<div class="p"><img class="alignnone21" src="../images/00136.jpeg"/></div>
<ol start="7" class="calibre20">
<li value="7" class="calibre19">By employing the timeout function, a request sent to a non-responsive host will return after the specified amount of time, indicating that <kbd class="calibre16">0</kbd> answers were captured. Additionally, the responses received by this function can also be set to a variable, and subsequent handling can be performed on the response by calling this variable:</li>
</ol>
<div class="p"><img class="alignnone22" src="../images/00285.jpeg"/></div>
<ol start="8" class="calibre20">
<li value="8" class="calibre19">Scapy can also be used as a library within the Python scripting language. This can be used to effectively automate redundant tasks performed in Scapy. Python and Scapy can be used to loop through each of the possible host addresses within the local subnet in sequence and send ARP requests to each one. An example of a functional script that could be used to perform layer 2 discovery on a sequential series of hosts might look like the following:</li>
</ol>
<pre class="calibre24">
        #!/usr/bin/python<br class="title-page-name"/><br class="title-page-name"/>        import logging<br class="title-page-name"/>        import subprocess<br class="title-page-name"/>        logging.getLogger("scapy.runtime").setLevel(logging.ERROR)<br class="title-page-name"/>        from scapy.all import *<br class="title-page-name"/><br class="title-page-name"/>        if len(sys.argv) != 2:<br class="title-page-name"/>         print "Usage - ./arp_disc.py [interface]"<br class="title-page-name"/>         print "Example - ./arp_disc.py eth0"<br class="title-page-name"/>         print "Example will perform an ARP scan of the local <br class="title-page-name"/>           subnet to which eth0 is assigned"<br class="title-page-name"/>         sys.exit()<br class="title-page-name"/><br class="title-page-name"/>        interface = str(sys.argv[1])<br class="title-page-name"/>        ip = subprocess.check_output("ifconfig " + interface +<br class="title-page-name"/>         " | grep 'inet ' |  awk '{ print $2 }' <br class="title-page-name"/>         | cut -d ':' -f2", shell=True).strip()<br class="title-page-name"/>        prefix = ip.split('.')[0] + '.' + ip.split('.')[1] +<br class="title-page-name"/>         '.' +ip.split('.')[2] + '.'<br class="title-page-name"/><br class="title-page-name"/>        for addr in range(0,254):<br class="title-page-name"/>         answer=sr1(ARP(pdst=prefix+str(addr)),timeout=1,verbose=0)<br class="title-page-name"/>          if answer == None:<br class="title-page-name"/>            pass<br class="title-page-name"/>          else:<br class="title-page-name"/>            print prefix+str(addr)
</pre>
<div class="calibre31">
<ul class="calibre18">
<li class="calibre19"> The first line of the script indicates where the Python interpreter is located so that the script can be executed without it being passed to the interpreter. The script then imports all the Scapy functions and also defines Scapy logging levels to eliminate unnecessary output in the script.</li>
<li class="calibre19">The subprocess library is also imported to facilitate easy extraction of information from system calls. The second block of code is a conditional test that evaluates whether the required argument is supplied to the script. If the required argument is not supplied upon execution, the script will then output an explanation of the appropriate script usage. This explanation includes the usage of the tool, an example, and explanation of the task that will be performed by this example.</li>
<li class="calibre19">After this block of code, there is a single isolated line of code that assigns the provided argument to the interface variable. The next block of code utilizes the <kbd class="calibre16"><span>check_output()</span></kbd> subprocess function to perform an <kbd class="calibre16"><span>ifconfig</span></kbd> system call that also utilizes <kbd class="calibre16"><span>grep</span></kbd> and <kbd class="calibre16"><span>cut</span></kbd> to extract the IP address from the local interface that was supplied as an argument. This output's then assigned to the <kbd class="calibre16"><span>ip</span></kbd> variable.</li>
<li class="calibre19">The <kbd class="calibre16"><span>split</span></kbd> function is then used to extract the <kbd class="calibre16"><span>/24</span></kbd> network prefix from the IP address string. For example, if the <kbd class="calibre16"><span>ip</span></kbd> variable contains the <kbd class="calibre16"><span>192.168.11.4</span></kbd> string, then the value of <kbd class="calibre16"><span>192.168.11</span></kbd> will be assigned to the <kbd class="calibre16"><span>prefix</span></kbd> variable.</li>
<li class="calibre19">The final block of code is a <kbd class="calibre16"><span>for</span></kbd> loop that performs the actual scanning. The <kbd class="calibre16"><span>for</span></kbd> loop cycles through all values between <kbd class="calibre16"><span>0</span></kbd> and <kbd class="calibre16"><span>254</span></kbd>, and for each iteration, the value is then appended to the network prefix. In the case of the example provided earlier, an ARP request would be broadcast for each IP address between <kbd class="calibre16"><span>192.168.11.0</span></kbd> and <kbd class="calibre16"><span>192.168.11.254</span></kbd>. For each live host that does reply, the corresponding IP address is then printed to the screen to indicate that the host is alive on the LAN.</li>
</ul>
</div>
<ol start="9" class="calibre20">
<li value="9" class="calibre19">Once the script has been written to the local directory, you can execute it in the Terminal using a period and forward slash, followed by the name of the executable script. Have a look at the following command used to execute the script:</li>
</ol>
<div class="p"><img class="image-border47" src="../images/00518.jpeg"/></div>
<ol start="10" class="calibre20">
<li value="10" class="calibre19">If the script is executed without any arguments supplied, the usage is output to the screen. The usage output indicates that this script requires a single argument that defines what interface should be used to perform the scan. In the following example, the script is executed using the <kbd class="calibre16"><span>eth0</span></kbd> interface:</li>
</ol>
<div class="p"><img class="image-border47" src="../images/00520.jpeg"/></div>
<ol start="11" class="calibre20">
<li value="11" class="calibre19">Once run, the script will determine the local subnet of the supplied interface, perform the ARP scan on this subnet, and then output a list of live IP addresses based on the responses from the hosts to which these IPs are assigned. Additionally, Wireshark can be run at the same time as the script is running, to observe how a request is broadcast for each address in sequence and how live hosts respond to these requests, as seen in the following screenshot:</li>
</ol>
<div class="p"><img class="alignnone23" src="../images/00458.jpeg"/></div>
<ol start="12" class="calibre20">
<li value="12" class="calibre19">Additionally, one can easily redirect the output of the script to a text file that can then be used for subsequent analysis. The output can be redirected using the greater-than sign followed by the name of the text file. An example of this is as follows:</li>
</ol>
<div class="p"><img class="image-border47" src="../images/00525.jpeg"/></div>
<ol start="13" class="calibre20">
<li value="13" class="calibre19">Once output has been redirected to the output file (<kbd class="calibre16"><span>output.txt</span></kbd>), you can use the <kbd class="calibre16"><span>ls</span></kbd> command to verify that the file was written to the filesystem, or you can use the <kbd class="calibre16"><span>cat</span></kbd> command to view the contents of the file. This script can also be easily modified to only perform ARP requests against certain IP addresses contained within a text file. To do this, we would first need to create a list of IP addresses that we desire to scan. For this purpose, you can use either the <span>GNU n</span>ano or Vim text editors. To evaluate the functionality of the script, include some addresses that were earlier discovered to be live and some other randomly selected addresses in the same range that do not correspond to any live host. To create the input file in either Vim or <span>GNU n</span>ano, use one of the following commands:</li>
</ol>
<div class="p"><img class="alignnone24" src="../images/00237.jpeg"/></div>
<ol start="14" class="calibre20">
<li value="14" class="calibre19">Once the input file (<kbd class="calibre16"><span>iplist.txt</span></kbd>) has been created, you can verify its contents using the <kbd class="calibre16"><span>cat</span></kbd> command. Assuming that the file was created correctly, you should see the same list of IP addresses that you entered into the text editor:</li>
</ol>
<div class="p"><img class="alignnone25" src="../images/00251.jpeg"/></div>
<ol start="15" class="calibre20">
<li value="15" class="calibre19">To create a script that will accept a text file as input, we can either modify the existing script from the previous exercise or create a new script file. To utilize this list of IP addresses in our script, we will need to perform some file handling in Python. An example of a working script might look like the following:</li>
</ol>
<pre class="calibre24">
        #!/usr/bin/python<br class="title-page-name"/><br class="title-page-name"/>        import logging<br class="title-page-name"/>        logging.getLogger("scapy.runtime").setLevel(logging.ERROR)<br class="title-page-name"/>        from scapy.all import *<br class="title-page-name"/><br class="title-page-name"/>        if len(sys.argv) != 2:<br class="title-page-name"/>         print "Usage - ./arp_disc.py [filename]"<br class="title-page-name"/>         print "Example - ./arp_disc.py iplist.txt"<br class="title-page-name"/>         print "Example will perform an ARP scan of <br class="title-page-name"/>           the IP addresses  listed in iplist.txt"<br class="title-page-name"/>         sys.exit()<br class="title-page-name"/><br class="title-page-name"/>        filename = str(sys.argv[1])<br class="title-page-name"/>        file = open(filename,'r')<br class="title-page-name"/><br class="title-page-name"/>        for addr in file:<br class="title-page-name"/>         answer = sr1(ARP(pdst=addr.strip()),timeout=1,verbose=0)<br class="title-page-name"/>         if answer == None:<br class="title-page-name"/>             pass<br class="title-page-name"/>         else:<br class="title-page-name"/>             print addr.strip()
</pre>
<ol start="16" class="calibre20">
<li value="16" class="calibre19">The only real difference between this script and the one that was previously used to cycle through a sequential series is the creation of a variable called <kbd class="calibre16"><span>file</span></kbd> rather than <kbd class="calibre16"><span>interface</span></kbd>. The <kbd class="calibre16"><span>open()</span></kbd> function is then used to create an object by opening the <kbd class="calibre16"><span>iplist.txt</span></kbd> file in the same directory as the script. The <kbd class="calibre16"><span>r</span></kbd> value is also passed to the function to specify read-only access to the file. The <kbd class="calibre16"><span>for</span></kbd> loop cycles through each IP address listed in the file and then outputs IP addresses that reply to the broadcast ARP requests. This script can be executed in the same manner as discussed earlier:</li>
</ol>
<div class="p"><img class="image-border47" src="../images/00021.jpeg"/></div>
<ol start="17" class="calibre20">
<li value="17" class="calibre19">If the script is executed without any arguments supplied, the usage is output to the screen. The usage output indicates that this script requires a single argument that defines the input list of IP addresses to be scanned. In the following example, the script is executed using an <kbd class="calibre16"><span>iplist.txt</span></kbd> file in the execution directory:</li>
</ol>
<div class="p"><img class="alignnone25" src="../images/00088.jpeg"/></div>
<ol start="18" class="calibre20">
<li value="18" class="calibre19">Once run, the script will only output the IP addresses that are in the input file and are also responding to ARP request traffic. Each of these addresses represents a system that is alive on the LAN. In the same manner as discussed earlier, the output of this script can be easily redirected to a file using the greater-than sign followed by the desired name of the output file:</li>
</ol>
<div class="p"><img class="alignnone25" src="../images/00153.jpeg"/></div>
<ol start="19" class="calibre20">
<li value="19" class="calibre19">Once the output has been redirected to the output file, you can use the <kbd class="calibre16"><span>ls</span></kbd> command to verify that the file was written to the filesystem, or you can use the <kbd class="calibre16"><span>cat</span></kbd> command to view the contents of the file.</li>
</ol>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section>

            <header id="38STS2-cf89710d791c4a3bb78ec273d9322426">
                </header><h1 class="header-title" id="calibre_pb_0">Layer 3 discovery - ICMP</h1>
            

            <article>
                
<p class="calibre5">In order to send an ICMP echo request using Scapy, we will need to start stacking layers to send requests. A good rule of thumb when stacking packets is to work up through the layers of the OSI model. You can stack multiple layers by separating each layer with a forward slash. To generate an ICMP echo request, an IP layer needs to be stacked with an ICMP request:</p>
<ol class="calibre20">
<li value="1" class="calibre19">To get started, use the <kbd class="calibre16"><span>scapy</span></kbd> command to open the Scapy interactive console, and then assign an <kbd class="calibre16"><span>IP</span></kbd> object to a variable:</li>
</ol>
<div class="p"><img class="alignnone26" src="../images/00334.jpeg"/></div>
<ol start="2" class="calibre20">
<li value="2" class="calibre19">In the example provided, the <kbd class="calibre16"><span>display()</span></kbd> function was used to view the default configurations of the object attributes after it was assigned to the <kbd class="calibre16"><span>ip</span></kbd> variable. By default, the <kbd class="calibre16"><span>IP</span></kbd> object is configured to send and receive using the loopback IP address of <kbd class="calibre16"><span>127.0.0.1</span></kbd>. To change any attribute of an object in Scapy, you need to set <kbd class="calibre16"><span>[object].[attribute]</span></kbd> equal to the desired value. In this case, we want to change the destination IP address to the address of the system that we would like to send the ICMP request to, as shown in the following set of commands:</li>
</ol>
<div class="p"><img class="alignnone27" src="../images/00302.jpeg"/></div>
<ol start="3" class="calibre20">
<li value="3" class="calibre19">After assigning the new value to the destination address attribute, the changes can be verified by calling the <kbd class="calibre16"><span>display()</span></kbd> function once again. Notice that when the destination IP address value is changed to any other value, the source address is also automatically updated from the loopback address to the IP address associated with the default interface. Now that the attributes of the <kbd class="calibre16"><span>IP</span></kbd> object have been appropriately modified, we will need to create the second layer in our packet stack. The next layer to be added to the stack is the ICMP layer, which we will assign to a separate variable:</li>
</ol>
<div class="p"><img class="alignnone28" src="../images/00351.jpeg"/></div>
<ol start="4" class="calibre20">
<li value="4" class="calibre19">In the example provided, the ICMP object was initialized with the <kbd class="calibre16"><span>ping</span></kbd> variable name. The <kbd class="calibre16"><span>display()</span></kbd> function can then be called to display the default configurations of the ICMP attributes. To perform an ICMP echo request, the default configurations are sufficient. Now that both layers have been configured correctly, they can be stacked in preparation to send. In Scapy, layers can be stacked by separating each layer with a forward slash. Have a look at the following set of commands:</li>
</ol>
<div class="p"><img class="alignnone29" src="../images/00672.jpeg"/></div>
<ol start="5" class="calibre20">
<li value="5" class="calibre19">Once the stacked layers have been assigned to a variable, the <kbd class="calibre16"><span>display()</span></kbd> function will then show the entire stack. The process of stacking layers in this manner is often referred to as datagram encapsulation. Now that the layers have been stacked, the request is ready to be sent across the wire. This can be done using the <kbd class="calibre16"><span>sr1()</span></kbd> function in Scapy:</li>
</ol>
<div class="p"><img class="alignnone30" src="../images/00057.jpeg"/></div>
<ol start="6" class="calibre20">
<li value="6" class="calibre19">In the example provided, the <kbd class="calibre16"><span>sr1()</span></kbd> function is assigned to the <kbd class="calibre16"><span>ping_reply</span></kbd> variable. This executes the function and then passes the result to this variable. After receiving the response, the <kbd class="calibre16"><span>display()</span></kbd> function is used on the <kbd class="calibre16"><span>ping_reply</span></kbd> variable to see the contents of the response. Notice that this packet was sent from the host to which we sent the initial request, and the destination address is the IP address of our Kali system. Additionally, notice that the ICMP type of the response is an echo reply. This process of sending and receiving ICMP with Scapy may seem functional, based on this example, but if you attempt to use the same process with a non-responsive target address, you will quickly notice the problem:</li>
</ol>
<div class="p"><img class="alignnone31" src="../images/00585.jpeg"/></div>
<ol start="7" class="calibre20">
<li value="7" class="calibre19">The example output was truncated, but this output will continue indefinitely until you force an escape with <em class="calibre15">Ctrl</em> + <em class="calibre15">C</em>. Without supplying a timeout value to the function, the <kbd class="calibre16"><span>sr1()</span></kbd> function will continue to listen until a response is received. If a host is not alive or if the IP address is not associated with any host, no response will be sent, and the function will not exit. To use this function effectively within a script, a timeout value should be defined:</li>
</ol>
<div class="p"><img class="alignnone32" src="../images/00596.jpeg"/></div>
<ol start="8" class="calibre20">
<li value="8" class="calibre19">By supplying a timeout value as a second argument passed to the <kbd class="calibre16"><span>sr1()</span></kbd> function, the process will then exit if no response is received within the designated number of seconds. In the example provided, the <kbd class="calibre16"><span>sr1()</span></kbd> function is used to send the ICMP request to a nonresponsive address that is exited after 1 second because no response was received. In the examples provided so far, we have assigned functions to variables to create objects that are persistent and can be manipulated. However, these functions do not have to be assigned to variables but can also be generated by calling the functions directly:</li>
</ol>
<div class="p"><img class="alignnone33" src="../images/00270.jpeg"/></div>
<ol start="9" class="calibre20">
<li value="9" class="calibre19">In the example provided here, all of the work that was done earlier with four separate commands can actually be accomplished with a single command by directly calling the functions. Notice that if an ICMP request is sent to an IP address that does not reply within the timeframe specified by the timeout value, calling the object will result in an exception. As no response was received, the answer variable in this example that was set equal to the response is never initialized:</li>
</ol>
<div class="p"><img class="alignnone31" src="../images/00347.jpeg"/></div>
<ol start="10" class="calibre20">
<li value="10" class="calibre19">Knowledge of these varied responses can be used to generate a script that will perform ICMP requests on multiple IP addresses in sequence. The script will loop through all of the possible values for the last octet in the destination IP address, and for each value, it will send an ICMP request. As each <kbd class="calibre16"><span>sr1()</span></kbd> function is returned, the response is evaluated to determine whether an echo response was received:</li>
</ol>
<pre class="calibre24">
        #!/usr/bin/python<br class="title-page-name"/><br class="title-page-name"/>        import logging<br class="title-page-name"/>        logging.getLogger("scapy.runtime").setLevel(logging.ERROR)<br class="title-page-name"/>        from scapy.all import *<br class="title-page-name"/><br class="title-page-name"/>        if len(sys.argv) != 2:<br class="title-page-name"/>         print "Usage - ./pinger.py [/24 network address]"<br class="title-page-name"/>         print "Example - ./pinger.py 172.16.36.0"<br class="title-page-name"/>         print "Example will perform an ICMP scan of<br class="title-page-name"/>           the 172.16.36.0/24 range"<br class="title-page-name"/>         sys.exit()<br class="title-page-name"/><br class="title-page-name"/>        address = str(sys.argv[1])<br class="title-page-name"/>        prefix = address.split('.')[0] + '.' + address.split('.')[1]<br class="title-page-name"/>          + '.' +address.split('.')[2] + '.'<br class="title-page-name"/><br class="title-page-name"/>        for addr in range(1,254):<br class="title-page-name"/>         answer=sr1(ARP(pdst=prefix+str(addr)),timeout=1,verbose=0)<br class="title-page-name"/>         if answer == None:<br class="title-page-name"/>             pass<br class="title-page-name"/>         else:<br class="title-page-name"/>             print prefix+str(addr)
</pre>
<div class="calibre31">
<ul class="calibre18">
<li class="calibre19">The first line of the script indicates where the Python interpreter is located so that the script can be executed without it being passed to the interpreter. The script then imports all Scapy functions and also defines Scapy logging levels to eliminate unnecessary output in the script.</li>
<li class="calibre19">The second block of code is a conditional test that evaluates whether the required argument is supplied to the script. If the required argument is not supplied upon execution, the script will then output an explanation of appropriate script usage. This explanation includes the usage of the tool, an example, and an explanation of the task that will be performed by this example.</li>
<li class="calibre19">After this block of code, the supplied value is assigned to the <kbd class="calibre16"><span>address</span></kbd> variable. That value is then used to extract the network prefix. For example, if the <kbd class="calibre16"><span>address</span></kbd> variable contains the <kbd class="calibre16"><span>192.168.11.0</span></kbd> string , the value of <span><kbd class="calibre16">192.168.11</kbd></span> will be assigned to the <kbd class="calibre16"><span>prefix</span></kbd> variable.</li>
<li class="calibre19">The final block of code is a <kbd class="calibre16"><span>for</span></kbd> loop that performs the actual scanning. The <kbd class="calibre16"><span>for</span></kbd> loop cycles through all values between <kbd class="calibre16"><span>0</span></kbd> and <kbd class="calibre16"><span>254</span></kbd>, and for each iteration, the value is then appended to the network prefix. In the case of the example provided earlier, an ICMP echo request would be sent to each IP address between <kbd class="calibre16"><span>192.168.11.0</span></kbd> and <kbd class="calibre16"><span>192.168.11.254</span></kbd>. For each live host that does reply, the corresponding IP address is then printed to the screen to indicate that the host is alive on the LAN.</li>
</ul>
</div>
<ol start="11" class="calibre20">
<li value="11" class="calibre19">Once the script has been written to the local directory, you can execute it in the Terminal using a period and forward slash, followed by the name of the executable script:</li>
</ol>
<div class="p"><img class="alignnone34" src="../images/00631.jpeg"/></div>
<ol start="12" class="calibre20">
<li value="12" class="calibre19">If the script is executed without any arguments supplied, the usage is output to the screen. The usage output indicates that this script requires a single argument that defines the <kbd class="calibre16"><span>/24</span></kbd> network to scan. In the example provided, the script is executed using the <kbd class="calibre16"><span>172.16.36.0</span></kbd> network address. The script then outputs a list of live IP addresses in the <kbd class="calibre16"><span>/24</span></kbd> network range. This output can also be redirected to an output text file using a greater-than sign followed by the output filename. An example of this is as follows:</li>
</ol>
<div class="p"><img class="image-border47" src="../images/00512.jpeg"/></div>
<ol start="13" class="calibre20">
<li value="13" class="calibre19">The <kbd class="calibre16"><span>ls</span></kbd> command can then be used to verify that the output file was written to the filesystem, or the <kbd class="calibre16"><span>cat</span></kbd> command can be used to view its contents. This script can also be modified to accept a list of IP addresses as input. To do this, the <kbd class="calibre16"><span>for</span></kbd> loop must be changed to loop through the lines that are read from the specified text file. An example of this can be seen as follows:</li>
</ol>
<pre class="calibre24">
        #!/usr/bin/python<br class="title-page-name"/><br class="title-page-name"/>        import logging<br class="title-page-name"/>        logging.getLogger("scapy.runtime").setLevel(logging.ERROR)<br class="title-page-name"/>        from scapy.all import *<br class="title-page-name"/><br class="title-page-name"/>        if len(sys.argv) != 2:<br class="title-page-name"/>         print "Usage - ./pinger.py [filename]"<br class="title-page-name"/>         print "Example - ./pinger.py iplist.txt"<br class="title-page-name"/>         print "Example will perform an ICMP ping scan<br class="title-page-name"/>           of the IP addresses listed in iplist.txt"<br class="title-page-name"/>         sys.exit()<br class="title-page-name"/><br class="title-page-name"/>        filename = str(sys.argv[1])<br class="title-page-name"/>        file = open(filename,'r')<br class="title-page-name"/><br class="title-page-name"/>        for addr in file:<br class="title-page-name"/>         ans=sr1(IP(dst=addr.strip())/ICMP(),timeout=1,verbose=0)<br class="title-page-name"/>         if ans == None:<br class="title-page-name"/>           pass<br class="title-page-name"/>         else:<br class="title-page-name"/>            print addr.strip()
</pre>
<ol start="14" class="calibre20">
<li value="14" class="calibre19">The only major difference from the prior script is that this one accepts an input <kbd class="calibre16"><span>filename</span></kbd> as an argument and then loops through each IP address listed in this file to scan. Similar to the other script, the resulting output will include a simple list of IP addresses associated with systems that responded to the ICMP echo request with an ICMP echo response:</li>
</ol>
<div class="p"><img class="image-border47" src="../images/00478.jpeg"/></div>
<ol start="15" class="calibre20">
<li value="15" class="calibre19">The output of this script can be redirected to an output file in the same way. Execute the script with the input file supplied as an argument and then redirect the output using a greater-than sign followed by the name of the output text file.  An example of this can be seen as follows:</li>
</ol>
<div class="p"><img class="image-border47" src="../images/00637.jpeg"/></div>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section>

            <header id="39REE2-cf89710d791c4a3bb78ec273d9322426">
                </header><h1 class="header-title" id="calibre_pb_0">Layer 4 discovery - TCP and UDP</h1>
            

            <article>
                
<p class="calibre5">To verify that an RST response is received from a live host, we can use Scapy to send a TCP ACK packet to a known live host. In the example provided, the ACK packet will be sent to the TCP destination port <kbd class="calibre16"><span>80</span></kbd>. This port is commonly used to run HTTP web services. The host used in the demonstration currently has an Apache service running on this port.</p>
<ol class="calibre20">
<li value="1" class="calibre19">To do this, we need to build each of the layers of our request. The first layer to be built is the IP layer. Have a look at the following command:</li>
</ol>
<div class="p"><img class="alignnone35" src="../images/00484.jpeg"/></div>
<ol start="2" class="calibre20">
<li value="2" class="calibre19">Here, we have initialized the <kbd class="calibre16"><span>i</span></kbd> variable as an <kbd class="calibre16"><span>IP</span></kbd> object and then reconfigured the standard configurations to set the destination address to the IP address of our target server. Notice that the source IP address is automatically updated when any IP address other than the loopback address is provided for the destination address. The next layer we need to build is our TCP layer. This can be seen in the commands that follow:</li>
</ol>
<div class="p"><img class="alignnone36" src="../images/00486.jpeg"/></div>
<ol start="3" class="calibre20">
<li value="3" class="calibre19">Here, we have initialized the <kbd class="calibre16"><span>t</span></kbd> variable as a <kbd class="calibre16"><span>TCP</span></kbd> object. Notice that the default configurations for the object already have the destination port set to HTTP or port <kbd class="calibre16"><span>80</span></kbd>. Here, we only needed to change the TCP flags from SYN (<kbd class="calibre16"><span>S</span></kbd>) to ACK (<kbd class="calibre16"><span>A</span></kbd>). Now, the stack can be built by separating each of the layers with a forward slash, as seen in the following commands:</li>
</ol>
<div class="p"><img class="alignnone37" src="../images/00489.jpeg"/></div>
<ol start="4" class="calibre20">
<li value="4" class="calibre19">Here, we have set the entire request stack equal to the request variable. Now, the request can be sent across the wire with the send and receive function, and then the response can be evaluated to determine the status of the target address:</li>
</ol>
<div class="p"><img class="alignnone38" src="../images/00026.jpeg"/></div>
<ol start="5" class="calibre20">
<li value="5" class="calibre19">Notice that the remote system responds with a TCP packet that has the RST flag set. This is indicated by the <kbd class="calibre16"><span>R</span></kbd> value assigned to the <kbd class="calibre16"><span>flags</span></kbd> attribute. The entire process of stacking the request and sending and receiving the response can be compressed into a single command by calling the functions directly:</li>
</ol>
<div class="p"><img class="alignnone38" src="../images/00493.jpeg"/></div>
<ol start="6" class="calibre20">
<li value="6" class="calibre19">Now that we have identified the response associated with an ACK packet sent to an open port on a live host, let's attempt to send a similar request to a closed port on a live system and identify whether there is any variation in response:</li>
</ol>
<div class="p"><img class="alignnone38" src="../images/00495.jpeg"/></div>
<ol start="7" class="calibre20">
<li value="7" class="calibre19">In this request, the destination TCP port was changed from the default port <kbd class="calibre16"><span>80</span></kbd> to the port <kbd class="calibre16"><span>1111</span></kbd> (a port on which no service is running). Notice that the response that is returned from both an open port and a closed port on a live system is the same. Regardless of whether this is a service actively running on the scanned port, a live system will return an RST response. Additionally, it should be noted that if a similar scan is sent to an IP address that is not associated with a live system, no response will be returned. This can be verified by modifying the destination IP address in the request to one that is not associated with an actual system on the network:</li>
</ol>
<div class="p"><img class="alignnone32" src="../images/00066.jpeg"/></div>
<ol start="8" class="calibre20">
<li value="8" class="calibre19">So, in review, we discovered that an ACK packet sent to a live host on any port, regardless of the port status, will return an RST packet, but no response will be received from an IP if no live host is associated with it. This is excellent news because it means that we can perform a discovery scan on a large number of systems by only interacting with a single port on each system. Using Scapy in conjunction with Python, we can quickly loop through all of the addresses in a <kbd class="calibre16"><span>/24</span></kbd> network range and send a single ACK packet to only one TCP port on each system. By evaluating the response returned by each host, we can easily output a list of live IP addresses:</li>
</ol>
<pre class="calibre24">
        #!/usr/bin/python<br class="title-page-name"/><br class="title-page-name"/>        import logging<br class="title-page-name"/>        logging.getLogger("scapy.runtime").setLevel(logging.ERROR)<br class="title-page-name"/>        from scapy.all import *<br class="title-page-name"/><br class="title-page-name"/>        if len(sys.argv) != 2:<br class="title-page-name"/>         print "Usage - ./ACK_Ping.py [/24 network address]"<br class="title-page-name"/>         print "Example - ./ACK_Ping.py 172.16.36.0"<br class="title-page-name"/>         print "Example will perform a TCP ACK ping scan<br class="title-page-name"/>           of the 172.16.36.0/24 range"<br class="title-page-name"/>         sys.exit()<br class="title-page-name"/><br class="title-page-name"/>        address = str(sys.argv[1])<br class="title-page-name"/>        prefix = address.split('.')[0] + '.' + address.split('.')[1]<br class="title-page-name"/>         + '.' + address.split('.')[2] + '.'<br class="title-page-name"/><br class="title-page-name"/>        for addr in range(1,254):<br class="title-page-name"/>        response = sr1(IP(dst=prefix+str(addr))/<br class="title-page-name"/>        TCP(dport=80,flags='A'),timeout=1,verbose=0)<br class="title-page-name"/>         try:<br class="title-page-name"/>             if int(response[TCP].flags) == 4:<br class="title-page-name"/>                 print "172.16.36."+str(addr)<br class="title-page-name"/>         except:<br class="title-page-name"/>             pass
</pre>
<ol start="9" class="calibre20">
<li value="9" class="calibre19">The example script that is provided is fairly simple. While looping through each of the possible values for the last octet in the IP address, the ACK packet is sent to the TCP port <kbd class="calibre16"><span>80</span></kbd>, and the response is evaluated to determine whether the integer conversion of the TCP flag within the response has the value of <kbd class="calibre16"><span>4</span></kbd> (the value associated with a solitary RST flag). If the packet has an RST flag, the script outputs the IP address of the system that returned the response. If no response is received, Python is unable to test the value of the response variable as no value is assigned to it. As such, an exception will occur if no response is returned. If an exception is returned, the script will then pass. The resulting output is a list of live target IP addresses. This script can be executed using a period and forward slash, followed by the name of the executable script:</li>
</ol>
<div class="p"><img class="alignnone27" src="../images/00232.jpeg"/></div>
<ol start="10" class="calibre20">
<li value="10" class="calibre19">Similar discovery methods can be used to perform layer 4 discovery using the UDP protocol. To determine whether we can discover a host using the UDP protocol, we need to determine how to trigger a response from any live host with UDP, regardless of whether the system has a service running on the UDP port. To attempt this, we will first build our request stack in Scapy:</li>
</ol>
<div class="p"><img class="alignnone39" src="../images/00503.jpeg"/></div>
<ol start="11" class="calibre20">
<li value="11" class="calibre19">Notice that the default source and destination port for the UDP object is DNS. This is a commonly used service that can be used to resolve domain names to IP addresses. Sending the request as it is will prove to be of very little help in determining whether the IP address is associated with a live host. An example of sending this request can be seen in the following command:</li>
</ol>
<div class="p"><img class="alignnone40" src="../images/00647.jpeg"/></div>
<ol start="12" class="calibre20">
<li value="12" class="calibre19">Despite the fact that the host associated with the destination IP address is alive, we receive no response. Ironically, the lack of response is actually due to the fact that the DNS service is in use on the target system. Despite what you might naturally think, it can sometimes be more effective to attempt to identify hosts by probing UDP ports that are not running services, assuming that ICMP traffic is not blocked by a firewall. This is because live services are often configured to only respond to requests that contain specific content. Now, we will attempt to send the same request to a different UDP port that is not in use:</li>
</ol>
<div class="p"><img class="alignnone41" src="../images/00023.jpeg"/></div>
<ol start="13" class="calibre20">
<li value="13" class="calibre19">By changing the request destination to port <kbd class="calibre16"><span>123</span></kbd> and then resending it, we now receive a response indicating that the destination port is unreachable. If you examine the source IP address of this response, you can see that it was sent from the host to which the original request was sent. This response then confirms that the host at the original destination IP address is alive. Unfortunately, a response is not always returned in these circumstances. The effectiveness of this technique largely depends on the systems that you are probing and their configurations. It is because of this that UDP discovery is often more difficult to perform than TCP discovery. It is never as easy as just sending a TCP packet with a single flag lit up. In the case that services do exist, service-specific probes are often needed.</li>
</ol>
<p class="calibre5">Fortunately, there are a variety of fairly complex UDP-scanning tools that can employ a range of UDP requests and service-specific probes to determine whether a live host is associated with any given IP address.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="3APV01-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works…</h1>
            

            <article>
                
<p class="calibre5">ARP layer 2 discovery is possible in Scapy by employing the use of the <kbd class="calibre16"><span>sr1()</span></kbd> (send/receive one) function. This function injects a packet, as defined by the supplied argument, and then waits to receive a single response. In this case, a single ARP request is broadcast, and the function will return the response. The Scapy library makes it possible to easily integrate this technique into a script and enables the testing of multiple systems.</p>
<p class="calibre5">ICMP layer 3 discovery was performed here with Scapy by crafting a request that includes both an IP layer and an appended ICMP request. The IP layer allowed the packet to be routed outside the local network, and the ICMP request was used to solicit a response from the remote system. Using this technique in a Python script, this task can be performed in sequence to scan multiple systems or entire network ranges.</p>
<p class="calibre5">TCP and UDP layer 4 discovery methods were used by Scapy to craft custom requests to identify live hosts using each of these protocols. In the case of TCP, the custom ACK packets were constructed and sent to an arbitrary port on each target system. If an RST reply was received, the system was identified as alive. Alternatively, empty UDP requests were sent to arbitrary ports to attempt to solicit an ICMP port unreachable response. Responses were used as an indication of a live system. Each of these techniques can be used in a Python script to perform discovery against multiple hosts or against a range of addresses.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="3BOFI1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Using Nmap to perform host discovery (layers 2/3/4)</h1>
            

            <article>
                
<p class="calibre5"><strong class="calibre1">Network Mapper</strong> (<strong class="calibre1">Nmap</strong>) is one of the most effective and functional tools in Kali Linux. Nmap can be used to perform a large range of different scanning techniques and is highly customizable. This tool will be addressed frequently throughout the course of this book. In this recipe, we will discuss how to use Nmap to perform layer 2 scanning with ARP, layer 3 scanning with ICMP, and layer 4 scanning utilizing TCP/UDP.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="3CN041-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre5">To use Nmap to perform ARP discovery, you will need to have at least one system on the LAN that will respond to ARP requests. In the examples provided, a combination of Linux and Windows systems are used. For more information on setting up systems in a local lab environment, refer to the <em class="calibre15">Installing Metasploitable2</em> and <em class="calibre15">Installing Windows Server</em> recipes in <a href="part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426" class="calibre6">Chapter 1</a>, <em class="calibre15">Getting Started</em>.</p>
<p class="calibre5">Using Nmap to perform layer 3 and layer 4 discovery does not require a lab environment, as many systems on the Internet will reply to ICMP echo requests, as well as both TCP and UDP traffic. However, it is highly recommended that you perform any type of network scanning exclusively in your own lab unless you are thoroughly familiar with the legal regulations imposed by any governing authorities to whom you are subject. If you wish to perform this technique within your lab, you will need to have at least one system that will respond to ICMP, TCP, and UDP requests. In the examples provided, a combination of Linux and Windows systems are used. For more information on setting up systems in a local lab environment, refer to the the <em class="calibre15">Installing Metasploitable2</em> and <em class="calibre15">Installing Windows Server</em> recipes in <a href="part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426" target="_blank" class="calibre6">Chapter 1</a>, <em class="calibre15">Getting Started</em>. Additionally, this section will require a script to be written to the filesystem, using a text editor such as Vim or <span>GNU n</span>ano. For more information on writing scripts, refer to the <em class="calibre15">Using text editors (VIM and <span>GNU n</span>ano)</em> recipe in <a href="part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426" target="_blank" class="calibre6">Chapter 1</a>, <em class="calibre15">Getting Started</em>.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="3DLGM1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it…</h1>
            

            <article>
                
<p class="calibre5">As in the previous recipe, we'll go through this layer by layer.  In this layer, we will use Nmap to perform discovery at layers 2, 3, and 4.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="3EK181-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Layer 2 discovery - ARP</h1>
            

            <article>
                
<p class="calibre5">Nmap is another option for performing automated layer 2 discovery scans with a single command. The <kbd class="calibre16">-sn</kbd> option is referred to by Nmap as a ping scan. Although the term <strong class="calibre1">ping scan</strong> naturally leads you to think that layer 3 discovery is being performed, it is actually adaptive:</p>
<ol class="calibre20">
<li value="1" class="calibre19">Assuming that addresses on the same local subnet are specified as the argument, a layer 2 scan can be performed with the following command:</li>
</ol>
<div class="p"><img class="alignnone42" src="../images/00091.jpeg"/></div>
<ol start="2" class="calibre20">
<li value="2" class="calibre19">This command will send an ARP request to the LAN broadcast address and will determine whether the host is alive, based on the response that is received. Alternatively, if the command is used against an IP address of a host that is not alive, the response will indicate that the host is down:</li>
</ol>
<div class="p"><img class="alignnone43" src="../images/00675.jpeg"/></div>
<ol start="3" class="calibre20">
<li value="3" class="calibre19">This command can be modified to perform layer 2 discovery on a sequential series of IP addresses, using dash notation. To scan a full <kbd class="calibre16">/24</kbd> range, you can use <kbd class="calibre16">0-255</kbd>:</li>
</ol>
<div class="p"><img class="alignnone44" src="../images/00159.jpeg"/></div>
<ol start="4" class="calibre20">
<li value="4" class="calibre19">Using this command will send out broadcast ARP requests for all hosts within that range and will determine each host that is actively responding. This scan can also be performed against an input list of IP addresses, using the <kbd class="calibre16">-iL</kbd> option:</li>
</ol>
<p class="calibre5"><img class="alignnone45" src="../images/00305.jpeg"/></p>
<ol start="5" class="calibre20">
<li value="5" class="calibre19">When the <kbd class="calibre16">-sn</kbd> option is used, Nmap will first attempt to locate the host using layer 2 ARP requests, and it will only use layer 3 ICMP requests if the host is not located on the LAN. Notice how an Nmap ping scan performed against the hosts on the local network (on the <kbd class="calibre16">172.16.36.0/24</kbd> private range) returns MAC addresses. This is because the MAC addresses are returned by the ARP response from the hosts. However, if the same Nmap ping scan is performed against remote hosts on a different LAN, the response will not include system MAC addresses:</li>
</ol>
<div class="p"><img class="alignnone46" src="../images/00195.jpeg"/></div>
<ol start="6" class="calibre20">
<li value="6" class="calibre19">When performed against a remote network range (public range <kbd class="calibre16">74.125.21.0/24</kbd>), you can see that layer 3 discovery was used, as no MAC addresses were returned. This demonstrates that when possible, Nmap will automatically leverage the speed of layer 2 discovery, but when necessary, it will use routable ICMP requests to discover remote hosts on layer 3. This can also be seen if you use Wireshark to monitor traffic while an Nmap ping scan is performed against hosts on the local network.</li>
</ol>
<ol start="7" class="calibre20">
<li value="7" class="calibre19">In the following screenshot, you can see that Nmap utilizes ARP requests to identify hosts on the local segment:</li>
</ol>
<div class="p"><img class="alignnone47" src="../images/00209.jpeg"/></div>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="3FIHQ1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Layer 3 discovery - ICMP</h1>
            

            <article>
                
<p class="calibre5">Nmap is an adaptive tool that will automatically adjust and use layer 2, layer 3, or layer 4 discovery as needed. If the <kbd class="calibre16">-sn</kbd> option is used in Nmap to scan IP addresses that do not exist on the local network segment, ICMP echo requests will be used to determine whether the hosts are alive and responding.</p>
<ol class="calibre20">
<li value="1" class="calibre19">To perform an ICMP scan of a single target, use Nmap with the <kbd class="calibre16">-sn</kbd> option, and pass the IP address to be scanned as an argument:</li>
</ol>
<div class="p"><img class="alignnone48" src="../images/00523.jpeg"/></div>
<ol start="2" class="calibre20">
<li value="2" class="calibre19">The output of this command will indicate whether the device is up and will also provide details about the scan performed. Additionally, notice that the system name is also identified. Nmap also performs DNS resolution to provide this information in the scan output. It can also be used to scan a sequential range of IP addresses, using dash notation. Nmap is multithreaded by default and runs multiple processes in parallel. As such, Nmap is very fast in returning scan results. Have a look at the following command:</li>
</ol>
<div class="p"><img class="alignnone49" src="../images/00526.jpeg"/></div>
<ol start="3" class="calibre20">
<li value="3" class="calibre19">In the example provided, Nmap is used to scan an entire <kbd class="calibre16">/24</kbd> network range. For convenience of viewing, the output of this command was truncated. By analyzing the traffic passing across the interface with Wireshark, you may notice that the addresses are not sequentially scanned. This can be seen in the following screenshot. This is further evidence of the multithreaded nature of Nmap and illustrates how processes are initiated from addresses in a queue as other processes complete:</li>
</ol>
<div class="p"><img class="alignnone50" src="../images/00660.jpeg"/></div>
<ol start="4" class="calibre20">
<li value="4" class="calibre19">Alternatively, Nmap can also be used to scan IP addresses from an input text file. This can be done using the <kbd class="calibre16">-iL</kbd> option, followed by the name of the file or file path:</li>
</ol>
<div class="p"><img class="alignnone28" src="../images/00529.jpeg"/></div>
<ol start="5" class="calibre20">
<li value="5" class="calibre19">In the example provided, a list of six IP addresses exists in the execution directory. This list is then input into Nmap, and each of the listed addresses is scanned in an attempt to identify live hosts:</li>
</ol>
<div class="p"><img class="alignnone51" src="../images/00280.jpeg"/></div>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="3GH2C1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Layer 4 discovery - TCP and UDP</h1>
            

            <article>
                
<p class="calibre5">There are options in Nmap to discover hosts with both TCP and UDP. UDP discovery with Nmap is already configured to use unique payloads necessary to trigger replies from less-responsive port services:</p>
<ol class="calibre20">
<li value="1" class="calibre19">To perform a discovery scan with UDP, use the <kbd class="calibre16">-PU</kbd> option in conjunction with the port to test:</li>
</ol>
<div class="p"><img class="alignnone52" src="../images/00534.jpeg"/></div>
<ol start="2" class="calibre20">
<li value="2" class="calibre19">Similarly, it is also possible to configure an Nmap UDP ping request to a series of IP addresses as defined by an input list. Here, in the example provided, we will use the <kbd class="calibre16">iplist.txt</kbd> file in the same directory to scan each host listed within:</li>
</ol>
<div class="p"><img class="alignnone53" src="../images/00253.jpeg"/></div>
<ol start="3" class="calibre20">
<li value="3" class="calibre19">Although the output from each of these examples indicated that six hosts were discovered, this does not necessarily indicate that the six hosts were all discovered by means of the UDP discovery method. In addition to the probing performed on UDP port <kbd class="calibre16">53</kbd>, Nmap also will utilize any other discovery technique it can to discover hosts within the designated range or within the input list. Although the <kbd class="calibre16">-sn</kbd> option is effective in preventing Nmap from performing a TCP port scan, it does not completely isolate our UDP ping request.</li>
<li value="4" class="calibre19">Although there is no effective way to isolate just this task, you can determine what hosts were discovered via UDP requests by analyzing the traffic in Wireshark or TCPdump. Alternatively, Nmap can also be used to perform a TCP ACK ping in the same fashion as was discussed with Scapy. To use ACK packets to identify live hosts, use the <kbd class="calibre16">-PA</kbd> option in conjunction with the port that you would like to use:</li>
</ol>
<div class="p"><img class="alignnone54" src="../images/00327.jpeg"/></div>
<ol start="5" class="calibre20">
<li value="5" class="calibre19">The TCP ACK ping-discovery method can also be performed on a range of hosts using dash notation, or can be performed on specified host addresses based on an input list:</li>
</ol>
<div class="p"><img class="alignnone55" src="../images/00540.jpeg"/></div>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="3HFIU1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works…</h1>
            

            <article>
                
<p class="calibre5">Nmap performs layer 2 scanning by sending out ARP requests to the broadcast address for a series of IP addresses and identifies live hosts by flagging responses. However, because this functionality is already integrated into Nmap, it can be executed by simply providing the appropriate arguments.</p>
<p class="calibre5">Nmap performs layer 3 scanning by sending out ICMP echo requests for each IP address within the supplied range or text file. As Nmap is a multithreaded tool, multiple requests are sent out in parallel, and results are quickly returned to the user. As Nmap's discovery function is adaptive, it will only use ICMP discovery if ARP discovery cannot effectively locate the host on the local subnet. Alternatively, if neither ARP discovery nor ICMP discovery is effective in identifying a live host at a given IP address, layer 4 discovery techniques will be employed.</p>
<p class="calibre5">Nmap performs layer 4 scanning by sending a series of TCP ACK packets to arbitrary ports on the target system and attempts to solicit an RST response as an indication of a live system. The technique used by Nmap to perform UDP discovery, however, is somewhat different than the technique we discussed with Scapy. Rather than merely relying on ICMP host-unreachable responses, which can be inconsistent and/or blocked, Nmap also performs host discovery by delivering service-specific requests to targeted ports in an attempt to solicit a response.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="3IE3G1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Using ARPing to perform host discovery (layer 2)</h1>
            

            <article>
                
<p class="calibre5">ARPing is a command-line network utility that has a functionality similar to the commonly used <kbd class="calibre16">ping</kbd> utility. This tool can identify whether a live host is on a local network at a given IP by supplying that IP address as an argument. This recipe will discuss how to use ARPing to scan for live hosts on a network.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="3JCK21-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre5">To use ARPing to perform ARP discovery, you will need to have at least one system on the LAN that will respond to ARP requests. In the examples provided, a combination of Linux and Windows systems is used. For more information on setting up systems in a local lab environment, refer to the <em class="calibre15">Installing Metasploitable2</em> and <em class="calibre15">Installing Windows Server</em> recipes in <a href="part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426" target="_blank" class="calibre6">Chapter 1</a>, <em class="calibre15">Getting Started</em>. Additionally, this section will require a script to be written to the filesystem, using a text editor such as Vim or <span>GNU n</span>ano. For more information on writing scripts, refer to the <em class="calibre15">Using text editors (Vim and <span>GNU n</span>ano)</em> recipe in <a href="part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426" target="_blank" class="calibre6">Chapter 1</a>, <em class="calibre15">Getting Started</em>.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section>

            <header id="3KB4K2-cf89710d791c4a3bb78ec273d9322426">
                </header><h1 class="header-title" id="calibre_pb_0">How to do it…</h1>
            

            <article>
                
<p class="calibre5">ARPing is a tool that can be used to send ARP requests and identify whether a host is alive and responding:</p>
<ol class="calibre20">
<li class="calibre19" value="1">The tool is used by simply passing an IP address as an argument to it:</li>
</ol>
<div class="p"><img class="alignnone54" src="../images/00462.jpeg"/></div>
<ol start="2" class="calibre20">
<li class="calibre19" value="2">In the example provided, a single ARP request is sent to the broadcast address, requesting the physical location of the <kbd class="calibre16">172.16.36.135</kbd> IP address. As indicated by the output, a single reply was received by the host with the <kbd class="calibre16">00:0C:29:3D:84:32</kbd> MAC address. This tool can be more effectively used for layer 2 discovery scanning if a bash script is used to perform this action on multiple hosts simultaneously. In order to test the responses of each instance in bash, we should determine a unique string that is included in the response, indicating a live host, but not included when no response is received.</li>
<li class="calibre19" value="3">To identify a unique string, an ARPing request should be made to a non-responsive IP address:</li>
</ol>
<div class="p"><img class="alignnone56" src="../images/00465.jpeg"/></div>
<ol start="4" class="calibre20">
<li class="calibre19" value="4">By analyzing varying responses from successful and unsuccessful ARPings, one might notice that the unique bytes from a string only exist in the response if there is a live host associated with the provided IP address, and it is also within a line that includes the IP address. By grepping this response, we can extract the IP address for each responding host:</li>
</ol>
<div class="p"><img class="alignnone57" src="../images/00141.jpeg"/></div>
<ol start="5" class="calibre20">
<li class="calibre19" value="5">Grepping for this unique string when performing an ARPing against an actual host IP returns a line with that IP address included, as seen in the first response from the previous set of commands. Performing the same task against an IP address that is not associated with an actual host returns nothing, as seen in the last response from the previous set of commands. Using <kbd class="calibre16">cut</kbd> with a specially crafted delimiter (<kbd class="calibre16">-d</kbd>) and the field (<kbd class="calibre16">-f</kbd>) values, we can quickly extract the IP address from this string. The command-line function <kbd class="calibre16">cut</kbd> can be used in bash to separate a line into an array, based on a specified delimiter. A specific value can then be returned from the <kbd class="calibre16">cut</kbd> function by specifying the field. By piping over the output multiple times, we can easily extract the MAC address from the returned string. Have a look at the following set of commands:</li>
</ol>
<div class="p"><img class="alignnone58" src="../images/00271.jpeg"/></div>
<ol start="6" class="calibre20">
<li value="6" class="calibre19">We can easily extract the IP address from the returned string by merely manipulating the delimiter and field values supplied to the <kbd class="calibre16">cut</kbd> function:</li>
</ol>
<div class="p"><img class="alignnone59" src="../images/00290.jpeg"/></div>
<ol start="7" class="calibre20">
<li class="calibre19" value="7">Upon identifying how to extract the IP address from a positive ARPing response, we can easily pass this task through a loop in a bash script and output a list of live IP addresses. An example of a script that uses this technique is as follows:</li>
</ol>
<pre class="calibre24">
        #!/bin/bash<br class="title-page-name"/><br class="title-page-name"/>        if [ "$#" -ne 1 ]; then<br class="title-page-name"/>        echo "Usage - ./arping.sh [interface]"<br class="title-page-name"/>        echo "Example - ./arping.sh eth0"<br class="title-page-name"/>        echo "Example will perform an ARP scan of the <br class="title-page-name"/>          local subnet to which eth0 is assigned"<br class="title-page-name"/>        exit<br class="title-page-name"/>        fi<br class="title-page-name"/><br class="title-page-name"/>        interface=$1<br class="title-page-name"/>        prefix=$(ifconfig $interface | grep 'inet ' <br class="title-page-name"/>        | awk '{ print $2 }'| cut -d ':' -f 2 | cut -d '.' -f 1-3)<br class="title-page-name"/><br class="title-page-name"/>        for addr in {1..254}; do<br class="title-page-name"/>        arping -c 1 $prefix.$addr | grep "bytes from" <br class="title-page-name"/>        | cut -d " " -f 5 | cut -d "(" -f 2 | cut -d ")" -f 1 &amp;<br class="title-page-name"/>        done
</pre>
<div class="calibre31">
<ul class="calibre18">
<li class="calibre19">In the bash script that is provided, the first line defines the location of the bash interpreter. The block of code that follows performs a test to determine whether the expected argument was supplied. This is determined by evaluating whether the number of supplied arguments is not equal to <kbd class="calibre16">1</kbd>. If the expected argument is not supplied, the usage of the script is output, and the script exits. The usage output indicates that the script is expecting the local interface name as an argument.</li>
<li class="calibre19">The next block of code assigns the supplied argument to the <kbd class="calibre16">interface</kbd> variable. The <kbd class="calibre16">interface</kbd> value is then supplied to <kbd class="calibre16">ifconfig</kbd>, and the output is then used to extract the network prefix. For example, if the IP address of the supplied interface is <kbd class="calibre16">192.168.11.4</kbd>, the prefix variable would be assigned <kbd class="calibre16">192.168.11</kbd>. A <kbd class="calibre16">for</kbd> loop is then used to cycle through the values of the last octet to generate each possible IP address in the local <kbd class="calibre16">/24</kbd> network. For each possible IP address, a single <kbd class="calibre16">arping</kbd> command is issued. The response for each of these requests is then piped over, and then <kbd class="calibre16">grep</kbd> is used to extract lines with the <kbd class="calibre16">bytes from</kbd> phrase. As discussed earlier, this will only extract lines that include the IP address of live hosts.</li>
<li class="calibre19">Finally, a series of <kbd class="calibre16">cut</kbd> functions are used to extract the IP address from this output.</li>
</ul>
</div>
<ol start="8" class="calibre20">
<li value="8" class="calibre19">Notice that an ampersand is used at the end of the <kbd class="calibre16">for</kbd> loop task instead of a semicolon. The ampersand allows the tasks to be performed in parallel instead of in sequence. This drastically reduces the amount of time required to scan the IP range. Have a look at the following set of commands:</li>
</ol>
<div class="p"><img class="alignnone60" src="../images/00471.jpeg"/></div>
<ol start="9" class="calibre20">
<li class="calibre19" value="9">One can easily redirect the output of the script to a text file that can then be used for subsequent analysis. The output can be redirected using the greater-than sign, followed  by the name of the text file. An example of this can be seen here:</li>
</ol>
<div class="p"><img class="alignnone56" src="../images/00463.jpeg"/></div>
<ol start="10" class="calibre20">
<li value="10" class="calibre19">Once the output has been redirected to the output file, you can use the <kbd class="calibre16">ls</kbd> command to verify that the file was written to the filesystem, or you can use the <kbd class="calibre16">cat</kbd> command to view the contents of the file. This script can also be modified to read from an input file and only verify that the hosts listed in this file are alive. For the following script, you will need an input file with a list of IP addresses. For this, we can use the same input file that was used for the Scapy script, discussed in the previous recipe:</li>
</ol>
<pre class="calibre24">
        #!/bin/bash<br class="title-page-name"/><br class="title-page-name"/>        if [ "$#" -ne 1 ]; then<br class="title-page-name"/>        echo "Usage - ./arping.sh [input file]"<br class="title-page-name"/>        echo "Example - ./arping.sh iplist.txt"<br class="title-page-name"/>        echo "Example will perform an ARP scan of all IP addresses<br class="title-page-name"/>         defined in iplist.txt"<br class="title-page-name"/>        exit<br class="title-page-name"/>        fi<br class="title-page-name"/><br class="title-page-name"/>        file=$1<br class="title-page-name"/><br class="title-page-name"/>        for addr in $(cat $file); do<br class="title-page-name"/>        arping -c 1 $addr | grep "bytes from" <br class="title-page-name"/>        | cut -d " " -f 5 | cut -d "(" -f 2 | cut -d ")" -f 1 &amp;<br class="title-page-name"/>        done
</pre>
<ol start="11" class="calibre20">
<li class="calibre19" value="11">The only major difference between this script and the preceding one is that rather than supplying an interface name, the filename of the input list is supplied upon the execution of the script. This argument is passed to the <kbd class="calibre16">file</kbd> variable. The <kbd class="calibre16">for</kbd> loop is then used to loop through each value in this file to perform the ARPing task. To execute the script, use a period and forward slash, followed by the name of the executable script:</li>
</ol>
<div class="p"><img class="alignnone61" src="../images/00530.jpeg"/></div>
<ol start="12" class="calibre20">
<li value="12" class="calibre19">Executing the script without any arguments supplied will return the usage of the script. This usage indicates that an input file should be supplied as an argument. When this is done, the script is executed, and a list of live IP addresses is returned from the input list of IP addresses. In the same manner as discussed earlier, the output of this script can easily be redirected to an output file using the greater-than sign. An example of this can be seen as follows:</li>
</ol>
<div class="p"><img class="alignnone62" src="../images/00649.jpeg"/></div>
<ol start="13" class="calibre20">
<li class="calibre19" value="13">Once the output has been redirected to the output file, you can use the <kbd class="calibre16">ls</kbd> command to verify that the file was written to the filesystem, or you can use the <kbd class="calibre16">cat</kbd> command to view the contents of the file.</li>
</ol>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="3L9L61-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works…</h1>
            

            <article>
                
<p class="calibre5">ARPing is a tool that was written with the intention of validating whether a single host is online. However, the simplicity of its use makes it easy to manipulate it in bash to scan multiple hosts in sequence. This is done by looping through a series of IP addresses, which are then supplied to the utility as arguments.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="3M85O1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Using netdiscover to perform host discovery (layer 2)</h1>
            

            <article>
                
<p class="calibre5">The netdiscover tool is a tool that is used to identify network hosts through both active and passive ARP analysis. It was primarily written to be used on a wireless interface; however, it is functional in a switched environment as well. In this specific recipe, we will discuss how to use netdiscover for both active and passive scanning.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="3N6MA1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre5">To use netdiscover to perform ARP discovery, you will need to have at least one system on the LAN that will respond to ARP requests. In the examples provided, a combination of Linux and Windows systems are used. For more information on setting up systems in a local lab environment, refer to the <em class="calibre15">Installing Metasploitable2</em> and <em class="calibre15">Installing Windows Server</em> recipes in <a href="part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426" target="_blank" class="calibre6">Chapter 1</a>, <em class="calibre15">Getting Started</em>.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="3O56S1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it…</h1>
            

            <article>
                
<p class="calibre5">A tool that was specifically designed to perform layer 2 discovery is netdiscover.</p>
<ol class="calibre20">
<li value="1" class="calibre19">The <kbd class="calibre16">netdiscover</kbd> command can be used to scan a range of IP addresses by passing the network range in CIDR notation as an argument while using the <kbd class="calibre16">-r</kbd> option.</li>
</ol>
<div class="p"><img class="image-border47" src="../images/00650.jpeg"/></div>
<ol start="2" class="calibre20">
<li value="2" class="calibre19">The output generates a table that lists live IP addresses, corresponding MAC addresses, the number of responses, the length of responses, and MAC vendor:</li>
</ol>
<div class="p"><img class="image-border47" src="../images/00027.jpeg"/></div>
<ol start="3" class="calibre20">
<li value="3" class="calibre19">The <kbd class="calibre16">netdiscover</kbd> command can also be used to scan IP addresses from an input text file. Instead of passing the CIDR range notation as an argument, the <kbd class="calibre16">-l</kbd> option can be used in conjunction with the name or path of an input file:<br class="title-page-name"/></li>
</ol>
<div class="p"><img class="image-border47" src="../images/00678.jpeg"/></div>
<p class="calibre27">After running the command, we see the results displayed in the Terminal window:</p>
<div class="p"><img class="image-border47" src="../images/00160.jpeg"/></div>
<ol start="4" class="calibre20">
<li value="4" class="calibre19">Another unique feature that sets this tool apart from the others is the capability to perform passive discovery. Broadcasting ARP requests for every IP address in an entire subnet can sometimes trigger alerts or responses from security devices such as <strong class="calibre1">intrusion detection systems</strong> (<strong class="calibre1">IDS</strong>) or <strong class="calibre1">intrusion prevention systems</strong> (<strong class="calibre1">IPS</strong>). A stealthier approach is to listen for the ARP traffic, as the scanning system naturally interacts with other systems on the network, and then record the data collected from ARP responses. This passive scanning technique can be performed using the <kbd class="calibre16">-p</kbd> option:</li>
</ol>
<div class="p"><img class="image-border47" src="../images/00491.jpeg"/></div>
<ol start="5" class="calibre20">
<li value="5" class="calibre19">This technique will be significantly slower in gathering information, as the requests have to come in as a result of normal network interactions, but it will also be unlikely to draw any unwanted attention. This technique is much more effective if it is run on a wireless network, as a promiscuous wireless adapter will receive ARP replies intended for other devices.</li>
<li value="6" class="calibre19">To work effectively in a switched environment, you would need access to SPAN or TAP, or need to overload the CAM tables to force the switch to start broadcasting all traffic.</li>
</ol>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="3P3NE1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works…</h1>
            

            <article>
                
<p class="calibre5">The underlying principle that describes ARP discovery with netdiscover is essentially the same as what we discussed with the previous layer 2 discovery approaches. The major differences between this tool and some of the others that we have discussed include the passive discovery mode and inclusion of the MAC vendor in the output. Passive mode is, in most cases, useless on a switched network, because the receipt of an ARP response will still require some interaction with discovered clients, albeit independent of the netdiscover tool. Nonetheless, it is important to understand this feature and its potential usefulness in a broadcast network such as a hub or wireless network. The netdiscover tool identifies the MAC vendor by evaluating the first half (first three octets <kbd class="calibre16">/24</kbd> bits) of the returned MAC address. This portion of the address identifies the manufacturer of the network interface and is often a good indication of the hardware manufacturer for the rest of the device.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="3Q2801-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Using Metasploit to perform host discovery (layer 2)</h1>
            

            <article>
                
<p class="calibre5">Metasploit is primarily an exploitation tool, and this functionality will be discussed in great length in the upcoming chapters. However, in addition to its primary function, Metasploit also has a number of auxiliary modules that can be used for various scanning and information gathering tasks. One auxiliary module in particular can be used to perform ARP scanning on the local subnet. This is helpful for many, as Metasploit is a tool that most penetration testers are familiar with, and the integration of this function into Metasploit reduces the total number of tools required for the duration of a given test. This specific recipe will demonstrate how to use Metasploit to perform ARP discovery.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="3R0OI1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre5">To use Metasploit to perform ARP discovery, you will need to have at least one system on the LAN that will respond to ARP requests. In the examples provided, a combination of Linux and Windows systems is used. For more information on setting up systems in a local lab environment, refer to the <em class="calibre15">Installing Metasploitable2</em> and <em class="calibre15">Installing Windows Server</em> recipes in <a href="part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426" target="_blank" class="calibre6">Chapter 1</a>, <em class="calibre15">Getting Started</em>.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="3RV941-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it…</h1>
            

            <article>
                
<p class="calibre5">Although often considered an exploitation framework, Metasploit also has a large number of auxiliary modules that can be useful in scanning and information gathering. There is one auxiliary module in particular that can be used to perform layer 2 discovery.</p>
<ol class="calibre20">
<li value="1" class="calibre19">To start the Metasploit framework, use the <kbd class="calibre16">msfconsole</kbd> command. Then, the <kbd class="calibre16">use</kbd> command in conjunction with the desired module can be used to configure the scan:</li>
</ol>
<div class="p"><img class="alignnone63" src="../images/00309.jpeg"/></div>
<ol start="2" class="calibre20">
<li value="2" class="calibre19">Once the module has been selected, you can view the configurable options using the <kbd class="calibre16">show options</kbd> command:</li>
</ol>
<div class="p"><span><img class="alignnone64" src="../images/00054.jpeg"/></span></div>
<ol start="3" class="calibre20">
<li class="calibre19" value="3">These are configuration options that specify information about the targets to be scanned, the scanning system, and scan settings. Most of the information for this particular scan can be collected by examining the interface configurations of the scanning system. Conveniently, system shell commands can be passed while in the Metasploit Framework Console.</li>
<li class="calibre19" value="4">In the following example, a system call is made to execute <kbd class="calibre16">ifconfig</kbd> without ever leaving the Metasploit Framework Console interface:</li>
</ol>
<div class="p"><img class="alignnone60" src="../images/00479.jpeg"/></div>
<ol start="5" class="calibre20">
<li class="calibre19" value="5">The interface to be used for this scan is the <kbd class="calibre16">eth1</kbd> interface. As layer 2 scans are only effective for identifying live hosts on the local subnet, we should look to the scanning system IP and subnet mask to determine the range to scan. In this case, the IP address and subnet mask indicate that we should scan the <kbd class="calibre16">172.16.69.0/24</kbd> range. Additionally, the source IP address and MAC address of the scanning system can be identified in these configurations. To define the configurations in Metasploit, use the <kbd class="calibre16">set</kbd> command, followed by the variable to be defined and then the value that you want to assign it:</li>
</ol>
<div class="p"><img class="alignnone60" src="../images/00500.jpeg"/></div>
<ol start="6" class="calibre20">
<li class="calibre19" value="6">Once the scan configurations have been set, the settings can be reviewed again by using the <kbd class="calibre16">show options</kbd> command. This should now display all the values that were previously set:</li>
</ol>
<div class="p"><img class="alignnone64" src="../images/00094.jpeg"/></div>
<ol start="7" class="calibre20">
<li class="calibre19" value="7">Upon verifying that all the settings are configured correctly, the scan can then be launched using the <kbd class="calibre16">run</kbd> command. This particular module will then print out any live hosts discovered with ARP. It will also indicate the <strong class="calibre1">network interface card</strong> (<strong class="calibre1">NIC</strong>) vendor, as defined by the first 3 bytes in the MAC address of the discovered hosts:</li>
</ol>
<div class="p"><img class="alignnone65" src="../images/00108.jpeg"/></div>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="3STPM1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works…</h1>
            

            <article>
                
<p class="calibre5">The underlying principle for how ARP discovery is performed by Metasploit is once again the same. A series of ARP requests is broadcast, and the ARP responses are recorded and output. The output of the Metasploit auxiliary module provides the IP address of all live systems, and then it also provides the MAC vendor name in parentheses.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="3TSA81-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Using hping3 to perform host discovery (layers 3/4)</h1>
            

            <article>
                
<p class="calibre5">An even more versatile discovery tool that can be used to perform host discovery in multiple different ways is <kbd class="calibre16">hping3</kbd>. It is more powerful than <kbd class="calibre16">fping</kbd> in the sense that it can employ multiple different types of discovery techniques but is less useful as a scanning tool because it can only be used to target a single host. However, this shortcoming can be overcome using bash scripting. This recipe will demonstrate how to use <kbd class="calibre16">hping3</kbd> to perform layer 3 and layer 4 discovery on remote hosts.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="3UQQQ1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre5">Using <kbd class="calibre16">hping3</kbd> to perform layer 3 discovery does not require a lab environment, as many systems on the Internet will reply to ICMP echo requests as well as both TCP and UDP traffic. However, it is highly recommended that you perform any type of network scanning exclusively in your own lab unless you are thoroughly familiar with the legal regulations imposed by any governing authorities to whom you are subject. If you wish to use this technique within your lab, you will need to have at least one system that will respond to ICMP, TCP, and UDP requests. In the examples provided, a combination of Linux and Windows systems are used. For more information on setting up systems in a local lab environment, refer to the <em class="calibre15">Installing Metasploitable2</em> and <em class="calibre15">Installing Windows Server</em> recipes in <a href="part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426" target="_blank" class="calibre6">Chapter 1</a>, <em class="calibre15">Getting Started</em>. Additionally, this section will require a script to be written to the filesystem, using a text editor such as Vim or <span>GNU n</span>ano. For more information on writing scripts, refer to the <em class="calibre15">Using text editors (Vim and <span>GNU n</span>ano)</em> recipe in <a href="part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426" target="_blank" class="calibre6">Chapter 1</a>, <em class="calibre15">Getting Started</em>.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="3VPBC1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it…</h1>
            

            <article>
                
<p class="calibre5">As before, we will look at this layer by layer.  Let's go through the discovery steps layer by layer.  In this layer, we will use hping3 to perform discovery at layers 3 and 4.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section>

            <header id="40NRU2-cf89710d791c4a3bb78ec273d9322426">
                </header><h1 class="header-title" id="calibre_pb_0">Layer 3 discovery - ICMP</h1>
            

            <article>
                
<p class="calibre5">The <kbd class="calibre16">hping3</kbd> command is a very powerful discovery utility that has a large range of options and modes that it can operate in. It is capable of performing discovery in both layer 3 and layer 4.</p>
<ol class="calibre20">
<li value="1" class="calibre19">To perform basic ICMP discovery of a single host address using <kbd class="calibre16">hping3</kbd>, you merely need to pass the IP address to be tested and the desired scanning mode of ICMP to it:</li>
</ol>
<div class="p"><img class="alignnone66" src="../images/00510.jpeg"/></div>
<ol start="2" class="calibre20">
<li value="2" class="calibre19">In the demonstration provided, the process was stopped using <em class="calibre15">Ctrl</em> + <em class="calibre15">C</em>. Similar to the standard <kbd class="calibre16">ping</kbd> utility, the <kbd class="calibre16">hping3</kbd> ICMP mode will continue indefinitely unless a specific number of packets is specified in the initial command. To define the number of attempts to be sent, the <kbd class="calibre16">-c</kbd> option should be included with an integer value that indicates the desired number of attempts:</li>
</ol>
<div class="p"><img class="alignnone66" src="../images/00112.jpeg"/></div>
<ol start="3" class="calibre20">
<li value="3" class="calibre19">Although <kbd class="calibre16">hping3</kbd> does not support the scanning of multiple systems by default, this can easily be scripted out with bash scripting. In order to do this, we must first identify the distinctions between the output associated with a live address and the output associated with a nonresponsive address.</li>
<li value="4" class="calibre19">To do this, we should use the same command on an IP address to which no host is assigned:</li>
</ol>
<div class="p"><img class="alignnone66" src="../images/00145.jpeg"/></div>
<ol start="5" class="calibre20">
<li value="5" class="calibre19">By identifying the responses associated with each of these requests, we can determine a unique string that we can <kbd class="calibre16">grep</kbd> for; this string will isolate the successful ping attempts from the unsuccessful ones. With <kbd class="calibre16">hping3</kbd>, you may notice that the length value is only presented in the case that a response is returned. Based on this, we can extract the successful attempts by grepping for <kbd class="calibre16">len</kbd>.</li>
</ol>
<ol start="6" class="calibre20">
<li value="6" class="calibre19">To determine the effectiveness of this approach in a script, we should attempt to concatenate the two previous commands and then pipe over the output to our <kbd class="calibre16">grep</kbd> function. Assuming that the string we have selected is truly unique to successful attempts, we should only see the output associated with the live host:</li>
</ol>
<div class="p"><img class="alignnone66" src="../images/00514.jpeg"/></div>
<ol start="7" class="calibre20">
<li value="7" class="calibre19">Despite the desired outcome, the <kbd class="calibre16">grep</kbd> function, in this case, does not appear to be effectively applied to the output. As the output display handling in <kbd class="calibre16">hping3</kbd> makes it difficult to pipe over to a <kbd class="calibre16">grep</kbd> function and only extract the desired lines, we can attempt to work around this by other means. Specifically, we will attempt to determine whether the output can be redirected to a file, and then we can <kbd class="calibre16">grep</kbd> directly from the file. To do this, we will attempt to pass the output for both the commands used earlier to the <kbd class="calibre16">handle.txt</kbd> file:</li>
</ol>
<div class="p"><img class="alignnone66" src="../images/00176.jpeg"/></div>
<ol start="8" class="calibre20">
<li value="8" class="calibre19">While this attempt was not completely successful as the output was not totally redirected to the file, we can see by reading the file that enough is output to create an effective script. Specifically, we are able to redirect a unique line that is only associated with successful ping attempts and that contains the corresponding IP address in the line. To verify that this workaround might be possible, we will attempt to loop through each of the addresses in the <kbd class="calibre16">/24</kbd> range and then pass the results to the <kbd class="calibre16">handle.txt</kbd> file:</li>
</ol>
<div class="p"><img class="alignnone67" src="../images/00421.jpeg"/></div>
<p class="calibre27">We can now open the <kbd class="calibre16">handle.txt</kbd> file and see the output of our script:</p>
<div class="p"><img class="alignnone5" src="../images/00496.jpeg"/></div>
<ol start="9" class="calibre20">
<li value="9" class="calibre19">Despite doing this, there is still a large amount of output (the provided output is truncated for convenience) that consists of all the parts of the output that were not redirected to the file. However, the success of the following script is not contingent upon the excessive output of this initial loop, but rather on the ability to extract the necessary information from the output file:</li>
</ol>
<div class="p"><img class="image-border47" src="../images/00563.jpeg"/></div>
<ol start="10" class="calibre20">
<li value="10" class="calibre19">After completing the scan loop, the output file can be identified in the current directory using the <kbd class="calibre16">ls</kbd> command, and then the unique string of <kbd class="calibre16">len</kbd> can be grepped directly from this file. Here in the output, we can see that each of our live hosts is listed. At this point, the only remaining task is to extract the IP addresses from this output and then recreate this entire process as a single functional script. Have a look at the following set of commands:</li>
</ol>
<div class="p"><img class="alignnone5" src="../images/00625.jpeg"/></div>
<ol start="11" class="calibre20">
<li value="11" class="calibre19">By piping over the output to a series of <kbd class="calibre16">cut</kbd> functions, we can extract the IP addresses from the output. Now that we have successfully identified a way to scan multiple hosts and easily identify the results, we should integrate it into a script. An example of a functional script that would tie all of these operations together is as follows:</li>
</ol>
<pre class="calibre24">
        #!/bin/bash<br class="title-page-name"/><br class="title-page-name"/>        if [ "$#" -ne 1 ]; then<br class="title-page-name"/>        echo "Usage - ./ping_sweep.sh [/24 network address]"<br class="title-page-name"/>        echo "Example - ./ping_sweep.sh 172.16.36.0"<br class="title-page-name"/>        echo "Example will perform an ICMP ping sweep of the<br class="title-page-name"/>          172.16.36.0/24 network and output to an output.txt file"<br class="title-page-name"/>        exit<br class="title-page-name"/>        fi<br class="title-page-name"/><br class="title-page-name"/>        prefix=$(echo $1 | cut -d '.' -f 1-3)<br class="title-page-name"/><br class="title-page-name"/>        for addr in $(seq 1 254); do<br class="title-page-name"/>        hping3 $prefix.$addr --icmp -c 1 &gt;&gt; handle.txt;<br class="title-page-name"/>        done<br class="title-page-name"/><br class="title-page-name"/>        grep len handle.txt | cut -d " " -f 2 <br class="title-page-name"/>        | cut -d "=" -f 2 &gt;&gt; output.txt<br class="title-page-name"/>        rm handle.txt
</pre>
<div class="calibre31">
<ul class="calibre18">
<li class="calibre19">In the bash script that is provided, the first line defines the location of the bash interpreter. The block of code that follows performs a test to determine whether the one argument that was expected was supplied. This is determined by evaluating whether the number of supplied arguments is not equal to <kbd class="calibre16">1</kbd>. If the expected argument is not supplied, the usage of the script is output, and the script exits. The usage output indicates that the script is expecting the <kbd class="calibre16">/24</kbd> network address as an argument.</li>
<li class="calibre19">The next line of code extracts the network prefix from the supplied network address. For example, if the network address supplied was <kbd class="calibre16">192.168.11.0</kbd>, the prefix variable would be assigned the value <kbd class="calibre16">192.168.11</kbd>. The <kbd class="calibre16">hping3</kbd> operation is then performed on each address within the <kbd class="calibre16">/24</kbd> range, and the resulting output of each task is placed into the <kbd class="calibre16">handle.txt</kbd> file.</li>
<li class="calibre19">Once completed, <kbd class="calibre16">grep</kbd> is used to extract the lines that are associated with live host responses from the <kbd class="calibre16">handle.txt</kbd> file and then extract the IP addresses from those lines. The resulting IP addresses are then passed into an <kbd class="calibre16">output.txt</kbd> file, and the temporary <kbd class="calibre16">handle.txt</kbd> file is removed from the directory.</li>
</ul>
</div>
<ol start="12" class="calibre20">
<li value="12" class="calibre19">This script can be executed using a period and forward slash, followed by the name of the executable script:</li>
</ol>
<div class="p"><img class="alignnone29" src="../images/00673.jpeg"/></div>
<ol start="13" class="calibre20">
<li value="13" class="calibre19">Once completed, the script should return an <kbd class="calibre16">output.txt</kbd> file to the execution directory. This can be verified using <kbd class="calibre16">ls</kbd>, and the <kbd class="calibre16">cat</kbd> command can be used to view the contents of this file:</li>
</ol>
<div class="p"><img class="alignnone68" src="../images/00267.jpeg"/></div>
<ol start="14" class="calibre20">
<li value="14" class="calibre19">When the script is run, you will still see the same large amount of output that was seen when originally looping through the task. Fortunately, your list of discovered hosts will not be lost in this output, as it is conveniently written to your output file each time.</li>
</ol>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section>

            <header id="41MCG2-cf89710d791c4a3bb78ec273d9322426">
                </header><h1 class="header-title" id="calibre_pb_0">Layer 4 discovery - TCP and UDP</h1>
            

            <article>
                
<p class="calibre5">Unlike Nmap, <kbd class="calibre16">hping3</kbd> makes it very easy to identify hosts that are discovered by UDP probes by isolating the task.</p>
<ol class="calibre20">
<li value="1" class="calibre19">By specifying the UDP mode with the <kbd class="calibre16">--udp</kbd> option, UDP probes can be transmitted in attempts to trigger replies from live hosts:</li>
</ol>
<div class="p"><img class="alignnone69" src="../images/00533.jpeg"/></div>
<ol start="2" class="calibre20">
<li value="2" class="calibre19">In the demonstration provided, the process was stopped using <em class="calibre15">Ctrl</em> + <em class="calibre15">C</em>. When using <kbd class="calibre16">hping3</kbd> in UDP mode, discovery will continue indefinitely unless a specific number of packets is defined in the initial command. To define the number of attempts to be sent, the <kbd class="calibre16">-c</kbd> option should be included with an integer value that indicates the desired number of attempts:</li>
</ol>
<div class="p"><img class="alignnone70" src="../images/00295.jpeg"/></div>
<ol start="3" class="calibre20">
<li value="3" class="calibre19">Although <kbd class="calibre16">hping3</kbd> does not support the scanning of multiple systems by default, using bash scripting we can filter our results to show only live addresses. In order to do this, we must first identify the distinctions between the output associated with a live address and the output associated with a nonresponsive address. To do this, we should use the same command on an IP address to which no host is assigned:</li>
</ol>
<div class="p"><img class="alignnone71" src="../images/00308.jpeg"/></div>
<ol start="4" class="calibre20">
<li value="4" class="calibre19">By identifying the responses associated with each of these requests, we can determine a unique string that we can <kbd class="calibre16">grep</kbd>; this string will isolate the successful discovery attempts from the unsuccessful ones. In the previous requests, you may have noticed that the phrase <kbd class="calibre16">ICMP Port Unreachable</kbd> is only presented in the case that a response is returned. Based on this, we can extract the successful attempts by grepping for <kbd class="calibre16">Unreachable</kbd>.</li>
<li value="5" class="calibre19">To determine the effectiveness of this approach in a script, we should attempt to concatenate the two previous commands and then pipe over the output to our <kbd class="calibre16">grep</kbd> function. Assuming that the string we have selected is truly unique to successful attempts, we should only see the output associated with the live host:</li>
</ol>
<div class="p"><img class="alignnone72" src="../images/00537.jpeg"/></div>
<ol start="6" class="calibre20">
<li value="6" class="calibre19">Despite the desired outcome, the <kbd class="calibre16">grep</kbd> function, in this case, does not appear to be effectively applied to the output. As the output display handling in <kbd class="calibre16">hping3</kbd> makes it difficult to pipe over to a <kbd class="calibre16">grep</kbd> function and only extract the desired lines, we can attempt to work around this by other means. Specifically, we will attempt to determine whether the output can be redirected to a file, and then we can grep directly from the file. To do this, we will attempt to pass the output for both the commands used earlier to the <kbd class="calibre16">handle.txt</kbd> file:</li>
</ol>
<div class="p"><img class="alignnone73" src="../images/00445.jpeg"/></div>
<ol start="7" class="calibre20">
<li value="7" class="calibre19">While this attempt was not completely successful as the output was not totally redirected to the file, we can see by reading the file that enough is output to create an effective script. Specifically, we are able to redirect a unique line that is only associated with successful ping attempts and that contains the corresponding IP address in the line. To check whether this workaround is possible, we will attempt to loop through each of the addresses in the <kbd class="calibre16">/24</kbd> range and then pass the results to the <kbd class="calibre16">handle.txt</kbd> file:</li>
</ol>
<div class="p"><img class="alignnone74" src="../images/00349.jpeg"/></div>
<p class="calibre27">We can now view the results by viewing the contents of <kbd class="calibre16">handle.txt</kbd>:</p>
<div class="p"><img class="alignnone73" src="../images/00352.jpeg"/></div>
<ol start="8" class="calibre20">
<li value="8" class="calibre19">By doing this, there is still a large amount of output (the provided output is truncated for convenience) that consists of all the parts of output that were not redirected to the file. However, the success of the script is not contingent upon the excessive output of this initial loop, but rather on the ability to extract the necessary information from the output file. This can be seen in the following commands:</li>
</ol>
<div class="p"><img class="alignnone32" src="../images/00041.jpeg"/></div>
<ol start="9" class="calibre20">
<li value="9" class="calibre19">After completing the scan loop, the output file can be identified in the current directory using the <kbd class="calibre16">ls</kbd> command, and then the unique string of <kbd class="calibre16">Unreachable</kbd> can be grepped directly from this file, as shown in the next command. Here, in the output, we can see that each of our live hosts discovered by UDP probing is listed. At this point, the only remaining task is to extract the IP addresses from this output and then recreate this entire process as a single functional script:</li>
</ol>
<div class="p"><img class="alignnone75" src="../images/00359.jpeg"/></div>
<ol start="10" class="calibre20">
<li value="10" class="calibre19">By piping over the output to a series of <kbd class="calibre16">cut</kbd> functions, we can extract the IP addresses from the output. Now that we have successfully identified a way to scan multiple hosts and easily identify the results, we should integrate it into a script:</li>
</ol>
<pre class="calibre24">
        #!/bin/bash<br class="title-page-name"/><br class="title-page-name"/>        if [ "$#" -ne 1 ]; then<br class="title-page-name"/>        echo "Usage - ./udp_sweep.sh [/24 network address]"<br class="title-page-name"/>        echo "Example - ./udp_sweep.sh 172.16.36.0"<br class="title-page-name"/>        echo "Example will perform a UDP ping sweep of the                       172.16.36.0/24 network and output to an output.txt file"<br class="title-page-name"/>        exit<br class="title-page-name"/>        fi<br class="title-page-name"/><br class="title-page-name"/>        prefix=$(echo $1 | cut -d '.' -f 1-3)<br class="title-page-name"/><br class="title-page-name"/>        for addr in $(seq 1 254); do<br class="title-page-name"/>        hping3 $prefix.$addr --udp -c 1 &gt;&gt; handle.txt;<br class="title-page-name"/>        done<br class="title-page-name"/><br class="title-page-name"/>        grep Unreachable handle.txt | cut -d " " -f 5 | cut -d "="<br class="title-page-name"/>         -f 2 &gt;&gt; output.txt<br class="title-page-name"/>        rm handle.txt
</pre>
<div class="calibre31">
<ul class="calibre18">
<li class="calibre19">In the bash script that is provided, the first line defines the location of the bash interpreter. The block of code that follows performs a test to determine whether the one argument that was expected was supplied. This is determined by evaluating whether the number of supplied arguments is not equal to <kbd class="calibre16">1</kbd>. If the expected argument is not supplied, the usage of the script is output, and the script exits. The usage output indicates that the script is expecting the <kbd class="calibre16">/24</kbd> network address as an argument.</li>
<li class="calibre19">The next line of code extracts the network prefix from the supplied network address. For example, if the network address supplied was <kbd class="calibre16">192.168.11.0</kbd>, the prefix variable would be assigned a value of <kbd class="calibre16">192.168.11</kbd>. The <kbd class="calibre16">hping3</kbd> operation is performed on each address within the <kbd class="calibre16">/24</kbd> range, and the resulting output of each task is placed into the <kbd class="calibre16">handle.txt</kbd> file.</li>
<li class="calibre19">Once this is complete, <kbd class="calibre16">grep</kbd> is used to extract the lines that are associated with live host responses from the <kbd class="calibre16">handle.txt</kbd> file and then extract the IP addresses from those lines.</li>
</ul>
</div>
<ol start="11" class="calibre20">
<li value="11" class="calibre19">The resulting IP addresses are then passed into an <kbd class="calibre16">output.txt</kbd> file, and the temporary <kbd class="calibre16">handle.txt</kbd> file is removed from the directory:</li>
</ol>
<div class="p"><img class="alignnone75" src="../images/00363.jpeg"/></div>
<p class="calibre27">We can now view the contents of our <kbd class="calibre16">output.txt</kbd> file:</p>
<div class="p"><img class="alignnone76" src="../images/00365.jpeg"/></div>
<ol start="12" class="calibre20">
<li value="12" class="calibre19">When the script is run, you will still see the same large amount of output that was seen when originally looping through the task. Fortunately, your list of discovered hosts will not be lost in this output, as it is conveniently written to your output file each time. You can also use <kbd class="calibre16">hping3</kbd> to perform TCP discovery. TCP mode is actually the default discovery mode used by <kbd class="calibre16">hping3</kbd>, and this mode can be used by just passing the IP address to be scanned to <kbd class="calibre16">hping3</kbd>:</li>
</ol>
<div class="p"><img class="alignnone77" src="../images/00369.jpeg"/></div>
<ol start="13" class="calibre20">
<li value="13" class="calibre19">In the same way that we created a bash script to cycle through a <kbd class="calibre16">/24</kbd> network and perform UDP discovery using <kbd class="calibre16">hping3</kbd>, we can create a similar script for TCP discovery. First, a unique phrase that exists in the output associated with a live host but not in the output associated with a nonresponsive host must be identified. To do this, we must evaluate the response for each:</li>
</ol>
<div class="p"><img class="alignnone77" src="../images/00372.jpeg"/></div>
<ol start="14" class="calibre20">
<li value="14" class="calibre19">In this case, the length value is only present in the output associated with a live host. Once again, we can develop a script that redirects the output to a temporary <kbd class="calibre16">handle.txt</kbd> file and then greps the output from this file to identify live hosts:</li>
</ol>
<pre class="calibre24">
        #!/bin/bash<br class="title-page-name"/><br class="title-page-name"/>        if [ "$#" -ne 1 ]; then<br class="title-page-name"/>        echo "Usage - ./tcp_sweep.sh [/24 network address]"<br class="title-page-name"/>        echo "Example - ./tcp_sweep.sh 172.16.36.0"<br class="title-page-name"/>        echo "Example will perform a tcp ping sweep of the                       172.16.36.0/24 network and output to an output.txt file"<br class="title-page-name"/>        exit<br class="title-page-name"/>        fi<br class="title-page-name"/><br class="title-page-name"/>        prefix=$(echo $1 | cut -d '.' -f 1-3)<br class="title-page-name"/><br class="title-page-name"/>        for addr in $(seq 1 254); do<br class="title-page-name"/>        hping3 $prefix.$addr -c 1 &gt;&gt; handle.txt;<br class="title-page-name"/>        done<br class="title-page-name"/><br class="title-page-name"/>        grep len handle.txt | cut -d " " -f 2 <br class="title-page-name"/>        | cut -d "=" -f 2 &gt;&gt; output.txt<br class="title-page-name"/>        rm handle.txt
</pre>
<ol start="15" class="calibre20">
<li value="15" class="calibre19">This script will perform in a way similar to the one developed for UDP discovery. The only differences are in the command performed in the loop sequence, grep value, and the process to extract the IP address. Once run, this script will produce an <kbd class="calibre16">output.txt</kbd> file that will contain a list of the IP addresses associated with the hosts discovered by TCP discovery:</li>
</ol>
<div class="p"><img class="alignnone78" src="../images/00125.jpeg"/></div>
<ol start="16" class="calibre20">
<li value="16" class="calibre19">You can confirm that the output file was written to the execution directory using the <kbd class="calibre16">ls</kbd> command and read its contents using the <kbd class="calibre16">cat</kbd> command. This can be seen in the following example:</li>
</ol>
<div class="p"><img class="alignnone79" src="../images/00379.jpeg"/></div>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="42KT21-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works…</h1>
            

            <article>
                
<p class="calibre5">To effectively use <kbd class="calibre16">hping3</kbd> for layer 3 discovery, a bash script was used to perform an ICMP echo request in sequence. This was possible due to the unique response that was generated by a successful and unsuccessful request. By passing the function through a loop and then grepping for the unique response, we could effectively develop a script that performs ICMP discovery against multiple systems in sequence and then outputs a list of live hosts.</p>
<p class="calibre5">For layer 4 discovery, <kbd class="calibre16">hping3</kbd> uses ICMP host-unreachable responses to identify live hosts with UDP requests and uses null-flag scanning to identify live hosts with TCP requests. For UDP discovery, a series of null UDP requests is sent to arbitrary destination ports in an attempt to solicit a response. For TCP discovery, a series of TCP requests is sent to destination port <kbd class="calibre16">0</kbd> with no flag bits activated. In the example provided, this solicited a response with the ACK+RST flags activated. Each of these tasks was passed through a loop in bash to perform scanning on multiple hosts or a range of addresses.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="43JDK1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Using ICMP to perform host discovery</h1>
            

            <article>
                
<p class="calibre5">Layer 3 discovery is probably the most commonly used tool among network administrators and technicians. It uses the famous ICMP <kbd class="calibre16">ping</kbd> utility to identify live hosts. This recipe will demonstrate how to use the <kbd class="calibre16">ping</kbd> utility to perform layer 3 discovery on remote hosts.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="44HU61-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre5">Using <kbd class="calibre16">ping</kbd> to perform layer 3 discovery does not require a lab environment, as many systems on the Internet will reply to ICMP echo requests. However, it is highly recommended you perform any type of network scanning exclusively in your own lab unless you are thoroughly familiar with the legal regulations imposed by any governing authorities to whom you are subject. If you wish to use this technique within your lab, you will need to have at least one system that will respond to ICMP requests. In the examples provided, a combination of Linux and Windows systems is used. For more information on setting up systems in a local lab environment, refer to the <em class="calibre15">Installing Metasploitable2</em> and <em class="calibre15">Installing Windows Server</em> recipes in <a href="part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426" target="_blank" class="calibre6">Chapter 1</a>, <em class="calibre15">Getting Started</em>. Additionally, this section will require a script to be written to the filesystem, using a text editor such as Vim or <span>GNU n</span>ano. For more information on writing scripts, refer to the <em class="calibre15">Using text editors (Vim and <span>GNU n</span>ano)</em> recipe in <a href="part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426" target="_blank" class="calibre6">Chapter 1</a>, <em class="calibre15">Getting Started</em>.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section>

            <header id="45GEO2-cf89710d791c4a3bb78ec273d9322426">
                </header><h1 class="header-title" id="calibre_pb_0">How to do it…</h1>
            

            <article>
                
<ol class="calibre20">
<li value="1" class="calibre19">Most people who work in the IT industry are fairly familiar with the <kbd class="calibre16">ping</kbd> tool. To determine whether a host is alive using <kbd class="calibre16">ping</kbd>, you merely need to pass an argument to the command to define the IP address that you wish to test:</li>
</ol>
<div class="p"><img class="alignnone80" src="../images/00382.jpeg"/></div>
<ol start="2" class="calibre20">
<li value="2" class="calibre19">When this command is issued, an ICMP echo request will be sent directly to the IP address provided. Several conditions must be true in order to receive a reply to this ICMP echo request. These conditions are as follows:
<ul class="calibre30">
<li class="calibre19">The IP address tested must be assigned to a system</li>
<li class="calibre19">The system must be alive and online</li>
<li class="calibre19">There must be an available route from the scanning system to the target IP</li>
<li class="calibre19">The system must be configured to respond to ICMP traffic</li>
<li class="calibre19">There should not be any host-based or network firewall between the scanning system and the target IP that is configured to drop ICMP traffic</li>
</ul>
</li>
<li value="3" class="calibre19">As you can see, there are a lot of variables that have to be factored into the success of ICMP discovery. It is for this reason that ICMP can be somewhat unreliable, but unlike ARP, it is a routable protocol and can be used to discover hosts outside of the LAN. Notice that in the previous example, <kbd class="calibre16">^C</kbd> appears in the output presented from the <kbd class="calibre16">ping</kbd> command. This signifies that an escape sequence (specifically, <em class="calibre15">Ctrl</em> + <em class="calibre15">C</em>) was used to stop the process. Unlike Windows, the <kbd class="calibre16">ping</kbd> command integrated into Linux operating systems will, by default, ping a target host indefinitely.</li>
</ol>
<ol start="4" class="calibre20">
<li value="4" class="calibre19">However, the <kbd class="calibre16">-c</kbd> option can be used to specify the number of ICMP requests to be sent. Using this option, the process will end gracefully once the timeout has been reached or replies have been received for each sent packet. Have a look at the following command:</li>
</ol>
<div class="p"><img class="alignnone81" src="../images/00384.jpeg"/></div>
<ol start="5" class="calibre20">
<li value="5" class="calibre19">In the same way that ARPing can be used in a bash script to cycle through multiple IPs in parallel, <kbd class="calibre16">ping</kbd> can be used in conjunction with bash scripting to perform layer 3 discovery on multiple hosts in parallel. To write a script, we need to identify the varied responses associated with a successful and failed ping request. To do this, we should first ping a host that we know to be alive and responding to ICMP, and then follow it up with a ping request to a nonresponsive address. The following command demonstrates this:</li>
</ol>
<div class="p"><img class="alignnone80" src="../images/00388.jpeg"/></div>
<ol start="6" class="calibre20">
<li value="6" class="calibre19">As with the ARPing requests, the bytes from a unique string are only present in the output associated with live IP addresses, and they are also on a line that contains this address. In the same fashion, we can extract the IP address from any successful ping request using a combination of <kbd class="calibre16">grep</kbd> and <kbd class="calibre16">cut</kbd>:</li>
</ol>
<div class="p"><img class="alignnone79" src="../images/00198.jpeg"/></div>
<ol start="7" class="calibre20">
<li value="7" class="calibre19">By employing this task sequence in a loop that contains a range of target IP addresses, we can quickly identify live hosts that respond to ICMP echo requests. The output is a simple list of live IP addresses. An example script that uses this technique can be seen here:</li>
</ol>
<pre class="calibre24">
        #!/bin/bash<br class="title-page-name"/><br class="title-page-name"/>        if [ "$#" -ne 1 ]; then<br class="title-page-name"/>        echo "Usage - ./ping_sweep.sh [/24 network address]"<br class="title-page-name"/>        echo "Example - ./ping_sweep.sh 172.16.36.0"<br class="title-page-name"/>        echo " Example will perform an ICMP ping sweep of the <br class="title-page-name"/>          172.16.36.0/24 network and output to an output.txt file"<br class="title-page-name"/>        exit<br class="title-page-name"/>        fi<br class="title-page-name"/><br class="title-page-name"/>        prefix=$(echo $1 | cut -d '.' -f 1-3)<br class="title-page-name"/><br class="title-page-name"/>        for addr in $(seq 1 254); do<br class="title-page-name"/>        ping -c 1 $prefix.$addr | grep "bytes from" <br class="title-page-name"/>        | cut -d " " -f 4 | cut -d ":" -f 1 &amp;<br class="title-page-name"/>        done
</pre>
<div class="calibre31">
<ul class="calibre18">
<li class="calibre19">In the provided bash script, the first line defines the location of the bash interpreter. The block of code that follows performs a test to determine whether the one argument that was expected was supplied. This is determined by evaluating whether the number of supplied arguments is not equal to <kbd class="calibre16">1</kbd>. If the expected argument is not supplied, the usage of the script is output, and the script exits. The usage output indicates that the script is expecting the <kbd class="calibre16">/24</kbd> network address as an argument.</li>
<li class="calibre19">The next line of code extracts the network prefix from the supplied network address. For example, if the network address supplied was <kbd class="calibre16">192.168.11.0</kbd>, the prefix variable would be assigned <kbd class="calibre16">192.168.11</kbd>. A <kbd class="calibre16">for</kbd> loop is then used to cycle through the values of the last octet to generate each possible IP address in the local <kbd class="calibre16">/24</kbd> network. For each possible IP address, a single <kbd class="calibre16">ping</kbd> command is issued. The response for each of these requests is then piped over, and then <kbd class="calibre16">grep</kbd> is used to extract lines with the <kbd class="calibre16">bytes from</kbd> phrase. This will only extract lines that include the IP addresses of live hosts.</li>
<li class="calibre19">Finally, a series of <kbd class="calibre16">cut</kbd> functions is used to extract the IP address from that output. Notice that an ampersand is used at the end of the <kbd class="calibre16">for</kbd> loop task instead of a semicolon. The ampersand allows the tasks to be performed in parallel instead of in sequence. This drastically reduces the amount of time required to scan the IP range.</li>
</ul>
</div>
<ol start="8" class="calibre20">
<li value="8" class="calibre19">The script can then be executed with a period and forward slash, followed by the name of the executable script:</li>
</ol>
<div class="p"><img class="alignnone82" src="../images/00212.jpeg"/></div>
<ol start="9" class="calibre20">
<li value="9" class="calibre19">When executed without any arguments supplied, the script returns the usage. However, when executed with a network address value, the task sequence begins, and a list of live IP addresses is returned. As discussed in the previous scripts, the output of this script can also be redirected to a text file for later use. This can be done with a greater-than sign followed by the name of the output file.</li>
</ol>
<p class="calibre5"><img class="alignnone83" src="../images/00227.jpeg"/></p>
<ol start="10" class="calibre20">
<li value="10" class="calibre19">In the example provided, the <kbd class="calibre16">ls</kbd> command is used to confirm that the output file was created. The contents of this output file can be viewed by passing the filename as an argument to the <kbd class="calibre16">cat</kbd> command.</li>
</ol>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="46EVA1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works…</h1>
            

            <article>
                
<p class="calibre5">Ping is a well-known utility in the IT industry, and its existing functionality is already to identify live hosts. However, it was built with the intention of discovering whether a single host is alive and not as a scanning tool. The bash script in this recipe essentially does the same thing as using <kbd class="calibre16">ping</kbd> on every possible IP address in a <kbd class="calibre16">/24</kbd> CIDR range. However, rather than doing this tedious task manually, bash allows us to quickly and easily perform this task by passing the task sequence through a loop.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="47DFS1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Using fping to perform host discovery</h1>
            

            <article>
                
<p class="calibre5">A tool that is very similar to the well-known <kbd class="calibre16">ping</kbd> utility is <kbd class="calibre16">fping.</kbd> However, it is also built with a number of additional features that are not present in <kbd class="calibre16">ping</kbd>. These additional features allow <kbd class="calibre16">fping</kbd> to be used as a functional scan tool, without additional modification. This recipe will demonstrate how to use <kbd class="calibre16">fping</kbd> to perform layer 3 discovery on remote hosts.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="48C0E1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre5">Using <kbd class="calibre16">fping</kbd> to perform layer 3 discovery does not require a lab environment, as many systems on the Internet will reply to ICMP echo requests. However, it is highly recommended that you perform any type of network scanning exclusively in your own lab unless you are thoroughly familiar with the legal regulations imposed by any governing authorities to whom you are subject. If you wish to use this technique within your lab, you will need to have at least one system that will respond to ICMP requests. In the examples provided, a combination of Linux and Windows systems is used. For more information on setting up systems in a local lab environment, refer to the the <em class="calibre15">Installing Metasploitable2</em> and <em class="calibre15">Installing Windows Server</em> recipes in <a href="part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426" target="_blank" class="calibre6">Chapter 1</a>, <em class="calibre15">Getting Started</em>.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="49AH01-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it…</h1>
            

            <article>
                
<p class="calibre5">The <kbd class="calibre16">fping</kbd> command is very similar to the <kbd class="calibre16">ping</kbd> utility with a few extras added on. It can be used in the same way that <kbd class="calibre16">ping</kbd> can be used to send an ICMP echo request to a single target to determine whether it is alive.</p>
<ol class="calibre20">
<li value="1" class="calibre19">This is done by simply passing the IP address as an argument to the <kbd class="calibre16">fping</kbd> utility:</li>
</ol>
<div class="p"><img class="image-border47" src="../images/00400.jpeg"/></div>
<ol start="2" class="calibre20">
<li value="2" class="calibre19">Unlike the standard <kbd class="calibre16">ping</kbd> utility, <kbd class="calibre16">fping</kbd> will stop sending ICMP echo requests after it receives a single reply. Upon receiving a reply, it will indicate that the host corresponding to this address is alive. Alternatively, if a response is not received from the address, <kbd class="calibre16">fping</kbd> will, by default, make four attempts to contact the system prior to determining that the host is unreachable:</li>
</ol>
<div class="p"><img class="alignnone79" src="../images/00254.jpeg"/></div>
<ol start="3" class="calibre20">
<li value="3" class="calibre19">This default number of connection attempts can be modified using the <kbd class="calibre16">-c</kbd> (count) option and supplying an integer value to it that defines the number of attempts to be made:</li>
</ol>
<div class="p"><img class="alignnone84" src="../images/00269.jpeg"/></div>
<ol start="4" class="calibre20">
<li value="4" class="calibre19">When executed in this fashion, the output is slightly more cryptic but can be understood with careful analysis. The output for any host includes the IP address, the number of attempts made (<kbd class="calibre16">xmt</kbd>), the number of replies received (<kbd class="calibre16">rcv</kbd>), and the percentage of loss (<kbd class="calibre16">%loss</kbd>).</li>
<li value="5" class="calibre19">In the example provided, the first address was discovered to be online. This is evidenced by the fact that the number of bytes received and the latency of reply are both returned. You can also easily determine whether there is a live host associated with the provided IP address by examining the percentage loss. If the percentage loss is 100, no replies have been received. Unlike <kbd class="calibre16">ping</kbd>—which is most commonly used as a troubleshooting utility—<kbd class="calibre16">fping</kbd> was built with the integrated capability to scan multiple hosts.</li>
</ol>
<ol start="6" class="calibre20">
<li value="6" class="calibre19">A sequential series of hosts can be scanned with <kbd class="calibre16">fping,</kbd> using the <kbd class="calibre16">-g</kbd> option to dynamically generate a list of IP addresses. To specify a range to scan, pass this argument to both the first and last IP address in the desired sequential range:</li>
</ol>
<div class="p"><img class="alignnone78" src="../images/00282.jpeg"/></div>
<ol start="7" class="calibre20">
<li value="7" class="calibre19">The generate list option can also be used to generate a list based on the CIDR range notation. In the same way, <kbd class="calibre16">fping</kbd> will cycle through this dynamically generated list and scan each address:</li>
</ol>
<div class="p"><img class="alignnone78" src="../images/00415.jpeg"/></div>
<ol start="8" class="calibre20">
<li value="8" class="calibre19">Finally, <kbd class="calibre16">fping</kbd> can also be used to scan a series of addresses as specified by the contents of an input text file. To use an input file, use the <kbd class="calibre16">-f</kbd> (file) option and then supply the filename or path of the input file: </li>
</ol>
<div class="p"><img class="alignnone77" src="../images/00417.jpeg"/></div>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="4A91I1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works…</h1>
            

            <article>
                
<p class="calibre5">The <kbd class="calibre16">fping</kbd> tool performs ICMP discovery in the same manner as other tools that we discussed earlier. For each IP address, <kbd class="calibre16">fping</kbd> transmits one or more ICMP echo requests, and the received responses are then evaluated to identify live hosts. <kbd class="calibre16">fping</kbd> can also be used to scan a range of systems or an input list of IP addresses by supplying the appropriate arguments. As such, we do not have to manipulate the tool with bash scripting in the same way that was done with <kbd class="calibre16">ping</kbd> to make it an effective scanning tool.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    </body></html>