<html><head></head><body>
        <section id="7J5VE1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Vulnerability Scanning</h1>
            

            <article>
                
<p class="calibre5">This chapter contains the following recipes for performing automated vulnerability scanning:</p>
<ul class="calibre18">
<li class="calibre19">Vulnerability scanning with the Nmap Scripting Engine</li>
<li class="calibre19">Vulnerability scanning with MSF auxiliary modules</li>
<li class="calibre19">Creating scan policies with Nessus</li>
<li class="calibre19">Vulnerability scanning with Nessus</li>
<li class="calibre19">Vulnerability scanning with OpenVAS</li>
<li class="calibre19">Validating vulnerabilities with HTTP interaction</li>
<li class="calibre19">Validating vulnerabilities with ICMP interaction</li>
</ul>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="7K4G01-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Introduction</h1>
            

            <article>
                
<p class="calibre5">While it is possible to identify many potential vulnerabilities by reviewing the results of service fingerprinting and researching exploits associated with identified versions, this can often take an extraordinarily large amount of time. There are more streamlined alternatives that can usually accomplish a large part of this work for you. These alternatives include the use of automated scripts and programs that can identify vulnerabilities by scanning remote systems. Unauthenticated vulnerability scanners work by sending a series of distinct probes to services in attempt to solicit responses that indicate that a vulnerability exists. Alternatively, authenticated vulnerability scanners will directly query the remote system using the credentials provided for information regarding installed applications, running services, filesystem, and registry contents.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="7L30I1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Vulnerability scanning with the Nmap Scripting Engine</h1>
            

            <article>
                
<p class="calibre5">The <strong class="calibre1">Nmap Scripting Engine (NSE)</strong> provides a large number of scripts that can be used to perform a range of automated tasks to evaluate remote systems. The existing NSE scripts that can be found in Kali are classified into a number of different categories, one of which is vulnerability identification.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="7M1H41-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre5">To perform vulnerability analysis with NSE, you will need to have a system that is running network services over TCP or UDP. In the example provided, a Windows XP system with a vulnerable SMB service is used for this task. For more information on setting up a Windows system, refer to the <em class="calibre15">Installing Windows Server</em> recipe in <a href="part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426" class="calibre6">Chapter 1</a>, <em class="calibre15">Getting Started</em>.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section>

            <header id="7N01M2-cf89710d791c4a3bb78ec273d9322426">
                </header><h1 class="header-title" id="calibre_pb_0">How to do it…</h1>
            

            <article>
                
<p class="calibre5">To get all the <span>vulnerability information with the Nmap Scripting Engine, perform the following steps:</span></p>
<ol class="calibre20">
<li value="1" class="calibre19">There are a number of different ways in which one can identify the functions associated with any given NSE script. One of the most effective ways is to reference the <kbd class="calibre16">script.db</kbd> file that is located in the Nmap script directory. To see the contents of the file, we can use the <kbd class="calibre16">cat</kbd> command, as follows:</li>
</ol>
<div class="p"><img class="alignnone150" src="../images/00093.jpeg"/></div>
<ol start="2" class="calibre20">
<li value="2" class="calibre19">This <kbd class="calibre16">script.db</kbd> file is a very simple index that shows each NSE script's filename and the categories it falls into. These categories are standardized and make it easy to grep for specific types of script. The category name for vulnerability scanning scripts is <kbd class="calibre16">vuln</kbd>. To identify all vulnerability scripts, one would need to grep for the <kbd class="calibre16">vuln</kbd> term and then extract the filename for each script with the <kbd class="calibre16">cut</kbd> command. This can be seen in the following truncated output:</li>
</ol>
<div class="p"><img class="alignnone151" src="../images/00467.jpeg"/></div>
<ol start="3" class="calibre20">
<li value="3" class="calibre19">To further evaluate the use of any given script in the preceding list, one can use the <kbd class="calibre16">cat</kbd> command to read the <kbd class="calibre16">.nse</kbd> file that is contained within the same directory as the <kbd class="calibre16">script.db</kbd> file. Because most of the descriptive content is generally at the beginning of the file, it is recommended that you pipe the content over to the <kbd class="calibre16">more</kbd> utility so that the file can be read from top to bottom, as follows:</li>
</ol>
<div class="p"><img class="alignnone152" src="../images/00535.jpeg"/></div>
<ol start="4" class="calibre20">
<li value="4" class="calibre19">In the example provided, we can see that the <kbd class="calibre16">smb-vuln-ms10-054.nse</kbd> script checks for a remote memory corruption vulnerability associated with the SMB service. Here, one can find a description of the vulnerability and references to the <strong class="calibre1">Common Vulnerabilities and Exposures</strong> (<strong class="calibre1">CVE</strong>) number that can be queried online for additional information. By reading further, one can learn even more about the script, as follows:</li>
</ol>
<div class="p"><img class="alignnone153" src="../images/00600.jpeg"/></div>
<ol start="5" class="calibre20">
<li value="5" class="calibre19">By reading further down, we can find details on script-specific arguments, appropriate usages, and an example of the expected script output. It is important to take note of the fact that there is an unsafe argument that can be set to the value of <kbd class="calibre16">0</kbd> (not activated) or <kbd class="calibre16">1</kbd> (activated). This is actually a common argument in Nmap vulnerability scripts and it is important to understand its use.</li>
<li value="6" class="calibre19">By default, the <kbd class="calibre16">unsafe</kbd> argument is set to <kbd class="calibre16">0</kbd>. When this value is set, Nmap does not perform any tests that could potentially result in a denial-of-service condition. While this sounds like the optimal choice, it often means that the results of many tests will be less accurate, and some tests will not be performed at all. Activating the <kbd class="calibre16">unsafe</kbd> argument is recommended for a more thorough and accurate scan, but this should only be performed against production systems in authorized testing windows. To run the vulnerability scan, the specific NSE script should be defined with the <kbd class="calibre16">nmap --script</kbd> argument, and all script-specific arguments should be passed using the <kbd class="calibre16">nmap --script-args</kbd> argument.</li>
<li value="7" class="calibre19">Also, to run the vulnerability scan with minimal distracting output, Nmap should be configured to only scan the port corresponding to the scanned service, as follows:</li>
</ol>
<div class="p"><img class="alignnone154" src="../images/00652.jpeg"/></div>
<ol start="8" class="calibre20">
<li value="8" class="calibre19">There is one more NSE script that I would like to draw attention to, because it teaches an important lesson about the practice of vulnerability scanning. This script is <kbd class="calibre16">smb-vuln-ms10-061.nse</kbd>. The details of this script can be seen by reading the script from the top down with the <kbd class="calibre16">cat</kbd> command piped over to <kbd class="calibre16">more</kbd>:</li>
</ol>
<div class="p"><img class="alignnone155" src="../images/00032.jpeg"/></div>
<ol start="9" class="calibre20">
<li value="9" class="calibre19">This vulnerability was one of four vulnerabilities that were exploited by the Stuxnet worm. The script checks for the vulnerability in a safe way without the possibility of crashing the remote system, as this is not a memory corruption vulnerability. In order for the check to work, it needs access to at least one shared printer on the remote system. By default, it tries to enumerate printers using the LANMAN API, which on some systems is not available by default. In that case, a user should specify the printer share name as a printer script argument. To find a printer share, <kbd class="calibre16">smb-enum-shares</kbd> can be used.</li>
<li value="10" class="calibre19">Also, on some systems, accessing shares requires valid credentials, which can be specified with the <kbd class="calibre16">smb</kbd> library arguments: <kbd class="calibre16">smbuser</kbd> and <kbd class="calibre16">smbpassword</kbd>. What makes this vulnerability interesting is the fact that there are multiple factors that must be true before it can actually be exploited:</li>
</ol>
<div class="calibre31">
<ul class="calibre18">
<li class="calibre19">First, a system must be running one of the implicated operating systems (XP, Server 2003 SP2, Vista, Server 2008, or Windows 7).</li>
<li class="calibre19">Second, it must be missing the <kbd class="calibre16">MS10-061</kbd> patch, which addresses the code-execution vulnerability.</li>
<li class="calibre19">Finally, a local print share on the system must be publicly accessible. What is interesting about this is that it is possible to audit the remote SMB print spooler service to determine whether the system is patched regardless of whether there is an existing printer share on the system. Because of this, there are varying interpretations of what a vulnerable system is. Some vulnerability scanners will identify non-patched systems as vulnerable, though in reality the vulnerability cannot be exploited. Alternatively, other vulnerability scanners, such as the NSE script, will evaluate all the required conditions to determine whether the system is vulnerable.</li>
</ul>
</div>
<ol start="11" class="calibre20">
<li value="11" class="calibre19">In the example provided, the scanned system is not patched, but it also does not have a remote printer share. Have a look at the following example:</li>
</ol>
<div class="p"><img class="alignnone156" src="../images/00101.jpeg"/></div>
<ol start="12" class="calibre20">
<li value="12" class="calibre19">In the example provided, Nmap has determined that the system is not vulnerable because it does not have a remote printer share. While it is true that the vulnerability cannot be exploited, some would still claim that the vulnerability still exists because the system is unpatched and can be exploited in case an administrator decides to share a printer from that device. This is why the results of all vulnerability scanners must be evaluated to fully understand their results.</li>
<li value="13" class="calibre19">Some scanners will choose to evaluate only limited conditions, while others will be more thorough. It's hard to say what the best answer is here. Most penetration testers would probably prefer to be told that the system is not vulnerable because of environmental variables, so that they do not spend countless hours attempting to exploit a vulnerability that cannot be exploited.</li>
<li value="14" class="calibre19">Alternatively, a system administrator might prefer to know that the system is missing the <kbd class="calibre16">MS10-061</kbd> patch so that the system can be totally secured, even if the vulnerability cannot be exploited under the existing conditions.</li>
</ol>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="7NUI81-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works…</h1>
            

            <article>
                
<p class="calibre5">Most vulnerability scanners will operate by evaluating a number of different responses to attempt to determine whether a system is vulnerable to a specific attack. In some cases, a vulnerability scan may be as simple as establishing a TCP connection with the remote service and identifying a known vulnerable version by the banner that is self disclosed. In other cases, a complex series of probes and specially crafted requests may be sent to a remote service in an attempt to solicit responses that are unique to services that are vulnerable to a specific attack. In the example NSE vulnerability scripts provided, the vulnerability scan will actually try to exploit the vulnerability if the <kbd class="calibre16">unsafe</kbd> parameter is activated.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="7OT2Q1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Vulnerability scanning with MSF auxiliary modules</h1>
            

            <article>
                
<p class="calibre5">Similar to the vulnerability scanning scripts available in NSE, Metasploit also offers a number of useful vulnerability scanners. Like Nmap's scripts, most of these are fairly targeted and are used to scan a particular service.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="7PRJC1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre5">To perform vulnerability analysis with Metasploit auxiliary modules, you will need to have a system that is running network services over TCP or UDP. In the example provided, a Windows XP system with an RDP service is used for this task. For more information on setting up a Windows system, refer to the <em class="calibre15">Installing Windows Server</em> recipe in <a href="part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426" target="_blank" class="calibre6">Chapter 1</a>, <em class="calibre15">Getting Started</em>.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="7QQ3U1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it…</h1>
            

            <article>
                
<p class="calibre5">Let's perform the vulnerability scan using the MSF auxiliary modules:</p>
<ol class="calibre20">
<li value="1" class="calibre19">There are a number of different ways that one can identify the vulnerability scanning auxiliary modules in Metasploit. One effective way is to browse to the <kbd class="calibre16">/auxiliary/scanner</kbd> directory, as this is the location where most vulnerability identification scripts will be found. Have a look at the following example:</li>
</ol>
<div class="p"><img class="alignnone157" src="../images/00166.jpeg"/></div>
<ol start="2" class="calibre20">
<li value="2" class="calibre19">The layout of these scripts is fairly standardized, and a description of any given script can be identified by reading the script from top to bottom using the <kbd class="calibre16">cat</kbd> command and then piping the output over to the more utility. In the example provided, we can see that the script tests an authentication bypass vulnerability that exists in MySQL database services. Alternatively, one can search for vulnerability identification modules within the MSF console interface. To open this, one should use the <kbd class="calibre16">msfconsole</kbd> command.</li>
</ol>
<ol start="3" class="calibre20">
<li value="3" class="calibre19">The <kbd class="calibre16">search</kbd> command can then be used in conjunction with keywords that specifically relate to the service, or one can use the <kbd class="calibre16">scanner</kbd> keyword to query all scripts within the <kbd class="calibre16">auxiliary/scanner</kbd> directory, as follows:</li>
</ol>
<div class="p"><img class="alignnone157" src="../images/00242.jpeg"/></div>
<ol start="4" class="calibre20">
<li value="4" class="calibre19">Upon identifying a script that looks promising, one can use the <kbd class="calibre16">use</kbd> command in conjunction with the relative path to activate that script. Once activated, the following <kbd class="calibre16">info</kbd> command can be used to read additional details about the script to include details, description, options, and references:</li>
</ol>
<p class="calibre5"><img class="alignnone158" src="../images/00316.jpeg"/></p>
<ol start="5" class="calibre20">
<li value="5" class="calibre19">Once the module has been selected, the <kbd class="calibre16">show options</kbd> command can be used to identify and/or modify scan configurations. This command will display four column headers: <kbd class="calibre16">Name</kbd>, <kbd class="calibre16">Current Setting</kbd>, <kbd class="calibre16">Required</kbd>, and <kbd class="calibre16">Description</kbd>. The <kbd class="calibre16">Name</kbd> column identifies the name of each configurable variable. The <kbd class="calibre16">Current Setting</kbd> column lists the existing configuration for any given variable. The <kbd class="calibre16">Required</kbd> column identifies whether a value is required for any given variable. And the <kbd class="calibre16">Description</kbd> column describes the function of each variable. The value of any given variable can be changed by using the <kbd class="calibre16">set</kbd> command and providing the new value as an argument, as follows:</li>
</ol>
<div class="p"><img class="alignnone48" src="../images/00403.jpeg"/></div>
<ol start="6" class="calibre20">
<li value="6" class="calibre19">In this particular case, the system is found to be vulnerable. Given that a vulnerable system has been identified, there is a corresponding exploitation module that can be used to actually cause a denial of service on the vulnerable system. This can be seen in the example provided:</li>
</ol>
<div class="p"><img class="alignnone159" src="../images/00485.jpeg"/></div>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="7ROKG1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works…</h1>
            

            <article>
                
<p class="calibre5">Most vulnerability scanners will operate by evaluating a number of different responses to attempt to determine whether a system is vulnerable to a specific attack. In some cases, a vulnerability scan may be as simple as establishing a TCP connection with the remote service and identifying a known vulnerable version by the banner that is self-disclosed. In other cases, a complex series of probes and specially crafted requests may be sent to a remote service in an attempt to solicit responses that are unique to services that are vulnerable to a specific attack. In the preceding example, it is likely that the author of the script identified a way to solicit a unique response that would only be generated by either patched or non-patched systems and then used this as a basis to determine the exploitability of any given remote system.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="7SN521-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Creating scan policies with Nessus</h1>
            

            <article>
                
<p class="calibre5">Nessus is one of the most powerful and comprehensive vulnerability scanners. By targeting a system or group of systems, it will automatically scan for a large range of vulnerabilities on all identifiable services. Scan policies can be built in Nessus to more granularly define the types of vulnerability that it tests for and the types of scan that are performed. This recipe will explain how to configure unique scan policies in Nessus.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="7TLLK1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre5">To configure scan policies in Nessus, one must first have a functional copy of Nessus installed on the Kali Linux penetration-testing platform. Because Nessus is a licensed product, it does not come installed by default in Kali. For more information on how to install Nessus on Kali, refer to the <em class="calibre15">Installing Nessus on Kali Linux</em> recipe in <a href="part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426" target="_blank" class="calibre6">Chapter 1</a>, <em class="calibre15">Getting Started</em>.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="7UK661-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it…</h1>
            

            <article>
                
<p class="calibre5">The following steps will guide you to create scan policies using the Nessus:</p>
<ol class="calibre20">
<li value="1" class="calibre19">To configure a new scan policy in Nessus, you will first need to access the Nessus web interface at <kbd class="calibre16">https://localhost:8834</kbd> or <kbd class="calibre16">https://127.0.0.1:8834</kbd>. Alternatively, if you are not accessing the web interface from the same system that is running Nessus, you should specify the appropriate IP address or hostname.</li>
<li value="2" class="calibre19">Once the web interface has loaded, you will need to log in with the account that was configured during the installation process or with another account built after install. After logging in, the <span>Policies</span> tab at the top of the page should be selected. If no other policies have been configured, you will see an empty list and a single button that says <span>New Policy</span>. Click on that button to start building your first scan policy.</li>
</ol>
<ol start="3" class="calibre20">
<li value="3" class="calibre19">Upon clicking on <span>New Policy</span>, the <span>Policy Wizards</span> screen will pop up with a number of preconfigured scan templates that can be used to speed up the process of creating a scan policy. As you can see in the following screenshot, each of the templates includes a name and then a brief description of its intended function:</li>
</ol>
<div class="p"><img class="alignnone160" src="../images/00550.jpeg"/></div>
<ol start="4" class="calibre20">
<li value="4" class="calibre19">In most circumstances, at least one of these preconfigured scan profiles will resemble what you are trying to accomplish. Probably the most commonly used of all of these is <span>Basic Network Scan</span>. Keep in mind that after selecting any one of these options, you can still modify every detail of the existing configurations. They are just there to get you started faster. Alternatively, if you do not want to use an existing template, you can scroll down and select the <span>Advanced Scan </span>option, which will allow you to start from scratch.</li>
<li value="5" class="calibre19">If you select any one of the preconfigured templates, you will go through a quick three-step process to complete your scan profile. The process is summarized in the following steps:
<ol class="calibre22">
<li value="1" class="calibre19">Step 1 allows you to configure the basic details to include the profile <span>Name</span>, <span>Description</span>, and <span>Visibility</span> (<span>public</span> or <span>private</span>). Public profiles will be visible to all Nessus users, while private ones will only be visible to the users that created them.</li>
<li value="2" class="calibre19">Step 2 will simply ask whether the scan is internal or external. External scans will be those performed against publicly accessible hosts, usually sitting in the DMZ of an enterprise network. External scans do not require you to be on the same network but can be performed across the Internet. Alternatively, internal scans are performed from within a network and require direct access to the LAN of the scan targets.</li>
<li value="3" class="calibre19">Step 3, the final step, requests for authentication credentials for scanned devices, using either SSH or Windows authentication. Once completed, the new profile can be seen in the previously empty list shown when the <span>Profiles</span> tab is accessed. This is shown in the following screenshot:</li>
</ol>
</li>
</ol>
<div class="p"><img class="alignnone161" src="../images/00616.jpeg"/></div>
<ol start="6" class="calibre20">
<li value="6" class="calibre19">This approach makes it quick and easy to create new scan profiles, but doesn't give you a whole lot of control over the vulnerabilities tested and the types of scans performed. To modify more detailed configurations, click on the newly created policy name and then click on the <span>Advanced Mode</span> link. The options in this configuration mode are very comprehensive and specific. There are four different menus that can be accessed on the left-hand side of the screen. These include the following:</li>
</ol>
<div class="calibre31">
<ul class="calibre18">
<li class="calibre19"><span>General Settings</span>: This menu provides basic configurations, detailed port scanning options that define how discovery and service enumeration are performed, and performance options that define policies regarding speed, throttling, parallelism, and so on.</li>
<li class="calibre19"><span>Credentials</span>: This menu allows the configuration of Windows credentials, SSH, Kerberos, and even a number of clear-text protocol options (not encouraged).</li>
<li class="calibre19"><span>Plugins</span>: This menu provides extremely granular control over Nessus plugins. <span>Plugins</span> is the term used in Nessus for the specific audits or vulnerability checks performed. You can enable or disable groups of audits based on their type of function or even manipulate specific plugins one by one.</li>
<li class="calibre19"><span>Preferences</span>: This menu covers the configurations for all of the more obscure operational functions of Nessus, such as HTTP authentication, brute force settings, and database interaction.</li>
</ul>
</div>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="7VIMO1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works…</h1>
            

            <article>
                
<p class="calibre5">Scan policies are what define the values that are used by Nessus to define how a scan will be run. These scan policies can be as simple as the three steps required to complete the simple scan wizard setup or complicated to the extent that each unique plugin is defined and custom authentication and operational configurations are applied.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="80H7A1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Vulnerability scanning with Nessus</h1>
            

            <article>
                
<p class="calibre5">Nessus is one of the most powerful and comprehensive vulnerability scanners available. By targeting a system or group of systems, it will automatically scan for a large range of vulnerabilities on all identifiable services. Once scan policies have been configured to define the configurations for the Nessus scanner, the scan policy can be used to execute scans on remote targets for evaluation. This recipe will explain how to perform vulnerability scanning with Nessus.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="81FNS1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre5"><span>To configure scan policies in Nessus, one must first have a functional copy of Nessus installed on the Kali Linux penetration-testing platform. Because Nessus is a licensed product, it does not come installed by default in Kali. For more information on how to install Nessus on Kali, refer to the</span> <em class="calibre15">Installing Nessus on Kali Linux</em> <span>recipe in</span> <a href="part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426" target="_blank" class="calibre6">Chapter 1</a><span>,</span> <em class="calibre15">Getting Started</em><span>.</span> Additionally, at least one scan policy will need to be created prior to scanning with Nessus. For more information on creating scan policies in Nessus, refer to the preceding recipe.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="82E8E1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it…</h1>
            

            <article>
                
<p class="calibre5">Let's perform vulnerability scan with the help of Nessus:</p>
<ol class="calibre20">
<li value="1" class="calibre19">To get started with a new scan in Nessus, you will need to ensure that the <span>Scans</span> tab is selected at the top of the screen. If no scans have been run in the past, this will generate an empty list at the center of the screen. To execute an initial scan, you will need to click on the blue <span>New Scan</span> button on the left-hand side of the screen, as shown in the following screenshot:</li>
</ol>
<div class="p"><img class="alignnone162" src="../images/00664.jpeg"/></div>
<ol start="2" class="calibre20">
<li value="2" class="calibre19">This will require some basic configuration information. You will be prompted with a series of fields, including <span>Name</span>, <span>Policy</span>, <span>Folder</span>, and <span>Targets</span>:
<ul class="calibre30">
<li class="calibre19">The <span>Name</span> field is simply used as a unique identifier to distinguish the scan results from other scans. If you are performing a large number of scans, it will be helpful to be very specific with the scan name.</li>
<li class="calibre19">The second field is the <span>Policy</span> field. It is what really defines all of the details of the scan. This field allows you to select which scan policy will be used. If you are not familiar with how scan policies work, refer to the preceding recipe. Any public or private scan policies that the logged-in user has created should be visible in the <span>Policy</span> drop-down menu.</li>
<li class="calibre19">The <span>Folder</span> field defines which folder the scan results will be placed in. Organizing your scans in folders can be helpful when you need to sort through a large number of scan results. New scan folders can be created from the main <span>Scans</span> menu by clicking on <span>New Folder</span>.</li>
<li class="calibre19">The last field is <span>Targets</span>. This field shows how one defines what systems will be scanned. Here, you can enter a single host IP address, a list of IP addresses, a sequential range of IP addresses, a CIDR range, or a list of IP ranges. Alternatively, you can use hostnames, assuming the scanner is able to properly resolve them to IP addresses using DNS.</li>
<li class="calibre19">Finally, there is also an option to upload a text file containing a list of targets in any of the aforementioned formats, as shown in the following screenshot:</li>
</ul>
</li>
</ol>
<div class="p"><img class="alignnone163" src="../images/00047.jpeg"/></div>
<ol start="3" class="calibre20">
<li value="3" class="calibre19">After configuring the scan, it can be executed using the <span>Launch</span> button at the bottom of the screen. This will immediately add the scan to the list of scans, and the results can be viewed in real time, as shown in the following screenshot:</li>
</ol>
<div class="p"><img class="alignnone164" src="../images/00134.jpeg"/></div>
<ol start="4" class="calibre20">
<li value="4" class="calibre19">Even while the scan is running, you can click on the scan name and begin viewing the vulnerabilities as they are identified. Color-coding is used to quickly and easily identify the number of vulnerabilities and their levels of severity, as shown in the following screenshot:</li>
</ol>
<div class="p"><img class="alignnone165" src="../images/00555.jpeg"/></div>
<ol start="5" class="calibre20">
<li value="5" class="calibre19">After clicking on the example scan, we can see two of the hosts that are being scanned. The first indicates that the scan is complete, and the second host is at 2% completion. The bar graphs shown in the <span>Vulnerabilities</span> column show the number of vulnerabilities associated with each given host. Alternatively, one can click on the <span>Vulnerabilities</span> link at the top of the screen to organize the findings by discovered vulnerability and then the number of hosts for which that vulnerability was identified.</li>
<li value="6" class="calibre19">To the right-hand side of the screen, we can see a similar pie chart, but this one corresponds to all hosts scanned, as shown in the following screenshot:</li>
</ol>
<div class="p"><img class="alignnone166" src="../images/00261.jpeg"/></div>
<ol start="7" class="calibre20">
<li value="7" class="calibre19">This pie chart also clearly defines the meanings for each of the colors, ranging from critical vulnerabilities to informational details. By selecting the link for any particular host IP address, you can see the specific vulnerabilities that were identified for that host:</li>
</ol>
<div class="p"><img class="alignnone167" src="../images/00338.jpeg"/></div>
<ol start="8" class="calibre20">
<li value="8" class="calibre19">This list of vulnerabilities identifies the plugin name, which generally provides a brief description of the finding and the level of severity. As a penetration tester, the critical and high vulnerabilities will usually be the most promising if you are seeking to achieve remote code execution on the target system. By clicking on any one of the distinct vulnerabilities, you can get a large amount of information on that vulnerability, as shown in the following screenshot:</li>
</ol>
<div class="p"><img class="alignnone168" src="../images/00428.jpeg"/></div>
<ol start="9" class="calibre20">
<li value="9" class="calibre19">In addition to description and patching information, this page will also provide alternative sources for further research, and most importantly (for penetration testers, anyway) reveal whether or not an exploit exists. This page will also often indicate whether an available exploit is a public exploit or whether it exists within an exploitation framework such as Metasploit, CANVAS, or Core Impact.</li>
</ol>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="83CP01-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works…</h1>
            

            <article>
                
<p class="calibre5">Most vulnerability scanners will operate by evaluating a number of different responses to attempt to determine whether a system is vulnerable to a specific attack. In some cases, a vulnerability scan may be as simple as establishing a TCP connection with the remote service and identifying a known vulnerable version by the banner that is self-disclosed. In other cases, a complex series of probes and specially crafted requests may be sent to a remote service in an attempt to solicit responses that are unique to services that are vulnerable to a specific attack. Nessus sequences a large number of tests together to attempt to generate a complete picture of the attack surface for a given target.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="84B9I1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Vulnerability scanning with OpenVAS</h1>
            

            <article>
                
<p class="calibre5"><strong class="calibre1">Open Vulnerability Assessment System</strong> (<strong class="calibre1">OpenVAS</strong>) is freeware that is a vulnerability scanner and management suite. OpenVAS and Nessus are similar; in fact, OpenVAS was forked from the last free version of Nessus before it went proprietary. In this recipe, we will cover how to install and perform a scan with OpenVAS.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="859Q41-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre5">To use OpenVAS to perform vulnerability scanning, you will need to have a remote system available for scanning. In the examples provided, an instance of Metasploitable2 is used to perform this task. For more information on how to set up Metasploitable2, refer to <a href="part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426" target="_blank" class="calibre6">Chapter 1</a>, <em class="calibre15">Getting Started</em>. </p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="868AM1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre5">The following steps will guide you to perform vulnerability scan with the help of OpenVAS:</p>
<ol class="calibre20">
<li value="1" class="calibre19">OpenVAS does not come preinstalled on Kali Linux, but it is a simple process to get it installed and running. To begin, we will use the <kbd class="calibre16">apt-get</kbd> command to install the software; when prompted to continue, type <kbd class="calibre16">Y</kbd>:</li>
</ol>
<div class="p"><img class="alignnone169" src="../images/00502.jpeg"/></div>
<ol start="2" class="calibre20">
<li value="2" class="calibre19">Once successfully installed, run the <kbd class="calibre16">openvas-setup</kbd> command: </li>
</ol>
<div class="p"><img class="alignnone170" src="../images/00568.jpeg"/></div>
<ol start="3" class="calibre20">
<li value="3" class="calibre19">It will take a while for the set up to configure itself and install the vulnerability test scripts. At the conclusion of the configuration, take note of the password created. This will be needed when logging into the OpenVAS web interface:</li>
</ol>
<p class="calibre5"><img class="alignnone171" src="../images/00629.jpeg"/></p>
<ol start="4" class="calibre20">
<li value="4" class="calibre19">Once OpenVAS has been installed and configured we can start it using the <kbd class="calibre16">openvas-start</kbd> command:</li>
</ol>
<div class="p"><img class="alignnone170" src="../images/00677.jpeg"/></div>
<ol start="5" class="calibre20">
<li value="5" class="calibre19">We can now access the OpenVAS web interface by navigating to <kbd class="calibre16">https://127.0.0.1:9392/</kbd> with our local browser. We can authenticate using <kbd class="calibre16">admin</kbd> as our <span>Username</span> and <span>Password</span> we received at the conclusion of the <kbd class="calibre16">openvas-setup</kbd> process:</li>
</ol>
<div class="p"><img class="alignnone172" src="../images/00065.jpeg"/></div>
<ol start="6" class="calibre20">
<li value="6" class="calibre19">Upon successful authentication you are presented with the OpenVAS dashboard. Here (if you have any) you can see statistics on your scans and vulnerabilities. Given that we have just installed OpenVAS we do not currently have any data to display. We can change this by running a scan. To do this, go to <span>Scans</span> in the top menu and select <span>Tasks</span>:</li>
</ol>
<div class="p"><img class="alignnone173" src="../images/00130.jpeg"/></div>
<ol start="7" class="calibre20">
<li value="7" class="calibre19">Once on the the <span>Tasks</span> page, go to the wand icon in the top-left corner of the page and select <span>Task Wizard</span>:</li>
</ol>
<p class="calibre5"><img class="alignnone174" src="../images/00208.jpeg"/></p>
<ol start="8" class="calibre20">
<li value="8" class="calibre19">From the <span>Task Wizard</span> screen we are prompted to enter an <span>IP address or hostname</span>. For our example, we will use the IP address of our Metasploitable2 machine, <kbd class="calibre16">172.16.69.128</kbd>, and click on the <span>Start Scan</span> button:</li>
</ol>
<div class="p"><img class="alignnone175" src="../images/00279.jpeg"/></div>
<ol start="9" class="calibre20">
<li value="9" class="calibre19">On completion of the wizard, OpenVAS will begin scanning the target assigned. It will take some time for it to run the various scans and tests on your target machine. Upon completion, you should see a summary:</li>
</ol>
<div class="p"><img class="alignnone175" src="../images/00357.jpeg"/></div>
<ol start="10" class="calibre20">
<li value="10" class="calibre19">To view the results of the OpenVAS scan, navigate to the <span>Scans</span> section of the menus and select <span>Results</span>:</li>
</ol>
<div class="p"><img class="alignnone175" src="../images/00451.jpeg"/></div>
<ol start="11" class="calibre20">
<li value="11" class="calibre19">Here you can see the results of your scans. There are helpful charts showing the number of vulnerabilities by class (<span>High</span>, <span>Medium</span>, <span>Low</span>, <span>Log</span>) and by <strong class="calibre1">Common Vulnerability Scoring System</strong> (<strong class="calibre1">CVSS</strong>). Following the charts mentioned, we can see a list of each vulnerability, its severity, and its location:</li>
</ol>
<div class="p"><img class="alignnone176" src="../images/00521.jpeg"/></div>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="876R81-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre5">Most vulnerability scanners will operate by evaluating a number of different responses to attempt to determine whether a system is vulnerable to a specific attack. In some cases, a vulnerability scan may be as simple as establishing a TCP connection with the remote service and identifying a known vulnerable version by the banner that is self-disclosed. In other cases, a complex series of probes and specially crafted requests may be sent to a remote service in an attempt to solicit responses that are unique to services that are vulnerable to a specific attack. OpenVAS sequences a large number of tests together to attempt to generate a complete picture of the attack surface for a given target.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="885BQ1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Validating vulnerabilities with HTTP interaction</h1>
            

            <article>
                
<p class="calibre5">As a penetration tester, the best outcome of any given exploit is to achieve remote code execution. However, there are cases in which we might just want to determine whether a remote code-execution vulnerability is exploitable but don't want to actually follow through the entire exploitation and post-exploitation process. One way to do this is to create a web server that will log interaction and use a given exploit to execute code that would cause the remote host to interact with the web server. This recipe will demonstrate how to write a custom script for validating remote code-execution vulnerabilities with HTTP traffic.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="893SC1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre5">To validate vulnerabilities using HTTP interaction, you will need to have a system that is running software with a remote code execution vulnerability. Additionally, this section will require a script to be written to the filesystem using a text editor such as Vim or <span>GNU n</span>ano. For more information on writing scripts, refer to the <em class="calibre15">Using text editors (Vim and <span>GNU n</span>ano)</em> recipe in <a href="part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426" target="_blank" class="calibre6">Chapter 1</a>, <em class="calibre15">Getting Started</em>.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="8A2CU1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it…</h1>
            

            <article>
                
<p class="calibre5">Let's validate vulnerabilities with the help of HTTP interaction:</p>
<ol class="calibre20">
<li value="1" class="calibre19">Before actually exploiting a given vulnerability, we must deploy a web server that will log interaction with it. This can be done with a simple Python script, as follows:</li>
</ol>
<pre class="calibre24">
        #!/usr/bin/python<br class="title-page-name"/><br class="title-page-name"/>        import socket<br class="title-page-name"/><br class="title-page-name"/>        print "Awaiting connection...n"<br class="title-page-name"/><br class="title-page-name"/>        httprecv = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br class="title-page-name"/>        httprecv.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)<br class="title-page-name"/>        httprecv.bind(("0.0.0.0",8000))<br class="title-page-name"/>        httprecv.listen(2)<br class="title-page-name"/><br class="title-page-name"/>        (client, ( ip,sock)) = httprecv.accept()<br class="title-page-name"/>        print "Received connection from : ", ip<br class="title-page-name"/>        data = client.recv(4096)<br class="title-page-name"/>        print str(data)<br class="title-page-name"/><br class="title-page-name"/>        client.close()<br class="title-page-name"/>        httprecv.close()
</pre>
<ol start="2" class="calibre20">
<li value="2" class="calibre19">The provided Python script uses the <kbd class="calibre16">socket</kbd> library to generate a web server that listens on TCP port <kbd class="calibre16">8000</kbd> of all local interfaces. Upon receiving a connection from a client, the script will return the client's IP address and the request sent.</li>
<li value="3" class="calibre19">To use this script to validate a vulnerability, we need to execute code that will cause the remote system to interact with the hosted web service. But before doing this, we need to launch our script with the following command:</li>
</ol>
<div class="p"><img class="alignnone177" src="../images/00103.jpeg"/></div>
<ol start="4" class="calibre20">
<li value="4" class="calibre19">Next, we need to exploit a vulnerability that will yield remote code execution. By reviewing the Nessus scan results of the Metasploitable2 box, we can see that the FTP service running has a backdoor that can be triggered by supplying a username with a smiley face in it—no joke! This was actually included in a production FTP service. To attempt to exploit this, we will first connect to the service with an appropriate username, as follows:</li>
</ol>
<div class="p"><img class="alignnone178" src="../images/00169.jpeg"/></div>
<ol start="5" class="calibre20">
<li value="5" class="calibre19">After attempting to connect with a username with a smiley face included, a backdoor should have opened on the remote host's TCP port <kbd class="calibre16">6200</kbd>. We need not even enter a password. Instead, <em class="calibre15">Ctrl</em> + <em class="calibre15">C</em> can be used to exit the FTP client and then Netcat can be used to connect to the opened backdoor, as follows:</li>
</ol>
<div class="p"><img class="alignnone179" src="../images/00245.jpeg"/></div>
<ol start="6" class="calibre20">
<li value="6" class="calibre19">After establishing a TCP connection with the open port, we can use our script to verify that we can perform remote code execution. To do this, we attempt to use the <kbd class="calibre16">wget</kbd> command with the URL of the HTTP detection server. After attempting to execute this code, we can verify that the HTTP request was received by looking back to the script output:</li>
</ol>
<div class="p"><img class="alignnone180" src="../images/00319.jpeg"/></div>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="8B0TG1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works…</h1>
            

            <article>
                
<p class="calibre5">This script works by identifying attempted connections from remote hosts. By executing code that causes a remote system to connect back to our listening server, it is possible to verify that remote code execution is possible by exploiting a particular vulnerability. If <kbd class="calibre16">wget</kbd> or <kbd class="calibre16">curl</kbd> are not installed on the remote server, another means of identifying remote code execution may need to be employed.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="8BVE21-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Validating vulnerabilities with ICMP interaction</h1>
            

            <article>
                
<p class="calibre5">As a penetration tester, the best outcome of any given exploit is to achieve remote code execution. However, there are cases in which we might only want to determine whether a remote code-execution vulnerability is exploitable but don't want to actually follow through the entire exploitation and post-exploitation process. One way to do this is to run a script that logs ICMP traffic and then execute a <kbd class="calibre16">ping</kbd> command on the remote system. This recipe will demonstrate how to write a custom script for validating remote code-execution vulnerabilities with ICMP traffic.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="8CTUK1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre5">To validate vulnerabilities using ICMP traffic logging, you will need to have a remote system that is running an exploitable code-execution vulnerability. Additionally, this section will require a script to be written to the filesystem using a text editor such as Vim or <span>GNU n</span>ano. For more information on writing scripts, refer to the <em class="calibre15">Using text editors (Vim and <span>GNU n</span>ano)</em> recipe in <a href="part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426" target="_blank" class="calibre6">Chapter 1</a>, <em class="calibre15">Getting Started</em>.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="8DSF61-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it…</h1>
            

            <article>
                
<p class="calibre5">Performing <span>vulnerabilities </span>validation operation using ICMP interaction:</p>
<ol class="calibre20">
<li value="1" class="calibre19">Before actually exploiting a given vulnerability, we must deploy a script to log incoming ICMP traffic. This can be done with a simple Python script using Scapy, as follows:</li>
</ol>
<pre class="calibre24">
        #!/usr/bin/python<br class="title-page-name"/><br class="title-page-name"/>        import logging<br class="title-page-name"/>        logging.getLogger("scapy.runtime").setLevel(logging.ERROR)<br class="title-page-name"/>        from scapy.all import *<br class="title-page-name"/><br class="title-page-name"/>        def rules(pkt):<br class="title-page-name"/>        try:<br class="title-page-name"/>        if (pkt[IP].dst=="172.16.69.133") and (pkt[ICMP]):<br class="title-page-name"/>          print str(pkt[IP].src) + " is exploitable"<br class="title-page-name"/>        except:<br class="title-page-name"/>          pass<br class="title-page-name"/><br class="title-page-name"/>        print "Listening for Incoming ICMP Traffic.<br class="title-page-name"/>         Use Ctrl+C to stop listening"<br class="title-page-name"/><br class="title-page-name"/>        sniff(lfilter=rules,store=0)
</pre>
<ol start="2" class="calibre20">
<li value="2" class="calibre19">The provided Python script sniffs all incoming traffic and flags the source of any ICMP traffic directed toward the scanning system as vulnerable. To use this script to validate that a vulnerability can be exploited, we need to execute code that will cause the remote system to ping our scanning system. To demonstrate this, we can use Metasploit to launch a remote code-execution exploit. But prior to doing this, we need to launch our script, as follows:</li>
</ol>
<div class="p"><img class="alignnone180" src="../images/00408.jpeg"/></div>
<ol start="3" class="calibre20">
<li value="3" class="calibre19">Next, we need to exploit a vulnerability that will yield remote code execution. By reviewing the Nessus scan results of the Windows XP box, we can see that the system is vulnerable to the <kbd class="calibre16">MS08-067</kbd> exploit. To validate this, we will exploit the vulnerability with a payload that executes a <kbd class="calibre16">ping</kbd> command back to the scanning system, as follows:</li>
</ol>
<div class="p"><img class="alignnone181" src="../images/00099.jpeg"/></div>
<ol start="4" class="calibre20">
<li value="4" class="calibre19">The exploit in Metasploit was configured to use the <kbd class="calibre16">windows/exec</kbd> payload that executes code in the exploited system. This payload was configured to send a single ICMP echo request to our scanning system. After execution, we can confirm that the exploit was successful by referring back to the original script that was still listening, as follows:</li>
</ol>
<div class="p"><img class="alignnone180" src="../images/00553.jpeg"/></div>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="8EQVO1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works…</h1>
            

            <article>
                
<p class="calibre5">This script works by listening for incoming ICMP traffic from remote hosts. By executing code that causes a remote system to send an <kbd class="calibre16">echo</kbd> request to our listening server, it is possible to verify that remote code execution is possible by exploiting a particular vulnerability.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    </body></html>