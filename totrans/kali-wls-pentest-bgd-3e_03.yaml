- en: Chapter 3. Bypassing WLAN Authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '|   | *"A false sense of security is worse than being unsure."* |   |'
  prefs: []
  type: TYPE_TB
- en: '|   | --*Anonymous* |'
  prefs: []
  type: TYPE_TB
- en: '*A false sense of security is worse than being insecure, as you may not be
    prepared to face the eventuality of being hacked.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*WLANs can have weak authentication schemas that can be easily broken and bypassed.
    In this chapter, we will take a look at the various basic authentication schemas
    used in WLANs and learn how to beat them.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will take a look at the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Uncovering hidden SSIDs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Beating MAC filters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bypassing Open Authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bypassing **Shared Key Authentication** (**SKA**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hidden SSIDs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the default configuration mode, all access points send out their SSIDs in
    beacon frames. This allows clients in the vicinity to discover them easily. Hidden
    SSIDs is a configuration where the access point does not broadcast its SSID in
    beacon frames. Thus, only clients that know the SSID of the access point can connect
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, this measure does not provide robust security, but most network
    administrators think it does. Hidden SSIDs should not be considered a security
    measure by any stretch of the imagination. We will now take a look at how to uncover
    hidden SSIDs.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – uncovering hidden SSIDs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perform the following instructions to get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Using Wireshark, if we monitor beacon frames in the Wireless Lab network, we
    are able to see the SSID in plain text. You should see beacon frames, as shown
    in the following screenshot:![Time for action – uncovering hidden SSIDs](graphics/B09903_03_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure your access point to set the `Wireless Lab` network as a hidden SSID.
    The configuration option to do this may differ across access points. In my case,
    I need to check the `Invisible` option in the **Visibility Status** option, as
    shown in the following screenshot:![Time for action – uncovering hidden SSIDs](graphics/B09903_03_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now if you take a look at the Wireshark trace, you will find that the SSID `Wireless
    Lab` has disappeared from the beacon frames. This is what hidden SSIDs are all
    about:![Time for action – uncovering hidden SSIDs](graphics/B09903_03_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In order to bypass beacon frames, we will first use the passive technique of
    waiting for a legitimate client to connect to the access point. This will generate
    probe request and probe response packets that will contain the SSID of the network,
    thus revealing its presence:![Time for action – uncovering hidden SSIDs](graphics/B09903_03_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Alternatively, you can use the `aireplay-ng` utility to send deauthentication
    packets to all stations on behalf of the `Wireless Lab` access point by typing
    `aireplay-ng -0 5 -a <mac> --ignore-negative wlan0mon`, where `<mac>` is the MAC
    address of the router. The `-0` option is used to choose a deauthentication attack,
    and `5` is the number of deauthentication packets to send. Finally, `-a` specifies
    the MAC address of the access point you are targeting:![Time for action – uncovering
    hidden SSIDs](graphics/B09903_03_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The preceding deauthentication packets will force all legitimate clients to
    disconnect and reconnect. It would be a good idea to add a filter for deauthentication
    packets to view them in an isolated way, which we can do with `wlan.fc.type_subtype
    == 0x0c`:![Time for action – uncovering hidden SSIDs](graphics/B09903_03_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The probe responses from the access point will end up revealing its hidden SSID.
    These packets will show up on Wireshark as shown in the following screenshot.
    Once the legitimate clients connect back, we can see the hidden SSID using the
    probe request and probe response frames. You can use the filter `(wlan.bssid ==
    <the AP MAC>) && !(wlan.fc.type_subtype == 0x08)` to monitor all non-beacon packets
    to and fro from the access point. The `&&` sign stands for the logical AND operator
    and the `!` sign stands for the logical NOT operator:![Time for action – uncovering
    hidden SSIDs](graphics/B09903_03_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Even though the SSID is hidden and not broadcasted, whenever a legitimate client
    tries to connect to the access point, they exchange probe request and probe response
    packets. These packets contain the SSID of the access point. As these packets
    are not encrypted, they can be very easily sniffed from the air and the SSID can
    be found.
  prefs: []
  type: TYPE_NORMAL
- en: We will cover using probe requests for other purposes such as tracking in a
    later chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In many cases, all clients may be already connected to the access point and
    there may be no probe request/response packets available in the Wireshark trace.
    Here, we can forcibly disconnect the clients from the access point by sending
    forged deauthentication packets on the air. These packets will force the clients
    to reconnect back to the access point, thus revealing the SSID.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero – selecting deauthentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous exercise, we sent broadcast deauthentication packets to force
    reconnection of all wireless clients. Try to verify how you can selectively target
    individual clients using the `aireplay-ng` utility.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that, even though we are illustrating many of these
    concepts using Wireshark, it is possible to orchestrate these attacks with other
    tools, such as the `aircrack-ng` suite as well. We encourage you to explore the
    entire `aircrack-ng` suite of tools and other documentation located on their website
    at [http://www.aircrack-ng.org](http://www.aircrack-ng.org).
  prefs: []
  type: TYPE_NORMAL
- en: MAC filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MAC filters are an age-old technique used for authentication and authorization
    and have their roots in the wired world. Unfortunately, they fail miserably in
    the wireless world.
  prefs: []
  type: TYPE_NORMAL
- en: The basic idea is to authenticate based on the MAC address of the client. The
    MAC filter is an identification code assigned to a network interface; a router
    will be able to check this code and compare it to a list of approved MACs. This
    list of allowed MAC addresses will be maintained by the network administrator
    and will be fed into the access point. We will now take a look at how easy it
    is to bypass MAC filters.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – beating MAC filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s follow the instructions to get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Let's first configure our access point to use MAC filtering and then add the
    client MAC address of the victim laptop. The settings pages on my router looks
    as follows:![Time for action – beating MAC filters](graphics/B09903_03_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once MAC filtering is enabled, only the allowed MAC address will be able to
    successfully authenticate with the access point. If we try to connect to the access
    point from a machine with a non-whitelisted MAC address, the connection will fail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Behind the scenes, the access point is sending authentication failure messages
    to the client. The packet trace resembles the following:![Time for action – beating
    MAC filters](graphics/B09903_03_09.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In order to beat MAC filters, we can use `airodump-ng` to find the MAC addresses
    of clients connected to the access point. We can do this by issuing the `airodump-ng
    -c 10 -a --bssid <mac> wlan0mon` command. By specifying the `bssid` command, we
    will only monitor the access point, which is of interest to us. The `-c 10` command
    sets the channel to `10`, where the access point is. The `-a` command ensures
    that, in the client section of the `airodump-ng` output, only clients associated
    and connected to an access point are shown. This will show us all the client MAC
    addresses associated with the access point:![Time for action – beating MAC filters](graphics/B09903_03_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once we find a whitelisted client's MAC address, we can spoof the MAC address
    of the client using the `macchanger` utility, which ships with Kali. You can use
    the `macchanger –m <mac> wlan0mon` command to get this done. The MAC address you
    specify with the `-m` command option is the new spoofed MAC address for the `wlan0mon`
    interface:![Time for action – beating MAC filters](graphics/B09903_03_11.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you can clearly see, we are now able to connect to the access point after
    spoofing the MAC address of a whitelisted client.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We monitored the air using `airodump-ng` and found the MAC address of legitimate
    clients connected to the wireless network. We then used the `macchanger` utility
    to change our wireless card's MAC address to match the client's. This fooled the
    access point into believing that we were the legitimate client, and it allowed
    us access to its wireless network.
  prefs: []
  type: TYPE_NORMAL
- en: You are encouraged to explore the different options of the `airodump-ng` utility
    by going through the documentation on their website at [http://www.aircrack-ng.org/doku.php?id=airodump-ng](http://www.aircrack-ng.org/doku.php?id=airodump-ng).
  prefs: []
  type: TYPE_NORMAL
- en: Open Authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The term Open Authentication is almost a misnomer, as it actually provides no
    authentication at all. When an access point is configured to use Open Authentication,
    it will successfully authenticate all clients that connect to it.
  prefs: []
  type: TYPE_NORMAL
- en: We will now do an exercise to authenticate and connect to an access point using
    Open Authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – bypassing Open Authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s now take a look at how to bypass Open Authentication:'
  prefs: []
  type: TYPE_NORMAL
- en: We will first set our lab access point Wireless Lab to use Open Authentication.
    On my access point, this is simply done by setting **Security Mode** to **Disable
    Security**:![Time for action – bypassing Open Authentication](graphics/B09903_03_12.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then connect to this access point using the `iwconfig wlan0 essid Wireless
    Lab` command and verify that the connection has succeeded and that we are connected
    to the access point.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that we did not have to supply any username/password/passphrase to get
    through Open Authentication.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is probably the simplest exercise so far. As you saw, there is no barrier
    to connecting to an Open Authentication network and connecting to the access point.
  prefs: []
  type: TYPE_NORMAL
- en: Shared Key Authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'SKA uses a shared secret such as the WEP key to authenticate the client. The
    exact exchange of information is illustrated in the following screenshot (taken
    from [www.netgear.com](http://www.netgear.com)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Shared Key Authentication](graphics/B09903_03_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The wireless client sends an authentication request to the access point, which
    responds back with a challenge. The client now needs to encrypt this challenge
    with the shared key and send it back to the access point, which decrypts this
    to check whether it can recover the original challenge text. If it succeeds, the
    client successfully authenticates; if not, it sends an authentication failed message.
  prefs: []
  type: TYPE_NORMAL
- en: The security problem here is that an attacker passively listening to this entire
    communication by sniffing the air has access to both the plain text challenge
    and the encrypted challenge. He can apply the XOR operation to retrieve the keystream.
    This keystream can be used to encrypt any future challenge sent by the access
    point without needing to know the actual key.
  prefs: []
  type: TYPE_NORMAL
- en: The most common form of shared authentication is known as **Wired Equivalent
    Privacy** (**WEP**). It is easy to break, and numerous tools have been created
    over time to facilitate the cracking of WEP networks.
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we will learn how to sniff the air to retrieve the challenge
    and the encrypted challenge, retrieve the keystream, and use it to authenticate
    to the access point without needing the shared key.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – bypassing shared authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Bypassing shared authentication is a bit more challenging than the previous
    exercises, so follow the steps carefully:'
  prefs: []
  type: TYPE_NORMAL
- en: Let's first set up shared authentication for our Wireless Lab network. I have
    done this on my access point by setting the security mode as **WEP** and **Authentication**
    as **Shared Key**:![Time for action – bypassing shared authentication](graphics/B09903_03_14.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's now connect a legitimate client to this network using the shared key we
    have set in step 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In order to bypass SKA, we will first start sniffing packets between the access
    point and its clients. However, we would also like to log the entire shared authentication
    exchange. To do this, we use the `airodump-ng` utility using the `airodump-ng
    wlan0mon -c 11 --bssid <mac> -w keystream` command. The `-w` option, which is
    new here, requests `airodump-ng` to store the packets in a file whose name is
    prefixed with the word `keystream`. Incidentally, it might be a good idea to store
    different sessions of packet captures in different files. This allows you to analyze
    them long after the trace has been collected:![Time for action – bypassing shared
    authentication](graphics/B09903_03_15.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can either wait for a legitimate client to connect to the access point or
    force a reconnect using the deauthentication technique used previously. Once a
    client connects and the SKA succeeds, `airodump-ng` will capture this exchange
    automatically by sniffing the air. An indication that the capture has succeeded
    is when the `AUTH` column reads WEP.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The captured keystream is stored in a file prefixed with the word `keystream`
    in the current directory. In my case, the name of the file is `keystream-01-00-21-91-D2-8E-25.xor`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If this doesn't work, you can use `aireplay-ng -4 -h <Connected Device MAC>
    -a <AP BSSID> wlan0mon` to generate an `.xor` file. This requires a connected
    device to be on the target WEP protected network and will generate packets spoofing
    their MAC address to identify the XOR stream and key.![Time for action – bypassing
    shared authentication](graphics/B09903_03_16.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In order to fake a SKA, we will use the `aireplay-ng` tool. We run the `aireplay-ng
    -1 0 -e "Wireless Lab" -y keystream-01-00-21-91-D2-8E-25.xor -a <mac> -h AA:AA:AA:AA:AA:AA
    wlan0mon` command. This `aireplay-ng` command uses the keystream we just retrieved
    and tries to authenticate with the access point with the SSID, `Wireless Lab`
    and the MAC address, `00:21:91:D2:8E:25`, and uses an arbitrary client MAC address,
    `AA:AA:AA:AA:AA:AA.`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fire up Wireshark and sniff all packets of interest by applying a `wlan.addr
    == AA:AA:AA:AA:AA:AA` filter. We can verify this using Wireshark. You should see
    a trace on the Wireshark screen, as shown in the following screenshot:![Time for
    action – bypassing shared authentication](graphics/B09903_03_17.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first packet is the authentication request sent by the `aireplay-ng` tool
    to the access point:![Time for action – bypassing shared authentication](graphics/B09903_03_18.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second packet consists of the access point sending the client challenge
    text, as shown in the following screenshot:![Time for action – bypassing shared
    authentication](graphics/B09903_03_19.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the third packet, the tool sends the encrypted challenge to the access point:![Time
    for action – bypassing shared authentication](graphics/B09903_03_20.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As the `aireplay-ng` tool used the derived keystream for encryption, the authentication
    succeeds and the access point sends a success message in the fourth packet:![Time
    for action – bypassing shared authentication](graphics/B09903_03_21.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the authentication succeeds, the tool fakes an association with the access
    point, which succeeds as well. If you check the wireless logs in your access point's
    administrative interface, you should now see a wireless client with the MAC address,
    `AA:AA:AA:AA:AA:AA` connected:![Time for action – bypassing shared authentication](graphics/B09903_03_22.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We were successful in deriving the keystream from a shared authentication exchange,
    and we used it to fake an authentication to the access point.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero – filling up the access point's tables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Access points have a maximum client count after which they start refusing connections.
    By writing a simple wrapper over `aireplay-ng`, it is possible to automate and
    send hundreds of connection requests from random MAC addresses to the access point.
    This will end up filling the internal tables and once the maximum client count
    is reached, the access point will stop accepting new connections. This is typically
    what is called a **Denial of Service** (**DoS**) attack and can force the router
    to reboot or make it dysfunctional. This can lead to all the wireless clients
    being disconnected and being unable to use the authorized network.
  prefs: []
  type: TYPE_NORMAL
- en: Check whether you can verify this in your lab!
  prefs: []
  type: TYPE_NORMAL
- en: Pop quiz – WLAN authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Q1\. How can you force a wireless client to reconnect to the access point?
  prefs: []
  type: TYPE_NORMAL
- en: By sending a deauthentication packet
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By rebooting the client
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By rebooting the access point
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All of the above
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Q2\. What does Open Authentication do?
  prefs: []
  type: TYPE_NORMAL
- en: It provides decent security
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It provides no security
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It requires the use of encryption
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: None of the above
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Q3\. How does breaking SKA work?
  prefs: []
  type: TYPE_NORMAL
- en: By deriving the keystream from the packets
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By deriving the encryption key
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By sending deauthentication packets to the access point
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By rebooting the access point
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learnt about WLAN authentication. Hidden SSIDs are a security-through-obscurity
    feature and are relatively simple to beat. MAC address filters do not provide
    any security, as MAC addresses can be sniffed from the air from the wireless packets.
    This is possible because the MAC addresses are unencrypted in the packet. Open
    Authentication provides no real authentication at all. SKA is a bit tricky to
    beat but, with the help of the right tools, we can derive the store and the keystream,
    using which it is possible to answer all future challenges sent by the access
    point. The result is that we can authenticate without needing to know the actual
    key.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take a look at different WLAN encryption mechanisms—WEP,
    WPA, and WPA2—and look at the insecurities that plague them.
  prefs: []
  type: TYPE_NORMAL
