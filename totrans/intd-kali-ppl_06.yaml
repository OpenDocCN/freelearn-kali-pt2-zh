- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Configuring the ELK Stack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you learned how to install Kali Linux on a device –
    which is only half the toolset of Kali Purple. This chapter will help you grasp
    the other half, the **ELK stack**. Now that Kali Linux is installed, you will
    use the command line to install and configure Elasticsearch, Logstash, and Kibana
    so that you can begin developing a fully functioning robust *Purple* cybersecurity
    system.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We will break the tide a tiny bit as we’ll install these utilities in an order
    that is different from how we mention them. Elasticsearch will come first. However,
    to fully appreciate and utilize this utility from a beginner standpoint, we are
    going to install Kibana right afterward and integrate the two. Logstash will be
    last. You will understand why as we negotiate the process. So, you might say the
    ELK stack is the EKL stack! It doesn’t matter what we call it, so long as we get
    them all up and running properly.
  prefs: []
  type: TYPE_NORMAL
- en: As we did in [*Chapter 3*](B21223_03.xhtml#_idTextAnchor052), we’re going to
    inject a generous dose of troubleshooting and solutions for issues that users
    commonly encounter while configuring the ELK stack. It is impossible to account
    for every possible issue because of product changes and improvements that are
    longstanding and will continue to occur long after this book is published. For
    that reason, we encourage you to read the troubleshooting scenarios even if they
    don’t apply to you because that will help mold and enhance your thinking into
    that of an analyst’s mindset.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you’ll have set up a barebones SIEM technology.
    You’ll have also gained an understanding of how basic SIEM technologies manage
    data on the analyst side of things and how that data flows and is stored.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Install Elasticsearch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Install Kibana and integrate it with Elasticsearch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Install and integrate Logstash
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You should be using the same device that you completed [*Chapter 3*](B21223_03.xhtml#_idTextAnchor052)
    with. However, the demands for Elasticsearch are more stringent. You can work
    with less RAM than stated here, but it will be sluggish. Here are the requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Minimum requirements**: A computing device with either the *amd64 (x86_64/64-bit)*
    or *i386 (x86/32-bit)* architecture. It should contain at least *8 GB of RAM*
    and an additional *10 GB* of disk space. Note that these minimum requirements
    are known to cause significant performance issues, so you should aim to meet or
    exceed the recommended requirements for a stress-free experience.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Recommended requirements**: Based on feedback from cybersecurity field practitioners,
    aim for the *amd64 (x86_64/64-bit)* architecture with *16 GB of RAM* – more is
    better – and up to *64 GB* of additional disk space.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Elasticsearch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We learned a lot about the functionality of Elasticsearch in [*Chapter 2*](B21223_02.xhtml#_idTextAnchor039).
    Namely, we discovered that it’s an enhanced type of database for enriched SIEM
    information. Now that we’ve set up our Kali Purple operating system within a **virtual
    machine** (**VM**), what do you say we go out and grab ourselves a real copy of
    this famed Elasticsearch, and then install and configure it so that we can play
    with it?
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to go back to [*Chapter 3*](B21223_03.xhtml#_idTextAnchor052) if you
    need a refresher on how to get up and running, as well as log in. Otherwise, start
    by opening VirtualBox and selecting the Kali Purple VM we’ve created. Assuming
    you’ve done no renegade independent adjustments on your own since then, that should
    be the only VM you have available to select at this time. Highlight it and click
    the **Start** button near the top-right of the window. Enter the credentials you
    created in [*Chapter 3*](B21223_03.xhtml#_idTextAnchor052) for your non-administrative
    account and click **Log In** to get yourself into the Kali Purple environment.
    Once there, select the small black square/rectangle on the top navigation pane
    to bring up a terminal window. You should now have a command prompt that includes
    your username to work with.
  prefs: []
  type: TYPE_NORMAL
- en: Begin by typing **sudo apt update** and take note of the number of packages
    the terminal says you have available for upgrading. You must do this because after
    taking the next step, you will run this command again as a measure of quality
    control to ensure your upgrades are successful. The second time, that number should
    be significantly lower and possibly even zero.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is best practice to update and upgrade packages with each Linux boot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – sudo apt update](image/B21223_04_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – sudo apt update
  prefs: []
  type: TYPE_NORMAL
- en: Bear in mind that this command doesn’t update your packages. It only fetches
    a list of available updates. It is good form to follow this command by updating
    the available packages. To perform the actual update, you must type **sudo apt
    upgrade**. However, make sure you do this after you run the update command; otherwise,
    any new packages will not be found and updated! The very first time you perform
    this action, it could take a significant amount of time, depending on the number
    of packages you have to upgrade. As shown in *Figure 4**.1*, there were over 800
    packages with upgrades available!
  prefs: []
  type: TYPE_NORMAL
- en: Once the upgrade is complete, you will want to run the original **sudo apt update**
    command again. There may still be some packages with upgrades available, especially
    after your very first time doing this. This is because of the way some software
    teams develop improvements for their product. Sometimes, software teams will push
    out an update that only builds upon the previous update and is not an all-inclusive
    upgrade. This means that you must install a previous update first before installing
    the most recent update. Some software teams will ensure that every upgrade is
    standalone and can be applied after the initial installation. There’s no rhyme
    or reason to this other than the development and packaging methodology that’s
    used by any organization’s software team.
  prefs: []
  type: TYPE_NORMAL
- en: Lather. Rinse. Repeat. When you are satisfied with your total package upgrades,
    you will want to ensure any configuration or other changes made by any of those
    applications are recognized by your system. So, type **systemctl daemon-reload**.
  prefs: []
  type: TYPE_NORMAL
- en: This command causes systemd to re-read its configuration files and reload the
    unit files. **Systemd** is a system and service manager for Linux operating systems
    that is responsible for controlling and managing the operating system, including
    processes, services, and attached devices. Any time you modify any configuration
    or unit files, you will want to run the preceding **daemon-reload** command to
    cause those modifications to be applied. In short, the command makes systemd aware
    that those changes were made. It’s a good habit to run this command after each
    major step of installing and/or configuring a new application or application suite.
    Doing so can prevent the frustrations of troubleshooting conflict resolution or
    why certain expected results aren’t happening.
  prefs: []
  type: TYPE_NORMAL
- en: Elasticsearch may already be installed by default, depending on what level of
    experimenter you are or have been in the past. If so, it just needs to make some
    configuration changes. In the odd chance it isn’t, you can type **sudo apt install
    elasticsearch**. However, try the following commands to see if it’s already installed.
    If they execute, then that means it was.
  prefs: []
  type: TYPE_NORMAL
- en: To enable Elasticsearch to start up upon booting, type **sudo systemctl** **enable
    elasticsearch**.
  prefs: []
  type: TYPE_NORMAL
- en: The benefit of not having this service automatically start upon booting, as
    you might have guessed, is performance and potentially quicker loading of the
    environment. Just remember that if you choose not to enable Elasticsearch, you
    will have to manually start it each time you boot your Kali Purple instance. You
    can do that by running the **sudo systemctl start** **elasticsearch** command/
  prefs: []
  type: TYPE_NORMAL
- en: 'Record the initial password and note the password reset and token generation
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – Initial Elasticsearch configuration](image/B21223_04_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – Initial Elasticsearch configuration
  prefs: []
  type: TYPE_NORMAL
- en: If you haven’t started Elasticsearch in this instance, go ahead and do that
    now before proceeding to the next step. As highlighted in *Figure 4**.2*, you
    will want to take note of the default password because this is the only time it
    will be provided to you. Also, record the commands that are needed to change the
    password, if you so choose, and grab tokens for integrating Kibana with Elasticsearch.
  prefs: []
  type: TYPE_NORMAL
- en: Type **sudo systemctl status elasticsearch** to view the status of Elasticsearch.
  prefs: []
  type: TYPE_NORMAL
- en: 'Its status will show as **Active** if it’s running. You can press *Ctrl* +
    *Z* to break out of the status screen if needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – Status of Elasticsearch](image/B21223_04_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – Status of Elasticsearch
  prefs: []
  type: TYPE_NORMAL
- en: 'Elasticsearch will bind to localhost (IP address **127.0.0.1**) by default.
    If you want to access it remotely, you’ll want to configure it so that it binds
    to a different IP address. Do this by opening the configuration file using the
    nano text editor. Type **sudo nano /etc/elasticsearch/elasticsearch.yml** and
    look for the line that starts with **network.host** so that you can uncomment
    it by removing **#** at the beginning. You can use the arrow keys on your keyboard
    to physically navigate any file opened with the nano file editor. Even though
    the localhost IP of **127.0.0.1** that we are using for our example is a default,
    it’s good practice to still manually type that address in the **network.host**
    setting and uncomment it. That will establish a good habit of making sure you
    know where to go and adjust the setting. If you want that setting to bind to all
    interfaces, set it to **network.host: 0.0.0.0**, then save the changes before
    exiting the editor. This is virtually automatic since nano prompts you to save
    when you press *Ctrl* + *X* to leave the editor. Since adjusting this line created
    a new configuration change, you must type **sudo systemctl** **restart elasticsearch**.'
  prefs: []
  type: TYPE_NORMAL
- en: Open a web browser and point it to [https://localhost:9200](https://localhost:9200)
    while paying particular attention to the *s* after *http*. You can find an icon
    for the Firefox web browser in the top-left menu. It is critical to notice this
    detail because when you load Elasticsearch through the Kibana interface later,
    you will not include the *s*. The *s* stands for secure and it is there because
    all Elasticsearch versions after 8.0 distributed with security toggled on as a
    default setting. In this case, that means **Secure Socket Layer** (**SSL**) and
    **Transport Security Layer** (**TLS**) will be required for any HTTP protocol
    – browser – communications. While you certainly could turn security off, we’ll
    skip that walkthrough here because it’s simply not necessary for what we’re doing,
    not to mention discouraged.
  prefs: []
  type: TYPE_NORMAL
- en: If you provide the proper URL, your browser will initially display a security
    error, as shown in *Figure 4**.4*; that is a result of security being toggled
    on. There will either be a blue **Learn more…** link at the bottom left, an **Advanced...**
    button at the bottom right, or both. You should be able to select either one of
    those and be presented with an option to **Accept the Risk and Continue**. If
    one doesn’t give you that option, then the other will. It is perfectly okay to
    accept the risk in this instance because you’re attempting to connect to your
    own self and unless you have a hidden personality lurking somewhere inside your
    brain, you should be acutely aware that you’re not a threat to yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Select **Learn more…** or **Advanced…** and then **Accept the Risk and Continue**.
    A login popup will appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – Elasticsearch – initial web access](image/B21223_04_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 – Elasticsearch – initial web access
  prefs: []
  type: TYPE_NORMAL
- en: Once you accept the risk, the browser will display a popup where you can enter
    the Elasticsearch superuser – which is simply the word **elastic** and the default
    password that you recorded earlier when you ran Elasticsearch for the first time.
    If for some reason you forgot to record that password, you can return to the command-line
    terminal and request a new one by typing **sudo /usr/share/elasticsearch/bin/elasticsearch-reset-password
    -u elastic**, where **-u** identifies the next word in the command as the username
    and **elastic** is the username of the superuser. You will be asked for your sudo
    password before it issues you a new Elasticsearch password. Make sure you are
    in the default home directory when you type that command. You can type **cd**
    to return home if you aren’t. You can type **pwd** to see where in the default
    filesystem you are located. It should return something like **/home/<username>**,
    where **username** is the account name you created for your non-administrative
    Kali Purple account. If it doesn’t, you aren’t in the home directory. Alternatively,
    you can navigate directly to the **/usr/share/elasticsearch/bin/** directory using
    the **cd** command. Once there, you only need to type **elasticsearch-reset-password
    -u elastic** to reset your password.
  prefs: []
  type: TYPE_NORMAL
- en: Now, be prepared to be underwhelmed. If you’ve entered the correct credentials,
    a simple web page will load, showing your default Elasticsearch cluster in JSON
    format. If you look closely at the top left of this new display, you will see
    additional tabs to display the same data in raw format or to peek at the page
    header.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, why on Earth did we put you through all this torturous effort just to show
    a few lines of text on your screen? There are three reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: Rumor has it that pulling you apart at the rack is now illegal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You get a visual confirmation that your Elasticsearch installation was successful
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You’ll appreciate the Kibana graphic interface that much more once we install
    it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With that, you now understand why we are going to install the ELK stack as an
    EKL stack. We are going to completely disrespect the ELK acronym and do this our
    own rebellious way. Installing and configuring Elasticsearch first is the only
    true necessary order of precedence but installing these items the way we are going
    to covers the dependencies each product has on others. So, there is a method to
    our madness.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re the gambling type and decide to install your items in an order we
    don’t present here, be prepared to encounter additional errors and challenges.
    That’s not an instruction for you not to do so, however. Some engineering personality
    types will purposely do things that way for the sheer enjoyment of learning by
    creating problems to solve. Others will do it because they are non-conformists
    by nature and simply don’t like to be told what to do. Both types are loved and
    welcomed in the Kali Purple community! If either of these apply to you, we hereby
    validate your feelings. It’s folks like you who help others learn. Please share
    your lessons in community forums. It will help and empower others to discover
    and process the finer details.
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, this is an introductory process and because this is introductory,
    you shouldn’t need to concern yourself with those finer details at this point
    if you don’t wish to. It’s something you will still discover as time goes on and
    you become more adept at using these products. Onward to Kibana!
  prefs: []
  type: TYPE_NORMAL
- en: Kibana
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For Kibana to have any real value here, it’s mission-critical that you have
    first installed Elasticsearch. As we have already discussed, that’s the most important
    order of operations for installing and configuring the ELK stack. Assuming you’ve
    done that, we’ll proceed with the best practice of updating the package index.
  prefs: []
  type: TYPE_NORMAL
- en: Begin by typing **sudo apt update** to get a list of packages that have updates
    available. Whether you choose to perform the update or not is up to you. It’s
    good form to do so but certainly not required. To perform the update, you must
    type **sudo apt upgrade** after the previous command has finished executing.
  prefs: []
  type: TYPE_NORMAL
- en: Then, as a best practice, you will also want to type **systemctl daemon-reload**
    just to develop the habit of doing so. This will ensure any configuration changes
    you’ve made that you might have forgotten about are first recognized by systemd
    before restarting the services. Then, you will want to restart the services you’ve
    used since your last package to apply any such changes to the service. In this
    case, the only service we’ve worked with so far is Elasticsearch. So, the command
    you seek is **sudo systemctl restart elasticsearch**. Don’t forget to type **sudo
    systemctl status elasticsearch** after the command prompt returns to verify that
    Elasticsearch did, indeed, start and is active.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can grab Kibana by typing **sudo apt install kibana**. As we did with
    Elasticsearch, we can enable Kibana to automatically start up upon booting by
    typing **sudo systemctl** **enable kibana**.
  prefs: []
  type: TYPE_NORMAL
- en: To start Kibana, type **sudo systemctl** **start kibana**.
  prefs: []
  type: TYPE_NORMAL
- en: To verify the status and ensure Kibana is successfully running, type **sudo
    systemctl** **status kibana**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Kibana will show as active if it’s been installed and started correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – Kibana status with the initial login URL and verification code](image/B21223_04_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5 – Kibana status with the initial login URL and verification code
  prefs: []
  type: TYPE_NORMAL
- en: If the status does not return to the command prompt promptly, you can hold down
    *Ctrl* + *Z* to forcefully break out of the status screen. The next step, as suggested
    near the bottom of *Figure 4**.5*, is to load a browser, as we did with Elasticsearch.
    However, this time, we’re using a different port number and we’re also leaving
    the *s* off the end of http.
  prefs: []
  type: TYPE_NORMAL
- en: While best practices suggest that Kibana should also use the secure HTTPS protocol,
    it is configured to use the HTTP protocol by default for performance reasons.
    Kibana, being a visual utility, is heavy on CPU resources by default. For the
    data to be compromised, it would have to be intercepted between Kibana and Elasticsearch,
    which are usually both located within the same internal network. Elasticsearch,
    in contrast, can be receiving data externally, from data shippers and agents outside
    of your network, so the data is far more vulnerable, making a default security-on
    approach more practical and necessary.
  prefs: []
  type: TYPE_NORMAL
- en: This subtle discrepancy often tends to cause confusion among first-time ELK
    stack users/installers. Just remember that for any part of this process, if you
    get hung up or if you’re simply the experimental type and like to color outside
    the lines by doing things we haven’t talked about, you can inspect any error messages
    regarding Elasticsearch, Kibana, or Logstash by using the change directory command.
    To do so, navigate to the file by typing **cd /var/log/**; then, once in the directory,
    type **ls** to view the available log file options. Each application that you
    have installed up to that point should have a file listed in that directory. To
    view any particular file, type **cat <filename>**. So, to view Kibana logs, you
    would type **cat Kibana**. Replace the word **Kibana** with the filename of whichever
    log you’d like to view out of the options presented when you typed **ls**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The verification code shown at the bottom of *Figure 4**.5* will not be shown
    on that screen if you haven’t yet loaded the Kibana interface in a web browser
    and entered the enrollment token. That token may have been provided to you during
    Elasticsearch’s and/or Kibana’s initial startup. However, if you missed it, you
    can create a new one by going into the command line and typing **sudo /usr/share/elasticsearch/bin/elasticsearch-create-enrollment-token
    -s kibana**. A very long and obscure alphanumeric code will print to your terminal
    screen. Select and copy that code before pasting it into the **Enrollment token**
    box that appears in your browser the first time you load Kibana, as seen in *Figure
    4**.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6 – First Kibana browser instance asking for the enrollment token](image/B21223_04_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.6 – First Kibana browser instance asking for the enrollment token
  prefs: []
  type: TYPE_NORMAL
- en: Load your browser and either point it to http://localhost:5601/?code=<VERIFICATION_CODE>,
    where **VERIFICATION_CODE** is what your screen shows instead of **754098**, which
    is shown in *Figure 4**.5*, or point it to the simpler [http://localhost:5601](http://localhost:5601);
    the browser will prompt you to enter the code manually. Either way, you’ll get
    the same result. If you forget the verification code, you can type **sudo systemctl
    status kibana** to view it again at the bottom of the output.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: When you first launch a browser session after installing and starting Kibana,
    you will likely get your first test of computing resources. If at this point or
    any point hereafter you find that your VM’s performance is sluggish, you’ll be
    happy to know that you can adjust the memory, CPU, and other resources you allocated
    to the VM when you first created it.
  prefs: []
  type: TYPE_NORMAL
- en: In VirtualBox, this can be done by powering down your VM and selecting **Settings**
    from the Oracle VM VirtualBox Manager lobby screen (the first screen that loads
    when you launch VirtualBox). Keep in mind that the **Settings** button will address
    whichever VM you have selected, should you have more than one VM. Alternatively,
    you can right-click on your desired VM and select **Settings** from that angle.
  prefs: []
  type: TYPE_NORMAL
- en: The two tabs in the resulting left column that are most likely pertinent to
    your performance are **System** and **Display**. From within those two areas,
    you can adjust your processing power, RAM, video RAM, and more. It is paramount
    that you do not try to allocate more resources to your VM than your host machine
    has available, considering other applications outside of your virtualization software.
  prefs: []
  type: TYPE_NORMAL
- en: We provided instructions for VirtualBox because that’s what we’ll be using in
    this book. However, nearly any virtualization software will have the same options
    available. It would be impractical for us to provide instructions for each of
    the virtualization applications on the market. However, the skill of independent
    research is expected of a security professional. A simple Google or other search
    engine inquiry asking how to adjust resource allocation with your brand of virtualization
    software should more than suffice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you’ve confirmed your verification code, addressed any performance and/or
    VM settings, and logged in to the Kibana interface using the same Elastic credentials
    you used for Elasticsearch, you will be presented with a screen giving you the
    option to **Add integrations** or **Explore on my own**. Go ahead and select the
    **Add integrations** button and prepare to feel like a rich kid in an overstocked
    candy store:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7 – Kibana’s visual lobby upon logging in to Elasticsearch](image/B21223_04_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.7 – Kibana’s visual lobby upon logging in to Elasticsearch
  prefs: []
  type: TYPE_NORMAL
- en: You will be presented with over 350 options of potential Kibana integrations.
    Just above the **All categories** column on the left, you’ll see the option to
    **Browse integrations**. This should be highlighted in blue to indicate you are
    currently at that location. Just to the right of that, you will see a black **Installed
    integrations** option, which is meant to catalog any integrations you might have
    already installed. Go ahead and click **Installed integrations**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Kibana offers 350+ stable integrations – approximately 400 if you select the
    **Display beta** **integrations** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8 – Kibana’s Integrations page](image/B21223_04_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.8 – Kibana’s Integrations page
  prefs: []
  type: TYPE_NORMAL
- en: You will see that you already have an item installed called **Elastic Synthetics**.
    This is the core Elastic agent that is installed by default. Each time you add
    a new integration, it will appear in this list. Return to **Browse integrations**
    and take some time to play around with some or all those options.
  prefs: []
  type: TYPE_NORMAL
- en: 'If for some reason you back yourself into a corner, you can utilize the following
    command sequence to remove Kibana:'
  prefs: []
  type: TYPE_NORMAL
- en: Type **sudo systemctl** **stop kibana**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type **sudo systemctl** **disable kibana**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type **sudo apt** **remove kibana**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type **sudo apt** **purge kibana**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Purging will attempt to clean up any residual configuration files so that you
    don’t have unexpected discrepancies on any future installations.
  prefs: []
  type: TYPE_NORMAL
- en: This same process works for Elasticsearch and Logstash as well, should you decide
    to start over on any of these utilities. You can simply substitute the names of
    those applications with **kibana** in the commands listed earlier. Should you
    feel confident and playful, it might not be a bad idea to install and uninstall
    some of these items several times anyway just to get a feel for the process. Repetition
    is the mother of all learning and practical application is the father. Here, you’re
    getting both.
  prefs: []
  type: TYPE_NORMAL
- en: Amid your well-deserved gloating of having successfully installed Elasticsearch
    and Kibana, you might have noticed that, in the **Browse integrations** section,
    you have the option to install Logstash from within the Kibana environment. We’ll
    cover that in the next chapter, which focuses on acquiring the data we will be
    running through the ELK stack. Graphically adding Logstash comes with the option
    of adding the Elastic agent – an alternative to Beats. For the sake of consistency
    and developing a necessary skill regarding command-line work, we are going to
    install Logstash from the command line in the next section. We’re on a roll! So,
    let’s charge forward with Logstash.
  prefs: []
  type: TYPE_NORMAL
- en: Logstash
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may have already done so but since we don’t know when you will take a break
    from reading this, we will continue to develop the best practice habit of updating
    your package lists before every single new installation, just like we did when
    we transitioned from Elasticsearch to Kibana.
  prefs: []
  type: TYPE_NORMAL
- en: Begin by typing **sudo apt update**. If you’re new to working within a Linux
    environment, you might have noticed by now that even with the frequency of us
    utilizing this command, there is an almost constant stream of new updates for
    one thing or another. If you haven’t experienced this yet, then that just means
    you’re working at a quick pace and covering a lot of ground at once. There’s nothing
    wrong with that but don’t let it fool you. The first time you step away for a
    day or two, you’ll come back and run this command to find there are new package
    updates available. That’s why we will make a habit of running it after every package
    installation and every time we log on to our Kali Purple system.
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and plop a **sudo apt update** command in there, followed by **sudo
    apt upgrade** to update your packages if you’re willing. Then, type **systemctl
    daemon-reload**. This isn’t something you necessarily need to do with every logon
    but it should be a habit when you’re in the midst of a project that involves having
    to install and configure a lot of new packages – as we are now.
  prefs: []
  type: TYPE_NORMAL
- en: Logstash is one of the applications we spoke of in [*Chapter 3*](B21223_03.xhtml#_idTextAnchor052)
    that requires the **Java Development Kit** (**JDK**). If you followed the directions
    in that chapter, then you already have it installed. Otherwise, you might wish
    to peek back near the end of that chapter and get it taken care of. It’s quick
    and painless.
  prefs: []
  type: TYPE_NORMAL
- en: Begin installing Logstash by typing **sudo apt** **install logstash**.
  prefs: []
  type: TYPE_NORMAL
- en: Set Logstash to automatically start upon system boot by typing **sudo systemctl
    enable logstash**. If you ever wish to adjust this setting for any of the applications
    you’ve set to automatically start thus far, you can simply type **sudo systemctl
    disable logstash** – a command you were briefly introduced to at the end of the
    previous section – to set it to manually start. This means you will have to manually
    turn it on every time you boot your system by running the start command.
  prefs: []
  type: TYPE_NORMAL
- en: Start the Logstash service by typing **sudo service logstash start**. Next,
    you will want to verify the status and ensure Logstash is successfully running
    by typing **sudo systemctl status logstash**. When ready and if needed, press
    *Ctrl* + *Z* to break out of the status screen.
  prefs: []
  type: TYPE_NORMAL
- en: Now, because one of Logstash’s primary functions is dependent upon moving data,
    we need to test it out and make sure the pipeline for doing so is functioning
    as expected. We will do that by going into Logstash itself, creating a basic pipeline,
    typing a command, and examining whether that command was taken and processed by
    Logstash. It’s simpler than it sounds. Using the **change directory** (**cd**)
    command, navigate to the Logstash installation. To get there, type **cd /usr/share/logstash**.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re uncertain of yourself, you can use the **print working directory**
    (**pwd**) command after you type the preceding command to verify your location.
    Type **pwd**; it should return **/usr/share/logstash**. Before you attempt to
    open the pipeline, you will want to ensure you and any other applications trying
    to access Logstash have the ability and permissions to do so. Type **sudo chmod
    -R 777 /usr/share/logstash/data** to set the correct permissions for the entire
    file path. From that location, open a pipeline within the Logstash application
    by typing **bin/logstash -e ''input { stdin {} } output { stdout {} }''** while
    paying particular attention to the single quote and braces instead of parenthesis.
    Wait a few moments for the pipeline to open. You’ll know this was successful when
    your terminal delivers some text stating that the main pipeline or Java pipeline
    has started, as seen in *Figure 4**.9*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.9 – Logstash – basic Java pipeline](image/B21223_04_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.9 – Logstash – basic Java pipeline
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: During this process, you may notice some warnings. You can safely ignore these
    if you followed our lead exactly. Those warnings are there with a valid purpose,
    but the machine has no way of knowing that we are installing and configuring these
    applications for the first time. They should go away after the ELK stack has been
    fully configured and is functional.
  prefs: []
  type: TYPE_NORMAL
- en: The exact text that’s returned to you might vary depending on which version
    of Logstash you have installed since the product is actively updated and will
    continue to be long after this book goes to press. Sometimes, this process takes
    a while to set itself up in the background properly. If you encounter an error,
    wait a few minutes and type the command again. It has been reported by testers
    that simply having to wait and re-enter the command has been necessary. In the
    previous command, everything after **-e** is the command to open the pipeline.
    This **-e** tells Kali that it’s okay for us to attach this command to Logstash
    and execute it in one statement at the command line. Programmers and software
    engineers, especially those of you who’ve worked with the C family of languages,
    will recognize **stdin** and **stdout** as core functions for managing input and
    output. They stand for **standard input** and **standard output**, respectively.
    The command is more or less telling Logstash to take the input it is about to
    receive and process it as output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s test this new pipeline we’ve opened within Logstash by typing **I
    love Kali Purple** within our terminal window. If Logstash was installed correctly,
    started without error, and the pipeline from the previous step was set up correctly,
    then you should see that a timestamp has been added and the output has been returned
    to you, as seen in *Figure 4**.10*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.10 – Logstash’s successful input/output processing](image/B21223_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.10 – Logstash’s successful input/output processing
  prefs: []
  type: TYPE_NORMAL
- en: Press *Ctrl* + *D* to break out of Logstash and return to your command prompt.
    One last task you must complete is to configure Logstash so that it can index
    your data within Elasticsearch.
  prefs: []
  type: TYPE_NORMAL
- en: '*“But Karl, I have no data!”* I hear ya. I feel the same way every morning
    until about my second or third cup of coffee. In the next chapter, we will focus
    on acquiring the data and passing it through the ELK stack using Beats and sample
    datasets. For now, though, we are simply setting the tools up for use.'
  prefs: []
  type: TYPE_NORMAL
- en: To configure Logstash to index your data within Elasticsearch, you will want
    to use the **cd** function to navigate to the Logstash home folder. To do that,
    type **cd /etc/logstash**. There are many ways to accomplish this Elasticsearch
    indexing goal, but we don’t know what future iterations of these applications
    will be. We also have no clue whether you leave your Kali Purple instance completely
    exposed while you walk your dog so that prankster teenagers can delete your files.
    Therefore, we are going to show you the bare-bones, from-scratch, effort-exerting,
    sweat-producing method first.
  prefs: []
  type: TYPE_NORMAL
- en: To do so, you need to create a pipeline file; within that file, you must identify
    where your input is coming from, any special filters (both in the next chapter),
    and where your output is going. Type **sudo touch learning-purple.conf** to create
    the file and then use the list command – **ls** – to verify that your file exists
    in the directory. If it isn’t, it’s likely the result of a typo, so try again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once it’s been created, we can edit the file with nano. Type **sudo nano learning-purple.conf**
    while in the same directory to open the newly created and completely blank file.
    If you’re no longer in the directory, either navigate to it or prepend the previous
    command with the **/etc/logstash/** filepath. If you’re unfamiliar with that term,
    think of the word append. If you’re appending something, you’re adding to the
    end of it. An appendix in a book, for example, means you’re adding an index at
    the end. In this case, prepend means you’re adding to the beginning of something
    – you’re adding the file before the previous command: **sudo nano /etc/logstash/learning-purple.conf**.
    That’s a free bonus lesson that has nothing to do with Kali Purple or the ELK
    stack because you’ll likely encounter that term again throughout your cybersecurity
    career. Once the file is open, insert the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding scenario, make sure you substitute **ElasticSuperUserPassword**
    with the password you received and/or created when you launched Elasticsearch
    for the very first time. This will be the same password you used to log in to
    Kibana for the first time, helping Kibana to integrate with Elasticsearch.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that if you change this password at any time, you will have to
    go through each application that is integrated with Elasticsearch manually and
    update their configuration files, lest they no longer be able to access Elasticsearch
    to do their job!
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This type of non-human authentication is what is generally referred to as a
    **service account** in the world of technology. You will want to study more about
    service accounts, especially well-known service accounts, as a cybersecurity analyst
    because having that knowledge may help you to examine security alerts to determine
    what’s occurring. One popular service account you are likely to see frequently
    is called **NT AUTHORITY\SYSTEM**. This is a built-in Windows user account that
    contains the absolute highest level of system privileges on a Windows operating
    system. It is created during the initial installation of a Windows operating system
    and is used to integrate services and processes within. That makes it a ripe target
    for bad actors and why its presence in a security alert justifies a deeper analysis.
  prefs: []
  type: TYPE_NORMAL
- en: 'Press *Ctrl* + *X* and select *Y* if prompted to save and close the file we
    just created. Now, our job isn’t done quite yet. We want to perform a configuration
    validation and syntax check of our newly created file. With the following command,
    make sure you use two tack symbols (minus signs) before the term **--path.config**
    but elsewhere leave only one. Enter the following behemoth of a command into your
    terminal all on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Be patient. This may take a minute or two to complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'Logstash has a built-in configuration file validator and syntax checker:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.11 – The configuration file passes validation](image/B21223_04_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.11 – The configuration file passes validation
  prefs: []
  type: TYPE_NORMAL
- en: Another method of setting up Logstash to report its data to Elasticsearch for
    indexing would be to edit **logstash-sample.conf** if you have one in your version
    of the product. It can be found in the same directory where we created **learning-purple.conf**.
    It is a best practice, however, not to edit default sample files in any technology
    but rather make a copy of them and edit the copy. That way, you always have a
    fresh unaltered original to work from if you make a mistake.
  prefs: []
  type: TYPE_NORMAL
- en: The format of the command to copy a file is **sudo cp <originalFile><newFileCopy>**
    if you’re in the same directory. For example, **sudo cp logstash-sample.conf logstash-sample-two.conf**
    will create a new file named **logstash-sample-two.conf** that will have identical
    contents to **logstash-sample.conf**. If you aren’t inside that directory, then
    you must prepend the file path for each file within the command – for example,
    **sudo cp /etc/logstash/logstash-sample.conf /etc/logstash/logstash-sample-two.conf**.
    You should do this even if you want the file copy to reside in the same directory
    as the original (otherwise, the copy will be placed inside the directory where
    you’re currently residing).
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that you still need to edit the new file and add the credentials
    for the Elastic service account. You will also want to ensure you remove any **#**
    symbols in front of the lines for the user and password so that the file can be
    read. Otherwise, the **#** symbols tell Logstash to ignore everything that comes
    after it on the line because whatever information might be there is meant for
    humans only, not machines. This convention allows developers and users of the
    application to read the files and understand what’s going on. The addition of
    such comments is considered a best practice for coding and/or scripting and is
    highly encouraged.
  prefs: []
  type: TYPE_NORMAL
- en: The ELK stack is not exclusive to Kali Purple. It is cross-platform-compatible
    and available in many different formats, including cloud-hosted. However, this
    book is about Kali Purple and our focus with the ELK stack is going to be how
    it relates to Kali Purple. Keep in mind that this is only one small piece of the
    overall Purple puzzle. Once we’ve finished configuring the ELK stack and have
    it running by the end of the next chapter, we will transition to other Kali Purple
    tools in future chapters. Those tools will integrate with the ELK stack and provide
    us with our full SOC solution.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered how to install and configure the three key components
    of the ELK stack. These components work together to receive, enrich, index, and
    display what data analysts need to do their jobs. Along the way, we learned about
    a bunch of related useful information that is likely to be seen again and again
    as you progress through your cybersecurity career.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we learned about some best practices, such as updating and upgrading after
    each new system boot and adding human-readable comments to code and configuration
    files. We also covered how to view the status of the applications after we start
    them, along with a bunch of commands to manipulate them, such as setting them
    to autostart upon boot and how to stop, disable, and remove them if needed.
  prefs: []
  type: TYPE_NORMAL
- en: These tasks provided us with a robust skill set to manipulate the ELK stack’s
    components so that they fit our needs. That includes our experiences testing our
    configurations and how to integrate the components using a service account.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’re going to take this a step further and learn about
    some additional components of the ELK stack that are meant to collect the data
    we need and ship it to us. We’ll learn how to deploy these endpoint agents and
    set up a Logstash filter for data enrichment. We will also grab a sample set of
    data to run through our new SIEM system and finally begin to see it working as
    a full unit!
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Answer the following questions to test your knowledge of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Which ELK stack component covered in this chapter relies on the JDK we installed?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Kibana
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Elasticsearch
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Logstash
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True or false: Logstash can be installed through the Kibana GUI.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'False'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the significance of the password that’s provided during the very first
    Elasticsearch run?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is a service account password that’s used to integrate the ELK stack components
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: It can never be changed
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: It’s used to integrate the ELK stack components but is not technically a service
    account
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: It can be changed a maximum of four times.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the primary function of a service account?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It manages running background services
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: It’s a non-human account to assist applications integrating with each other
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: It holds services accountable for their actions
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: It sends you an automated text to notify you when your car is due for an oil
    change
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the default port Elasticsearch binds to?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**5601**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**5400**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**9201**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**9200**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following commands cleans up residual configuration files?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**sudo apt** **purge <package>**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**sudo apt** **remove <package>**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**sudo apt** **disable <package>**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**sudo apt** **disintegrate <package>**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Elasticsearch** **guide**: [https://www.elastic.co/guide/en/elasticsearch/reference/current/index.xhtml](https://www.elastic.co/guide/en/elasticsearch/reference/current/index.xhtml)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kibana** **guide**: [https://www.elastic.co/guide/en/kibana/current/index.xhtml](https://www.elastic.co/guide/en/kibana/current/index.xhtml)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Logstash** **guide**: [https://www.elastic.co/guide/en/logstash/current/index.xhtml](https://www.elastic.co/guide/en/logstash/current/index.xhtml)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
