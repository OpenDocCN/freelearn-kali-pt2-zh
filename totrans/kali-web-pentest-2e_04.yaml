- en: Testing Authentication and Session Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Username enumeration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dictionary attack on login pages with Burp Suite
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Brute forcing basic authentication with Hydra
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attacking Tomcat's passwords with Metasploit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manually identifying vulnerabilities in cookies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attacking a session fixation vulnerability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Evaluating a session identifier's quality with Burp Sequencer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abusing insecure direct object references
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing a Cross-Site Request Forgeryattack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the information managed by an application is not meant to be public, a
    mechanism is required to verify that a user is allowed to see certain data; this
    is called **authentication**. The most common authentication method in web applications
    nowadays is the use of a username or identifier and a secret password combination.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP is a stateless protocol, which means it treats all requests as unique and
    doesn't have a way of relating two as belonging to the same user, so the application also requires
    a way of distinguishing requests from different users and allowing them to perform
    tasks that may require a series of requests performed by the same user and multiple
    users connected at the same time. This is called **session management**. Session
    identifiers in cookies are the most used session management method in modern web
    applications, although bearer tokens (values containing user identification information
    sent in the `Authorization` header of each request) are growing in popularity
    in certain types of applications, such as backend web services.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will cover the procedures to detect some of the most common
    vulnerabilities in web application authentication and session management, and
    how an attacker may abuse such vulnerabilities in order to gain access to restricted
    information.
  prefs: []
  type: TYPE_NORMAL
- en: Username enumeration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step to defeating a common user/password authentication mechanism
    is to discover valid usernames. One way of doing this is by enumeration; enumerating
    users in web applications is done by analyzing the responses when usernames are
    submitted in places such as login, registration, and password recovery pages.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will use a list of common usernames to submit multiple requests
    to an application and figure out which of the submitted names belongs to an existing
    user by comparing the responses.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, we will use the WebGoat application in the vulnerable virtual
    machine `vm_1` and Burp Suite as proxy to our browser in Kali Linux.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Almost all applications offer the user the possibility of recovering or resetting
    their password when it is forgotten. It''s not uncommon to find that these applications
    also tell when a non-existent username has been provided; this can be used to
    figure out a list of existing names:'
  prefs: []
  type: TYPE_NORMAL
- en: From Kali Linux, browse to WebGoat (`http://192.168.56.11/WebGoat/attack`),
    and, if a login dialog pops up, use `webgoat` as both the username and password.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once in WebGoat, go to Authentication Flaws | Forgot Password. If we submit
    any random username and that user does not exist in the database, we will receive
    a message saying that the username is not valid:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/8baf0541-9d22-4eae-a1bd-d8d3450adbbf.png)'
  prefs: []
  type: TYPE_IMG
- en: We can then assume that the response will be different when a valid username
    is provided. To test this, send the request to Intruder. In Burp's history, it
    should be a `POST` request to `http://192.168.56.11/WebGoat/attack?Screen=64&menu=500`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once in Intruder, leave the username as the only insertion position:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/7940ce04-40fa-4c6a-8e5b-2a525323630e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, go to Payloads to set the list of users we will use in the attack. Leave
    the type as Simple List and click on the Load button to load the `/usr/share/wordlists/metasploit/http_default_users.txt` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/69138945-5c36-470a-baef-923c662c94d1.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we know the message when a user doesn't exist, we can use Burp to tell
    us when that message appears in the results. Go to Options | Grep - Match and
    clear the list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a new string to match `Not a valid username`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/3287dab6-be24-4047-b142-0aaade525fe4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, start the attack. Notice how there are some names, such as `admin`, in
    which the message of an invalid username is not marked by Burp Suite; those are
    the ones that are valid names within the application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/40ce6475-0bee-45ef-b7f6-e7ffa5428302.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we are testing a web application that requires a username and password to
    perform any task, we need to evaluate how an attacker could discover valid usernames
    and passwords. The slightest difference in responses to valid and invalid users
    in the login, registration, and password recovery pages will let us find the first
    piece of information.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing the differences in responses to similar requests is a task we will
    always be performing as penetration testers. Here, we used Burp Suite's tools,
    such as a proxy to record the original request, and Intruder to repeat it many
    times with variations in the value of a variable (username). Intruder also allowed
    us to automatically search for a string and indicated to us in which responses
    that string was found.
  prefs: []
  type: TYPE_NORMAL
- en: Dictionary attack on login pages with Burp Suite
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we have a list of valid usernames for our target application, we can try
    a brute force attack, which tries all possible character combinations until a
    valid password is found. Brute force attacks are not feasible in web applications
    due to the enormous number of combinations and the response times between client
    and server.
  prefs: []
  type: TYPE_NORMAL
- en: A more realistic solution is a dictionary attack, which takes a reduced list
    of highly probable passwords and tries them with a valid username.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will use Burp Suite Intruder to attempt a dictionary attack
    over a login page.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll use the WackoPicko admin section login to test this attack:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we set up Burp Suite as a proxy to our browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Browse to `http://192.168.56.102/WackoPicko/admin/index.php?page=login`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will see a login form. Let's try `test` for both username and password.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, go to Proxy's history and look for the `POST` request we just made with
    the login attempt and send it to Intruder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Clear § to clear the pre-selected insertion positions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we add insertion positions on the values of the two `POST` parameters
    (`adminname` and `password`) by highlighting the value of the parameter and clicking
    Add §:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As we want our list of passwords to be tried against all users, we select Cluster
    bomb as the attack type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/f37456a1-ed4e-4dbf-98c9-111d986b7e3b.png)'
  prefs: []
  type: TYPE_IMG
- en: The next step is to define the values that Intruder is going to test against
    the inputs we selected. Go to the Payloads tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the textbox in the Payload Options [Simple list] section, add the following
    names:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`user`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`john`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`admin`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`alice`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bob`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`administrator`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](assets/8f671aca-19b3-46b5-8c67-4219ef59c898.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, select list 2 from the Payload set box. This list will be our password
    list and we''ll use the 25 most common passwords of 2017 for this exercise ([http://time.com/5071176/worst-passwords-2017/](http://time.com/5071176/worst-passwords-2017/)):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/75f20419-7676-4492-9abf-c82229dd0c6b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Start the attack. We can see that all responses seem to have the same length
    apart from one: the `admin`/`admin` combination has a status 303 (a redirection)
    and a minor length. If we check it, we can see that it''s a redirection to the
    admin''s home page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/b8db4135-d63d-40ca-b63c-980f3a055b8f.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As for the results, we can see that all failed login attempts get the same response,
    but one has status 200 (OK) and that is 813 bytes long in this case, so we suppose
    that a successful one would have to be different, at least in length (as it will
    have to redirect or send the user to their home page). If it transpires that successful
    and failed requests are the same length, we can also check the status code or
    use the search box to look for a specific pattern in responses.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Kali Linux includes a very useful collection of password dictionaries and wordlists
    in `/usr/share/wordlists`. Some files you will find there are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`rockyou.tar.gz`: The RockYou website was hacked in December 2010, more than
    14 million passwords were leaked, and this list includes them. These passwords
    are archived in this file, so you will need to decompress it before using it:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`dnsmap.txt`: Contains common subdomain names, such as `intranet`, `ftp`, or
    `www`; it is useful when brute forcing a DNS server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/dirbuster/*`: The `dirbuster` directory contains names of files commonly
    found in web servers; these files can be used when using DirBuster or OWASP-ZAP''s
    Forced Browse.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/wfuzz/*`: Inside this directory, we can find a large collection of fuzzing
    strings for web attacks and brute forcing files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/metasploit/*`: This directory contains all default dictionaries used by Metasploit
    Framework plugins. It contains dictionaries with default passwords for multiple
    services, hostnames, usernames, filenames, and many others.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Brute forcing basic authentication with Hydra
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: THC Hydra (or simply Hydra) is a network online logon cracker; this means it
    can be used to find login passwords by brute forcing active network services.
    Among the many services Hydra supports, we can find HTTP form login and HTTP basic
    authentication.
  prefs: []
  type: TYPE_NORMAL
- en: 'In HTTP basic authentication, the browser sends the username and password,
    encoded using base64 encoding, in the `Authorization` header. For example, if
    the username is `admin` and the password is `Password`, the browser will encode
    `admin:Password`, resulting in the string `*YWRtaW46UGFzc3dvcmQ=*` and the request
    header will have a line such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Almost every time we see a seemingly random alphanumeric string ending in one
    or two equal to (=) symbols, that string is base64 encoded. We can easily decode
    it using Burp Suite's Decoder or the `base64` command in Kali Linux. The = symbol
    may be encoded to be URL-friendly, that is, replaced by `%3D` in some requests
    and responses.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous recipe, we used Burp Suite's Intruder to attack a login form;
    in this recipe, we will use THC Hydra to attack a different login mechanism, HTTP
    basic authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As well as the password list we used in the previous recipe, in order to execute
    this dictionary attack, we will need to have a username list. We will assume we
    already did our reconnaissance and obtained several valid usernames. Create a
    text file (ours will be `user_list.txt`) containing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the directory where both users and password dictionaries are stored in our
    Kali Linux VM, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a terminal and run `hydra`, or use the Applications menu in Kali Linux
    Applications | 05 - Password Attacks | Online Attacks | Hydra.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Issuing the command without arguments displays the basic help:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/0d2669ca-f425-4b6b-a51a-1ffe33f97b83.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, we can see some useful information for what we want to do. By using the
    `-L` option, we can use a file containing possible usernames. `-P` allows us to
    use a password dictionary. We need to end the command with the service we want
    to attack, followed by `://` and the server, and, optionally, the port number
    and service options.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the terminal, issue the following command to execute the attack:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/edbc5a52-c3d6-45d4-a51b-84fa649fd3aa.png)'
  prefs: []
  type: TYPE_IMG
- en: Hydra found two different username/password combinations that successfully logged
    in to the server.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike other authentication methods, such as the form-based one, basic authentication
    is standard in what it sends to the server, how it sends it, and the response
    it expects from it. This allows attackers and penetration testers to save precious analysis time
    on which parameters contain the username and password, how are they processed
    and sent, and how to distinguish a successful response from an unsuccessful one.
    This is one of the many reasons why basic authentication is not considered a secure
    mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: 'When calling Hydra, we used some parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-L user_list.txt` tells Hydra to take the usernames from the `user_list.txt` file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-P top25_passwords.txt` tells Hydra to take the prospective passwords from
    the `top25_passwords.txt` file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-u`—Hydra will iterate usernames first, instead of passwords. This means that
    Hydra will try all usernames with a single password first and then move on to
    the next password. This is sometimes useful to prevent account blocking.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-e ns`—Hydra will try an empty password (`n`) and the username as password
    (`s`) as well as the list provided.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http-get` indicates that Hydra will be executed against HTTP basic authentication
    using `GET` requests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The service is followed by `://` and the target server (`192.168.56.11`). After
    the next `/`, we put the server's options, in this case the URL where the authentication
    is requested. The port is not specified and Hydra will try the default one, TCP
    `80`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is not recommended performing brute force attacks or dictionary attacks with
    large numbers of passwords on production servers because we risk interrupting
    the service, blocking valid users, or being blocked by our client's protection
    mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is recommended, as a penetration tester, performing this kind of attack
    using a maximum of four login attempts per user to avoid a blockage; for example,
    we could try `-e ns`, as we did here, and add `-p 123456` to cover three possibilities:
    no password, the password is the same as the username, and the password is `123456`,
    which is one of the most common passwords in the world.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have seen two authentication methods in web applications, namely,
    form-based authentication and basic authentication. These are not the only ones
    used by developers; the reader is encouraged to further investigate advantages,
    weaknesses, and possible implementation failures in methods such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Digest authentication**: This is significantly more secure than basic authentication.
    Instead of sending the username and password encoded in the header, the client
    calculates the MD5 hash of a value provided by the server, called a nonce, together
    with their credentials, and sends this hash to the server, which already knows
    the nonce, username, and password, and can recalculate the hash and compare both
    values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NTLM/Windows authentication**: Following the same principle as digest, NTLM
    authentication uses Windows credentials and the NTLM hashing algorithm to process
    a challenge provided by the server. This scheme requires multiple request-response
    exchanges, and the server and any intervening proxies must support persistent
    connections.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kerberos authentication**: This authentication scheme makes use of the Kerberos
    protocol to authenticate to a server. As with NTLM, it doesn''t ask for a username
    and password, but it uses Windows credentials to log in.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bearer tokens**: A bearer token is a special value, usually a randomly generated
    long string or a base64-encoded data structure signed using a cryptographic hashing
    function, which grants access to any client that presents it to the server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attacking Tomcat's passwords with Metasploit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Apache Tomcat is one of the most widely used servers for Java web applications
    in the world. It is also very common to find a Tomcat server with some configurations
    left by default. Among those configurations, it is surprisingly common to find
    that a server has the manager web application exposed, that is, the application
    that allows the administrator to start, stop, add, and delete applications in
    the server.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will use a Metasploit module to perform a dictionary attack
    over a Tomcat server in order to obtain access to its manager application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If it''s the first time you have run Metasploit Framework, you need to start
    the database service and initialize it. Metasploit uses a PostgreSQL database
    to store the logs and results, so the first thing we do is start the service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we use the Metasploit database tool to create and initialize the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we start the Metasploit console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/876cafce-d3dc-4884-8273-bcf4de22fd54.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We could use Hydra or Burp Suite to attack the Tomcat server, but having alternative
    ways to do things in case something doesn''t work as expected, and using alternative
    tools, should be part of the skill set of any good penetration tester. So, we
    will use Metasploit in this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The vulnerable virtual machine `vm_1` has a Tomcat server running on port `8080`.
    Browse to `http://192.168.56.11:8080/manager/html`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/f7c85495-777f-4131-b9e8-f1f6a3a1f905.png)'
  prefs: []
  type: TYPE_IMG
- en: We get a basic authentication popup requesting a username and password.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open a terminal and start the Metasploit console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'When it finishes starting, we need to load the proper module. Type the following
    in the `msf>` prompt:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We may want to see what parameter it uses:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we set our target hosts; in this case, it is only one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To make it work a little faster, but not too fast, we increase the number of
    threads. This means requests sent in parallel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, we don''t want our server to crash due to too many requests, so we lower
    the brute force speed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/556790f7-e7a8-4b81-84e3-94c4d97075f1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The remainder of the parameters work just as they are for our case, so let''s
    run the attack:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'After failing in some attempts, we will find a valid password, the one marked
    with a green `[+]` symbol:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/fddc467d-77fb-43cc-946f-694d57702340.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By default, Tomcat uses TCP port `8080` and has its manager application in
    `/manager/html`. That application uses basic HTTP authentication. Metasploit''s
    auxiliary module we just used (`tomcat_mgr_login`) has some configuration options
    worth mentioning here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`BLANK_PASSWORDS`: Adds a test with a blank password for every user tried'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PASSWORD`: Useful if we want to test a single password with multiple users
    or to add a specific one not included in the list'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PASS_FILE`: The password list we will use for the test'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Proxies`: If we need to go through a proxy to reach our target, or to avoid
    detection, this is the option we need to configure'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RHOSTS`: The host, hosts (separated by spaces), or file with hosts (`file:
    /path/to/file/with/hosts`) we want to test'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RPORT`: The TCP port in the hosts being used by Tomcat'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`STOP_ON_SUCCESS`: Stop trying a host when a valid password is found for it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TARGERURI`: Location of the manager application inside the host'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`USERNAME`: Defines a specific username to test; it can be tested alone or
    added to the list defined in `USER_FILE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`USER_PASS_FILE`: A file containing username/password combinations to be tested'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`USER_AS_PASS`: Try every username in the list as its password'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once we gain access to a Tomcat server, we can see and manipulate (start, stop,
    restart, and delete) the applications installed therein:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/127d10f1-309e-4a54-ab1a-1fbf472f6398.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Also, we can upload our own applications, including ones that execute commands
    in the server. It is left as an exercise to the reader to upload and deploy a
    webshell to the server and execute system commands in it. Kali Linux includes
    many useful webshell source codes in `/usr/share/webshells`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f4d29781-6664-47d9-87a7-0e9048f7bc90.png)'
  prefs: []
  type: TYPE_IMG
- en: Manually identifying vulnerabilities in cookies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cookies are pieces of information that servers store in the client computer,
    persistently or temporarily. In modern web applications, cookies are the most
    common way of keeping track of the user's session. By saving session identifiers
    generated by the server stored in the user's computer, the server is able to distinguish
    between different requests made from different clients at the same time. When
    any request is sent to the server, the browser adds the cookie and then sends
    the request so that the server can distinguish the session based on the cookie.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will see how to identify common vulnerabilities in cookies
    that would allow an attacker to hijack the session of a valid user.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s recommended to delete all cookies before doing this recipe. It may get
    confusing to have cookies from many different applications, as all of those applications
    are in the same server and all cookies belong to the same domain:'
  prefs: []
  type: TYPE_NORMAL
- en: Browse to `http://192.168.56.11/WackoPicko/`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can use the Cookies Manager browser add-on to check the cookies' values and
    parameters. To do this, just click on the add-on's icon and it will display all
    cookies currently stored by the browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select any cookie, for example `PHPSESSID` from the domain `192.168.56.11`,
    and double-click on it, or click Edit to open a new dialog to view and be able
    to change all of its parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/fb1cba3a-bf3a-4406-9a53-f011e1603116.png)'
  prefs: []
  type: TYPE_IMG
- en: '`PHPSESSID` is the default name of session cookies in PHP-based web applications.
    By looking at the parameter''s values in this cookie, we can see that it can be
    sent by secure and insecure channels (HTTP and HTTPS) and that it can be read
    by the server and also by the client through scripting code, because it doesn''t
    have the Secure (noticed by the Send For: Any type of connection parameter) and
    HTTP Only flags enabled. This means that the sessions in this application may
    be hijackable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use the browser''s Developer Tools to view and modify cookie values.
    Open the Developer Tools and go to Storage:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/ad9794e9-5bfb-44e8-852d-1d1c55f938eb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In this screenshot, we selected a cookie called `session`, which only has an
    effect over the WackoPicko directory in the server (given by the `Path` parameter);
    it will be erased when the browser is closed (`Expires: "Session"`) and as with `PHPSESSID`,
    it doesn''t have the `HttpOnly` and `Secure` flags enabled, hence it can be accessed
    via scripting (HttpOnly) and will be transmitted via either HTTP or HTTPS (Secure).'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we just checked some values of a cookie. Although not as spectacular
    as others, it is important to check the cookie configuration in every penetration
    test we perform; an incorrectly configured session cookie opens the door to a
    session hijacking attack and the misuse of a trusted user's account.
  prefs: []
  type: TYPE_NORMAL
- en: If a cookie doesn't have the `HTTPOnly` flag enabled, it can be read by scripting,
    which means that if there is a **Cross-Site Scripting** (**XSS**) vulnerability,
    which we will see in later chapters, the attacker will be able to get the identifier
    of a valid session and use that value to impersonate the real user in the application.
  prefs: []
  type: TYPE_NORMAL
- en: The **Secure** attribute, or Send For Encrypted Connections Only in Cookies
    Manager, tells the browser to only send or receive this cookie over encrypted
    channels. This means sending only via an HTTPS connection. If this flag is not
    set, an attacker could perform a **man-in-the-middle** (**MiTM**) attack and force
    the communication to be unencrypted, exposing the session cookie in clear text,
    which takes us again to a scenario where the attacker can impersonate a valid
    user by having their session identifier.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As `PHPSESSID` is the default name for PHP session cookies, other platforms
    have known names for theirs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ASP.NET_SessionId` is the name for an ASP .Net session cookie'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`JSESSIONID` is the session cookie for JSP implementations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'OWASP has a very thorough article on securing session cookies: [https://www.owasp.org/index.php/Session_Management_Cheat_Sheet](https://www.owasp.org/index.php/Session_Management_Cheat_Sheet).'
  prefs: []
  type: TYPE_NORMAL
- en: Attacking a session fixation vulnerability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a user loads the home page of an application, it sets a session identifier,
    be it a cookie, token, or internal variable; if, once the user logs in to the
    application, this is when the user enters into a restricted area of the application
    that requires a username and password or other type of identification, this identifier
    is not changed, then the application may be vulnerable to session fixation.
  prefs: []
  type: TYPE_NORMAL
- en: A session fixation attack occurs when the attacker forces a session ID value
    into a valid user, and then this user logs in to the application and the ID provided
    by the attacker is not changed. This allows for the attacker to simply use the
    same session ID and hijack the user's session.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn the process of a session fixation attack by using
    one of the applications in the vulnerable virtual machine `vm_1`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'WebGoat has a somewhat simplistic, yet very illustrative, exercise on session
    fixation. We will use it to illustrate how this attack can be executed:'
  prefs: []
  type: TYPE_NORMAL
- en: In the Kali VM, log in to WebGoat and go to Session Management Flaws | Session
    Fixation in the menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We are in the first stage of the attack. The description says we are an attacker
    attempting to send a phishing email to our victim to force a session ID of our
    choice. Replace the `href` value in the HTML code with the following (be careful
    of the capitalization as the server is case-sensitive):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/b63138c4-4370-4142-a813-3ce168400300.png)'
  prefs: []
  type: TYPE_IMG
- en: The important part here is the `SID` parameter, which contains a session value
    controlled by us, the attacker.
  prefs: []
  type: TYPE_NORMAL
- en: Click on Send Mail to go to STAGE 2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In STAGE 2, we take the perspective of the victim reading the malicious email.
    If you put your mouse over the link to Goat Hills Financial, you''ll notice that
    the destination URL contains the `SID` value we set as attackers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/6b01d3f9-77b8-48a6-9636-408043c723bb.png)'
  prefs: []
  type: TYPE_IMG
- en: Click on the link to move on to STAGE 3.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that the victim is on the login page, use the credentials provided and
    log in. Notice how the `SID` value in the address bar is still the one we set:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/d19bf421-2ab3-4331-8e54-f10c04ecb465.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, in STAGE 4, we are back to the attacker's perspective, and we have a link
    to Goat Hills Financial; click on it to go to the login page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Notice how the address bar has a different `SID` value now; this would happen
    if we go to the login page without being authenticated. Use the browser''s developer
    tools to find and change the `action` parameter of the login form so that it has
    the session value we established in relation to the victim:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/d2cfc6ea-3ece-4dda-b6f1-30cd575f195e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When the `SID` value is changed, click on Login; there''s no need to set any
    username or password as the fields are not validated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/c84eea11-7aed-4931-82b2-e4081ee2d698.png)'
  prefs: []
  type: TYPE_IMG
- en: By changing the `SID` parameter the login form uses when submitted, we tricked
    the server into thinking our request is coming from a valid, existing session.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we followed the complete path of an attack involving social
    engineering, by sending an email containing a malicious link to a victim. This
    link exploited a session fixation vulnerability, which should have been previously
    discovered by the attacker, and when the victim user logs in to the application,
    it keeps the session ID provided by the attacker and links it to the user; this
    enables the attacker to manipulate his/her own parameters in the application to
    replicate the same ID, and thereby hijack a valid user's session.
  prefs: []
  type: TYPE_NORMAL
- en: Evaluating the quality of session identifiers with Burp Sequencer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Burp Suite's Sequencer requests thousands of session identifiers from the server
    (by repeating the login request, for example) and analyzes the responses to determine
    the randomness and cryptographic strength of the algorithm generating the identifiers.
    The stronger the algorithm, the harder for an attacker to replicate a valid ID.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will use Burp Sequencer to analyze the session ID generation
    by two different applications and determine some characteristics of a secure session
    ID generation algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will use WebGoat and RailsGoat (a WebGoat version made with the Ruby on Rails
    framework). Both applications are available in the vulnerable VM (`vm_1`).
  prefs: []
  type: TYPE_NORMAL
- en: You will need to create a user in RailsGoat; to do that, use the signup button
    on the main page.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will start analyzing RailsGoat''s session cookie. We could have used any
    `PHPSESSID` or `JSESSIONID` cookie, but we will take advantage of this one being
    a custom value to review additional concepts. Configure your browser to use Burp
    Suite as a proxy and follow the next steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Log in to RailsGoat and look at the proxy's history for a response setting a
    session cookie. You should have the header `Set-Cookie` and should set a cookie
    called `_railsgoat_session`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this case, this is a request to `/railsgoat/session`. Right-click on the
    URL, or on the body of the request or response, and select Send to Sequencer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/0c3e56d6-af36-43ce-8d2d-d12fd639c290.png)'
  prefs: []
  type: TYPE_IMG
- en: Before continuing with Sequencer, let's see what the session cookie contains.
    This `_railsgoat_session` cookie looks like a base64-encoded string joined to
    a hexadecimal string by two hyphens (`--`). We'll explain this deduction later
    in this recipe. Select the value of the cookie, right-click on it, and select
    Send to Decoder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once in decoder, we first decode it as a URL, and then, in the second line,
    we decode it as base64:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/82cdfc18-c854-4a00-ba43-5c97345a659a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It seems as if the base64 code contains three fields: `session_id`, which is
    a hexadecimal value, perhaps a hash; `csrf_token`, which is a value used to prevent
    **Cross-Site Request Forgery** (**CSRF**) attacks; and `user_id`, which seems
    to be just two characters, maybe a sequential number. The rest of the cookie (the
    part after the `--`) is not base64-encoded and appears to be a random hash. Now,
    we understand a little bit more about the session ID, and have learned a little
    bit about encoding and Burp Suite''s Decoder.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s continue with our analysis in Sequencer. Go to the Sequencer tab in
    Burp Suite and ensure that the correct request and cookie are selected:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/b2b6360f-a9f6-46ef-894d-b685b4324138.png)'
  prefs: []
  type: TYPE_IMG
- en: We know the cookie is encoded with base64; go to Analysis Options and select
    Base64-decode before analyzing. This way, Burp Suite will analyze the decoded
    information in the cookie.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go back to the Live capture tab and click on Start live capture. A new window
    will appear; we wait for it to finish. It'll take some time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once it is finished, click on Analyze now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/70e32361-df92-4aa9-b733-59c7fc258aef.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see that the cookie is of excellent quality; this means it is not easily
    guessable by an attacker. Feel free to explore all the result tabs.
  prefs: []
  type: TYPE_NORMAL
- en: That was an example of a good quality session cookie; let's see a not-so-good
    one this time. Log in to WebGoat and go to Session Management Flaws | Hijack a
    Session.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This exercise is about bypassing a login form by hijacking a valid session
    ID. Attempt a login with any random username and password, just to get it recorded
    in Burp Suite:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/3ef404d9-ba39-45fc-86b4-0cf6a3a96426.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In this case, the request that sets the session cookie is the one that first
    loads the exercise; search in Burp Suite''s history for the `Set-Cookie: WEAKID=`
    response header. This ID is merely numbers separated by a hyphen.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Send the request to Sequencer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `WEAKID` cookie as the target to analyze.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start the live capture and wait for it to finish and execute the analysis:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/41065b0d-2dba-449b-9310-f9f4634dc3e3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For this ID, we can see that the quality is extremely poor. Going to the character
    analysis, we can have a better idea:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/88ec218d-cb3c-44a3-bdf9-c6faf0b7d8e2.png)'
  prefs: []
  type: TYPE_IMG
- en: This chart shows the degree of change or significance for each character position.
    We see that significance increases from position **2** to position **3** and from
    **3** to **4**, to then fall again in **5**, which is the location of the hyphen.
    This suggests that the first part of the ID is incremental and that the same may
    apply to the second part, but with a different rate.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Burp Suite's Sequencer performs different statistical analyses on large amounts
    of session identifiers (or whatever piece of information from a response we provide
    to it) to determine whether such data is being randomly generated or whether there
    may be a predictable pattern that may allow an attacker to generate a valid ID
    and hijack a session with it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we analyzed a complex session cookie composed by a data structure encoded
    using the base64 algorithm and what seems to be an SHA-1 hash. We can tell that
    the first part is base64-encoded because it contains lowercase and uppercase letters,
    numbers, may also contain a plus symbol (`+`) or a slash (`/`), and it also ends
    in `%3D`, which is the URL escape sequence for `=`, a string terminator in base64\.
    We say the second part of the cookie is an SHA-1 hash because it is a hexadecimal
    string of 40 digits; each hexadecimal digit represents 4 bits, and 4 bits * 40
    digits = 160 bits; and SHA-1 is the most popular 160-bit hashing algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we analyzed a weakly generated session ID. It's rather obvious that it
    is incremental, since in decimal numbers, the digit in the rightmost position
    changes ten times more frequently than its closest left-hand neighbor. The second
    part of the ID, based on its length and most significant digits, suggests a Unix
    timestamp ([https://en.wikipedia.org/wiki/Unix_time](https://en.wikipedia.org/wiki/Unix_time)).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dig further into the generation mechanisms for the `WEAKID` session cookie and
    try to figure out a way of discovering an active session cookie to bypass the
    login. Use Burp Suite's Repeater and Intruder to facilitate the job.
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn more about how to distinguish encoding, hashing, and encryption, check
    out this excellent article: [https://danielmiessler.com/study/encoding-encryption-hashing-obfuscation/](https://danielmiessler.com/study/encoding-encryption-hashing-obfuscation/).'
  prefs: []
  type: TYPE_NORMAL
- en: Abusing insecure direct object references
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A direct object reference is when an application uses input provided by the
    client to access a server-side resource by name or other simple identifier, for
    example, using a file parameter to search for a specific file in the server and
    allowing the user to access it.
  prefs: []
  type: TYPE_NORMAL
- en: If the application doesn't properly validate the value provided by the user,
    and that such a user is allowed to access the resource, an attacker can take advantage
    of this to bypass privilege level controls and access files or information not
    authorized for that user.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will analyze and exploit a simple example of this vulnerability
    in the RailsGoat application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, we need to have at least two users registered in RailsGoat.
    One of them will be the victim with the username `user`, and the other one will
    be the attacker, called `attacker`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this exercise, it is preferable that we know the passwords for both users,
    although we only really need to know the attacker's password in a real-life scenario.
  prefs: []
  type: TYPE_NORMAL
- en: 'Configure the browser to use Burp Suite as a proxy and do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Log in as the `user` and go to account settings; click on the profile picture
    (top right-hand corner) and account settings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/a3142d8a-3ff9-44df-a250-00f4a210c2ec.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice that, in our example, the URL says `users/7/account_settings`. Could
    it be that that number `7` is a user ID?
  prefs: []
  type: TYPE_NORMAL
- en: Log out and log in as the `attacker`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to account settings again and observe that the URL for the attacker settings
    has a different number.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enable request interception in Burp Suite.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the password for the attacking user. Set a new password, confirm it,
    and click Submit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s analyze the intercepted request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/6379899b-3fa1-441c-856a-6cb5a3079221.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's focus on the underlined parts of the screenshot. First, the request is
    made to a `9.json` file; `9` is the number in the URL of the attacker's account
    settings, so that may be the user ID. Next, there is a `user%5Buser_id%50` parameter
    (`user[user_id]`, if we decode it) with the value `9`, and then a `user%5Bemail%50`
    or `user[email]` once URL-decoded. The last two parameters are the password and
    its confirmation.
  prefs: []
  type: TYPE_NORMAL
- en: So, what if all those references to user number `9` in the attacker's requests
    are not correctly validated? Let's try and attack the victim user, which has the
    ID of `7`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As the attacker, make a password change and intercept the request again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the request, replacing the attacker's ID with the victim's ID in both
    the URL and `user_id` parameters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change the rest of the request as per the underlined values in the screenshot,
    or choose your own:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/68c61750-0b04-43f6-9a9a-bae791651a68.png)'
  prefs: []
  type: TYPE_IMG
- en: Submit the request and verify that it is accepted (response code 200 and a message
    `success` in the body).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Log out and try to log in as the victim user with the original password and
    the login will fail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, try the password set in the attacker's request and the login will be successful.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go to account settings and verify that the other changes also happened:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/5d91d21c-1bdf-496f-a5a5-6ce21d0b4830.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we first checked the URL of the user's account settings and
    noticed that the application may distinguish users by a numeric ID. Then, we performed
    a request to change the user's information and verified the use of numeric identifiers.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we attempted to replace the ID of the user, making changes to affect other
    users, and it turned out that RailsGoat makes a direct object reference to the
    object that contains the user's information and only validates with the user ID
    provided in the body of the same request to make changes. This way, as the attacker,
    we only needed to know the victim's ID to change their information, even the password,
    which allowed us to log in on their behalf.
  prefs: []
  type: TYPE_NORMAL
- en: Performing a Cross-Site Request Forgery attack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A CSRF attack is one that makes authenticated users perform unwanted actions
    in the web application they are authenticated with. This is done through an external
    site that the user visits, and that triggers these actions.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will obtain the required information from the application
    in order to know what the attacking site should do to send valid requests to the
    vulnerable server, and then we will create a page that simulates the legitimate
    requests and tricks the user into visiting that page while authenticated. We will
    also make a few iterations on the basic proof of concept to make it look more
    like a real-world attack, where the victim doesn't notice it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You''ll need a valid user account in BodgeIt for this recipe. We''ll use `user@example.com`
    as our victim:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/2ce59f95-cfd0-4804-844f-ac7858b4da06.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We first need to analyze the request we want to force the victim to make. To
    do this, we need Burp Suite, or another proxy configured in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: Log in to BodgeIt as any user and click on the username to go to the profile.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make a password change. Let''s see what the request looks like in the proxy:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/63d1ffbb-3262-4f9d-a3df-2d49958d0819.png)'
  prefs: []
  type: TYPE_IMG
- en: So, it is a `POST` request to `http://192.168.56.11/bodgeit/password.jsp` and
    has only the password and its confirmation in the body.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to make a very simple HTML page that replicates this request. Create
    a file (we''ll name it `csrf-change-password.html`) with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, load this file in the same browser as our logged-in session:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/f5129a54-3664-4acf-9e4e-0729f69f8b2f.png)'
  prefs: []
  type: TYPE_IMG
- en: Click on submit and you'll be redirected to the user's profile page. It'll tell
    you that the password was successfully updated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Although this proves the point, an external site (or a local HTML page as in
    this case) can execute a password change request on the application. It''s still
    unlikely that a user will click on the Submit button. We can automate that and
    hide the input fields so that the malicious content is hidden. Let''s make a new
    page based on the previous one; we''ll call it `csrf-change-password-scripted.html`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This time, the form has an ID parameter and there is a script in the page that
    will submit its content when the page is loaded completely.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we load this page in the same browser where we have a BodgeIt session initiated,
    it will automatically send the request and the user''s profile page will show
    after that. In the following screenshot, we used the browser''s Debugger to set
    a breakpoint just before the request is made:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/511c7c8a-3264-4620-8802-19488addcee5.png)'
  prefs: []
  type: TYPE_IMG
- en: This last attempt looks better from an attacker's perspective; we only need
    the victim to load the page and the request will be sent automatically, but then
    the victim will see the Your password has been changed message and that will surely
    raise an alert.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can further improve the attacking page by making it load the response in
    an invisible frame inside the same page. There are many ways of doing this; a
    quick and dirty one is to set a size `0` for the frame. Our file would look like
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the target property of the form is the `iframe` defined just below
    it, and that such frame has `0%` `height` and `width`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Load the new page in the browser where the session is initiated. This screenshot
    shows how the page looks when being inspected with the browser''s Developer Tools:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/a8964913-8631-43d1-a3ca-67a87d6c916f.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice that the `iframe` object is only a black line in the page and, in the
    `Inspector`, we can see that it contains the BodgeIt user's profile page.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we analyze the network communications undertaken by our CSRF page, we can
    see that it actually makes requests to change the BodgeIt password:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/ec4821c6-e984-412f-8ae9-0d48fc724867.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we send a request from a browser and already have a cookie belonging to
    the target domain stored, the browser will attach the cookie to the request before
    it is sent; this is what makes cookies so convenient as session identifiers, but
    this characteristic of how HTTP works is also what makes it vulnerable to an attack
    like the one we saw in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: When we load a page in the same browser where we have an active session in an
    application, even if it's a different tab or window, and this page makes a request
    to the domain where the session is initiated, the browser will automatically attach
    the session cookie to that request. If the server doesn't verify that the requests
    it receives actually originated from within the application, usually by adding
    a parameter containing a unique token that changes with every request or on every
    occasion, it allows a malicious site to make calls on behalf of legitimate, active
    users that visit this malicious site while authenticated to the target domain.
  prefs: []
  type: TYPE_NORMAL
- en: In a web application penetration test, the first code we used, the one with
    the two text fields and the Submit button, may be enough to demonstrate the presence
    of a security flaw. However, if the penetration testing of the application is
    part of another engagement, such as a social engineering or red team exercise,
    some extra effort will be required to prevent the victim user from suspecting
    that something is happening. In this recipe, we used JavaScript to automate the
    sending of the request by setting the `onload` event in the page and executing
    the form's submit method in the event handler function. We also used a hidden
    `iframe` to load the response of the password change, so, the victim never sees
    the message that his/her password has changed.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Applications often use web services to perform certain tasks or retrieve information
    from the server without changing or reloading pages; these requests are made via
    JavaScript (they will add the header `X-Requested-With: XMLHttpRequest`)  and
    usually in JSON or XML formats, with a `Content-Type` header with the value `application/json`
    or `application/xml`. When this happens, and we try to make a cross-site/domain
    request, the browser will perform what is called a **preflight check**, which
    means that before the intended request, the browser will send an `OPTIONS` request
    to verify what methods and content types the server allows being requested from
    cross origins (domains other than the one the application belongs to).'
  prefs: []
  type: TYPE_NORMAL
- en: The preflight check can interrupt a CSRF attack as the browser won't send the
    malicious request if the server doesn't allow cross-origin requests. However,
    this protection only works when the request is made via scripting, and not when
    it is made via a form. So, if we can convert the JSON or XML request to a regular
    HTML form, we can make a CSRF attack. If this is not possible, because the server
    only allows certain content types, for example, then our only chance for a successful
    CSRF is if the server's **Cross Origin Resource Sharing** (**CORS**) policy allows
    requests from our attacking domain, so check for the `Access-Control-Allow-Origin`
    header in the server's responses.
  prefs: []
  type: TYPE_NORMAL
