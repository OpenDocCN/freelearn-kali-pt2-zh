- en: Using Automated Scanners
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Scanning with Nikto
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Considerations when doing automated scanning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding vulnerabilities with Wapiti
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using OWASP ZAP to scan for vulnerabilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scanning with Skipfish
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding vulnerabilities in WordPress with WPScan
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding vulnerabilities in Joomla with JoomScan
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scanning Drupal with CMSmap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Almost every penetration testing project must follow a strict schedule, mostly
    determined by clients' requirements or development delivery dates. It is very
    useful for a penetration tester to have a tool that can perform plenty of tests
    on an application in a short period of time in order to identify the biggest possible
    number of vulnerabilities in the scheduled time. Automated vulnerability scanners
    are the tools to pick for this task. They can also be used to find exploitation
    alternatives or to be sure that one doesn't leave something obvious behind in
    a penetration test.
  prefs: []
  type: TYPE_NORMAL
- en: Kali Linux includes several vulnerability scanners aimed at web applications
    or specific web application vulnerabilities. In this chapter, we will cover some
    of the most widely used by penetration testers and security professionals.
  prefs: []
  type: TYPE_NORMAL
- en: Scanning with Nikto
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A must-have tool in every tester''s arsenal is Nikto; it is perhaps the most
    widely used free scanner in the world. As stated on its official website ([https://cirt.net/Nikto2](https://cirt.net/Nikto2)):'
  prefs: []
  type: TYPE_NORMAL
- en: '"Nikto is an Open Source (GPL) web server scanner which performs comprehensive
    tests against web servers for multiple items, including over 6700 potentially
    dangerous files/programs, checks for outdated versions of over 1250 servers, and
    version specific problems on over 270 servers. It also checks for server configuration
    items such as the presence of multiple index files, HTTP server options, and will
    attempt to identify installed web servers and software. Scan items and plugins
    are frequently updated and can be automatically updated."'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will use Nikto to search for vulnerabilities in a web application
    and analyze the results.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Nikto is a command-line utility included by default in Kali Linux; open a Terminal
    to start scanning the server:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will scan the Peruggia vulnerable application and export the results to
    an HTML report with the `nikto -h http://192.168.56.11/peruggia/ -o result.html` command.
    The output will look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/5aa90586-9850-45b7-9f08-8889a9332847.png)'
  prefs: []
  type: TYPE_IMG
- en: The `-h` option tells Nikto which host to scan, the `-o` option tells it where
    to store the output, and the extension of the file determines the format it will
    take. In this case, we have used `.html` to obtain an HTML-formatted report of
    the results. The output could also be in the CSV, TXT, and XML formats.
  prefs: []
  type: TYPE_NORMAL
- en: 'It will take some time to finish the scan. When it finishes, we can open the
    `result.html` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/18708ca6-3eb6-4c39-9b98-11b4ff38ea23.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we have used Nikto to scan an application and generate an HTML
    report. There are some more options in this tool for performing specific scans
    or generating specific output formats. Some of the most useful are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-H`: This shows Nikto''s help.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-config <file>`: To use a custom configuration file in the scan.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-update`: This updates plugin databases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Format <format>`: This defines the output format; it may be CSV, HTM, NBE
    (Nessus), SQL, TXT, or XML. Formats such as CSV, XML, and NBE are very useful when
    we want to use Nikto''s results as an input for other tools.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-evasion <technique>`: This uses some encoding techniques to help avoid detection
    by web application firewalls and intrusion detection systems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-list-plugins`: To view the available testing plugins.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Plugins <plugins>`: Select what plugins to use in the scan (default: all).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-port <port number>`: If the server uses a non-standard port (`80`, `443`),
    we may want to use Nikto with this option.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Considerations when doing automated scanning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Normal vulnerability scanners such as OpenVas and Nessus usually work by scanning
    open ports on target machines, and identifying the services running on those ports
    and their versions without sending malicious payloads that could cause a disruption
    in the server. Web vulnerability scanners, on the contrary, submit data into web
    forms and parameters and, even when these scanners are thoroughly tested and their
    payloads are intended to be secure, such data can compromise the application's
    stability and information integrity. For this reason, we need to take special
    care when using these tools as part of a penetration testing project.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will discuss a series of aspects to take into account before
    launching an automated test against a target application in an enterprise setup.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When preparing an automated scan for web applications, here are some key considerations:'
  prefs: []
  type: TYPE_NORMAL
- en: Always prefer a testing environment over a productive one, so if anything goes
    wrong real data won't be lost or corrupted.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure there is a recovery mechanism. The application's owners should take preemptive
    measures so data and code can be recovered in the case of an undesirable outcome.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define the scope of scanning. Although we can just launch a scanner against
    a whole site, it is recommended first to define the tool's configuration so sensitive
    or unstable parts of the application are left out of the scan, and only the modules
    specific to the server's architecture and application's development platform are
    scanned.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Know your tools. Always take time to test the tools in a laboratory so you understand
    what they do and how can they affect the normal operation of an application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Keep tools and their modules updated so the results are consistent with the
    latest vulnerability disclosures and attack techniques.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the scanner's parameters and scope before launching the scan to ensure
    no out-of-scope tests are performed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Keep comprehensive logs of the scanning process. Most tools have an option to
    save logs of their activity and issue a report of the findings; always use these
    features and store the logs in a secure way.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do not leave the scanner unattended.  It is not necessary to keep staring at
    the screen while the scanner runs, but we need to be aware and constantly check
    how it is doing to be ready to stop it at the first sign of it causing trouble
    on the server or the network.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do not rely on one single tool. We all have our favorite tools, but we need
    to keep in mind that there is no one tool that can cover all of the possible alternatives
    involved in a penetration test, so use alternative tools to minimize the rates
    of false positives and false negatives.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we showed some key aspects to take into account in order to
    avoid damage to the information and disruption to services when executing automated
    scanning against our target application.
  prefs: []
  type: TYPE_NORMAL
- en: The main reason for requiring special measures is that web application vulnerability
    scanners, in their default configurations, tend to crawl the entire site and use
    the URLs and parameters obtained from this crawling to send further payloads and
    probes. In applications that don't properly filter the data they receive, these
    probes can end up stored in the database or executed by the server, and this could
    cause integrity problems, permanently alter or damage existing information, or
    disrupt services.
  prefs: []
  type: TYPE_NORMAL
- en: To prevent this damage, we recommended a series of actions focused on preparing
    the testing environment, knowing what the tools are doing and keeping them updated,
    carefully selecting what is to be scanned, and keeping extensive record of all
    actions.
  prefs: []
  type: TYPE_NORMAL
- en: Finding vulnerabilities with Wapiti
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Wapiti is another terminal-based web vulnerability scanner, which sends `GET`
    and `POST` requests to target sites looking for the following vulnerabilities
    ([http://wapiti.sourceforge.net/](http://wapiti.sourceforge.net/)):'
  prefs: []
  type: TYPE_NORMAL
- en: File disclosure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cross-Site Scripting** (**XSS**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Command execution detection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CRLF injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**XML External Entity** (**XXE**) injection'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use of known, potentially dangerous files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Weak `.htaccess` configurations that can be bypassed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Presence of backup files that give sensitive information (source code disclosure)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this recipe, we will use Wapiti to discover vulnerabilities in one of our
    test applications and generate a report of the scan.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Wapiti is a command-line tool; open a Terminal in Kali Linux and be sure you
    are running the vulnerable VM before starting:'
  prefs: []
  type: TYPE_NORMAL
- en: In the Terminal, execute `wapiti http://192.168.56.11/peruggia/ -o wapiti_result
    -f html -m "-blindsql"` to scan the Peruggia application in our vulnerable VM,
    save the output in HTML format inside the `wapiti_result` directory, and skip
    the blind SQL injection tests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Wait for the scan to finish and open the report''s directory and then the `index.html`
    file; then, you will see something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/f58a5239-ae5e-4a78-92c6-2e9c71d91f33.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, we can see that Wapiti has found 12 XSS and five file-handling vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Now, click on Cross Site Scripting to see the details of the findings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select a vulnerability and click on HTTP Request. We will take the second one
    and select and copy the URL part of the request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/052ee805-b841-4a60-9276-5bb78dcd1f0b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we paste that URL in the browser and add the server portion (`http://192.168.56.11/peruggia/index.php?action=comment&pic_id=%3E%3C%2F%3E%3Cscript%3Ealert%28%27wp6dpkajm%27%29%3C/script%3E`);
    the result should be as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/2d6f36c8-8987-4125-a598-0bccd3e11a7d.png)'
  prefs: []
  type: TYPE_IMG
- en: And we do indeed have an XSS vulnerability.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We skipped the blind SQL injection test in this recipe (`-m "-blindsql"`), as
    we already know this application is vulnerable. When it reaches the point of calculating
    a time-based injection, it provokes a timeout error that makes Wapiti close before
    the scan is finished, because Wapiti tests multiple times by injecting the `sleep()`
    command until the server passes the timeout threshold.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we have selected the HTML format for output (`-f html`) and `wapiti_result`
    as our report's destination directory; we can also have other formats, such as
    JSON, OpenVas, TXT, or XML.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other interesting options in Wapiti are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-x <URL>`: Exclude the specified URL from the scan; particularly useful for
    logout and password change URLs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-i <file>`: Resumes a previously saved scan from an XML file. The filename
    is optional, as Wapiti takes the file from its `scans` folder if omitted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-a <login%password>`: Uses specified credentials to authenticate to the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--auth-method <method>`: Defines the authentication method for the `-a` option;
    it can be `basic`, `digest`, `kerberos`, or `ntlm`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-s <URL>`: Defines a URL to start the scan with.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-p <proxy_url>`: Uses an HTTP or HTTPS proxy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using OWASP ZAP to scan for vulnerabilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OWASP ZAP is a tool that we have already used ing this book for various tasks,
    and among its many features, it includes an automated vulnerability scanner. Its
    use and report generation will be covered in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we perform a successful vulnerability scan in OWASP ZAP, we need to
    crawl the site:'
  prefs: []
  type: TYPE_NORMAL
- en: Open OWASP ZAP and configure the web browser to use it as a proxy
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to `http://192.168.56.11/peruggia/`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Follow the instructions from *Using ZAP's spider* in [Chapter 3](d4ea55af-3a7c-4ee5-8e5d-65720f268ee2.xhtml), *Using
    Proxies, Crawlers, and Spiders*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once you have browsed through the application or run ZAP''s spider against
    it, let''s start the scan:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to OWASP ZAP's Sites panel and right-click on the `peruggia` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the menu, navigate to Attack | Active Scan, as shown in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/ba98aff9-7f74-4ce7-baa6-61fe2904e1be.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A new window will pop up. At this point, we know what technologies our application
    and server use; so, go to the Technology tab and check only MySQL, PHP, Linux,
    and Apache:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/3436d70c-3df6-40ff-a891-d374b6a25b30.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, we can configure our scan in terms of Scope (where to start the scan,
    on what context, and so on), Input Vectors (select if you want to test values
    in `GET` and `POST` requests, headers, cookies, and other options), Custom Vectors
    (add specific characters or words from the original request as attack vectors),
    Technology (what technology-specific tests to perform), and Policy (select configuration
    parameters for specific tests).
  prefs: []
  type: TYPE_NORMAL
- en: Click on Start Scan.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Active Scan tab will appear on the bottom panel and all the requests made
    during the scan will appear there.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When the scan is finished, we can check the results in the Alerts tab, as the
    following screenshot shows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/8e205c1b-5864-47a4-9549-36d8545175ae.png)'
  prefs: []
  type: TYPE_IMG
- en: If we select an alert, we can see the request made and the response obtained
    from the server. This allows us to analyze the attack and define whether it is
    a true vulnerability or a false positive. We can also use this information to
    fuzz, repeat the request in the browser, or to dig deeper into exploitation.
  prefs: []
  type: TYPE_NORMAL
- en: To generate an HTML report, as with the previous tools, go to Report in the
    main menu and then select Generate HTML Report.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A new dialog will ask for the filename and location. Set, for example, `zapresult.html`
    and when finished, open the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/556211da-8afc-4eb4-86b6-b4e1cae2bd6b.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OWASP ZAP has the ability to perform active and passive vulnerability scans;
    passive scans are unintrusive tests that OWASP ZAP makes while we browse, send
    data, and click links. Active tests involve the use of various attack strings
    against every form variable or request value in order to detect if the servers
    respond with what we can call a vulnerable behavior.
  prefs: []
  type: TYPE_NORMAL
- en: OWASP ZAP has test strings for a wide variety of technologies; it is useful
    first to identify the technologies that our target uses, in order to optimize
    our scan and diminish the probability of being detected or causing a drop in the
    service.
  prefs: []
  type: TYPE_NORMAL
- en: Another interesting feature of this tool is that we can analyze the request
    that results in the detection of a vulnerability and its corresponding response
    in the same window, and at the moment it is detected. This allows us to determine
    rapidly whether it is a real vulnerability or a false positive and whether to
    develop our **proof of concept** (**PoC**) or start the exploitation.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've also used Burp Suite throughout this book. Kali Linux includes only the
    free version, which doesn't have the active and passive scanning features. It's
    absolutely recommended to acquire a professional license for Burp Suite, as it
    has useful features and improvements over the free version such as these.
  prefs: []
  type: TYPE_NORMAL
- en: Passive vulnerability scanning happens in the background as we browse a web
    page with Burp Suite configured as our browser's proxy. Burp will analyze all
    requests and responses while looking for patterns corresponding to known vulnerabilities.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In active scanning, Burp Suite will send specific requests to the server and
    check the responses to see if they correspond to some vulnerable pattern or not.
    These requests are specially crafted to trigger special behaviors when an application
    is vulnerable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scanning with Skipfish
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Skipfish ([https://code.google.com/archive/p/skipfish/](https://code.google.com/archive/p/skipfish/))
    was created by Google and released to the public in 2010; it is described by its
    creators as an active web application security reconnaissance tool, is included
    by default in Kali Linux, and it does more than pure reconnaissance. It is a complete
    vulnerability scanner. Some of its highlights are:'
  prefs: []
  type: TYPE_NORMAL
- en: 'High speed: It can reach more than 400 requests per second and claims to be
    able to reach more than 2000 in high speed LAN'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Its command-line options are straightforward and easy to use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can detect a wide range of issues, from directory listing and other information
    disclosure vulnerabilities to different types of SQL and XML injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this recipe, we will look at a simple example of how to use Skipfish and
    check its results.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Skipfish, as installed in Kali Linux, is ready to use. We will scan Peruggia
    with it:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a Terminal and execute `skipfish -o skipfish_result -I peruggia http://192.168.56.11/peruggia/`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A message with some usage recommendations will appear; press *Enter* or wait
    60 seconds for the scan to start.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The scan will start and scan statistics will show on the screen. *Ctrl* + *C*
    can be used to stop it at any time. The Terminal will look like the following
    while scanning:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/0fca0750-51b9-4323-9198-78020dd95276.png)'
  prefs: []
  type: TYPE_IMG
- en: When the scan finishes, open the report. In our case, it will be in `skipfish_result/index.html`,
    relative to the directory we ran Skipfish from.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the Issue type overview - click to expand: section, we can click on the
    issues'' names and see the exact URL and payload of each occurrence, shown as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/48bcb71d-8e51-48bc-a3f2-9b89f2e2071c.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Skipfish will first build a site map by crawling it and optionally using a dictionary
    for directory and filenames. This map is then processed through multiple security
    checks.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we used it to scan Peruggia in our vulnerable VM. To prevent
    it scanning the whole server, we used the `-I peruggia` option, which scans only
    those URLs matching (containing) the specified text. We also used the `-o` option
    to tell Skipfish where to save the reports; this directory must not exist at the
    moment the scan is run.
  prefs: []
  type: TYPE_NORMAL
- en: The main drawback of Skipfish is that it hasn't been updated since 2012, according
    to its Google Code page, so newer technologies and attack vectors may not be the
    ideal target for it. It remains a very useful tool, though.
  prefs: []
  type: TYPE_NORMAL
- en: Finding vulnerabilities in WordPress with WPScan
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: WordPress is one of the most used **Content Management Systems** (**CMS**),
    if not the most used, in the world. A CMS is an application - usually a web application
    - that allows users to  create fully functional websites easily with no or little
    programming knowledge. WPScan is a vulnerability scanner specialized in detecting
    vulnerabilities in WordPress sites.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will use WPScan to identify vulnerable components on a WordPress
    site installed in the OWASP BWA virtual machine.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'WPScan is a command-line tool; open a Terminal to start using it:'
  prefs: []
  type: TYPE_NORMAL
- en: Run WPScan against our target with the `wpscan http://192.168.56.11/wordpress/` command; the
    URL is the location of the WordPress site we want to scan.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If this is the first time you are running WPScan, it will ask to update the
    database, which requires internet connection. In our laboratory setup, the Kali
    Linux VM doesn''t have internet connection, so it is a good idea first to change
    its network setup, update the tools we are using, and connect it back to the laboratory
    after that''s finished. To update, you just need to answer `Y` and press *Enter*
    when asked. The following screenshot shows the expected output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/7284067b-e428-4d82-bfac-74dc1fe49091.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the update is finished, WPScan will continue scanning the target site.
    It will be displaying its findings in the Terminal; for example, in the following
    screenshot we see that it detected the web server and WordPress versions, and
    several vulnerabilities exist for that specific version:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/0d872e87-ebb9-478a-9d58-21b0c17c9274.png)'
  prefs: []
  type: TYPE_IMG
- en: 'With information about the existent vulnerabilities, we can follow the references
    and search for published exploits; for example, if we search for CVE-2007-5106,
    which is an XSS vulnerability in the user registration form, we will find that
    there is an exploit published in Security Focus: [https://www.securityfocus.com/bid/25769/exploit](https://www.securityfocus.com/bid/25769/exploit).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Look for other exploits and attempt to exploit the vulnerabilities identified
    by WPScan.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: WordPress allows users that are not experienced in developing web applications
    to create their own sites by incorporating plugins that may be created by other
    users and are not subject to the same quality assurance and testing that the main
    CMS is; this means that when one of those plugins or modules has a serious security
    flaw, thousands of users may have installed vulnerable code in their sites and
    are exposed to attacks that can compromise their whole servers.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we used WPScan to identify vulnerabilities in an old WordPress
    installation. We started by updating the tool's database; this was done automatically
    while being connected to the internet. Having finished the update, the scan continued
    by identifying the version of WordPress installed, users, and plugins used by
    the site; with this information, WPScan searches in its database for known vulnerabilities
    in any of the active components and displays the findings in the Terminal. When
    the scan finished, we looked for information and exploits for the issues identified.
    The further exploitation of such vulnerabilities is left to the reader.
  prefs: []
  type: TYPE_NORMAL
- en: Finding vulnerabilities in Joomla with JoomScan
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another CMS widely used around the world is Joomla. As with WordPress, Joomla
    is based on PHP and its aim is to help users with little or no technical knowledge
    create websites, although it may not be as user-friendly as WordPress and is more
    suited for e-commerce sites rather than for blogs and news sites.
  prefs: []
  type: TYPE_NORMAL
- en: Kali Linux also includes a vulnerability scanner specialized in finding vulnerabilities
    in Joomla installations, JoomScan. In this recipe, we will use it to analyze the
    Joomla site installed in our vulnerable VM, `vm_1`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As with most of the tools in Kali Linux, JoomScan is a command-line utility,
    so we need to open a Terminal to run it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, run `joomscan -h` to see how is it used and its options, as shown in
    the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/a3d03937-5aeb-4680-84df-2e3a08dc25f4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we know that we need to use the `-u` option, followed by the URL we want
    to scan, we can also modify other parameters in the requests, such as cookies
    and user agents. We will run the simplest command: `joomscan -u http://192.168.56.11/joomla/`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'JoomScan will start scanning and displaying the results. As we can see in the
    following screenshot, those results include the version of Joomla that is affected,
    the type of vulnerability, the CVE number, and something that can prove to be
    very useful for a penetration tester, the Exploit-DB reference, if there is a
    public exploit available:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/a6bd5ac4-31b2-4130-a12e-b7396fb1e063.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When the scan is finished, JoomScan will show the path where the scan report
    is stored. This path is relative to JoomScan''s installation path; in our case,
    the report is saved in `/usr/share/joomscan/reports/192.168.56.11/`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/8cdd901c-4837-4b90-a18d-407c6ea910df.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can open the given directory and open the report, which is in HTML format,
    as can be seen in the next picture:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/fcbd96eb-47e2-4ae0-bd4d-44c3de0954b1.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we used JoomScan to identify vulnerabilities in a vulnerable
    installation. This tool identifies the Joomla version and the plugins it has enabled,
    and contrasts that information with its database of known vulnerabilities and
    exploits. The results of this process are displayed in the Terminal and also saved
    in a report in HTML format. The location of this report is given by JoomScan at
    the end of the scan.
  prefs: []
  type: TYPE_NORMAL
- en: Scanning Drupal with CMSmap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another popular CMS is Drupal, which is also open source and based on PHP as
    with the previous ones. Although not as widespread, it holds a considerable share
    of the market with more than 1 million sites using it according to its official
    site ([https://www.drupal.org/project/usage/drupal](https://www.drupal.org/project/usage/drupal)).
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will install CMSmap, a vulnerability scanner for Drupal,
    WordPress, and Joomla, and use it to identify vulnerabilities in the Drupal version
    installed in bee-box, one of the vulnerable virtual machines in our laboratory.
    After finding a relevant attack vector, we will exploit it and gain command execution
    on the server.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'CMSmap is not installed in Kali Linux, nor included in its official software
    repository; however, we can easily get it from its GitHub repository. Open a Terminal
    and run `git clone https://github.com/Dionach/CMSmap.git`; this will download
    the latest source code to the `CMSmap` directory. As it is made in Python, there
    is no need to compile the code, as it is ready to run. To see usage examples and
    available options, enter the `CMSmap` directory and run `python cmsmap.py` command.
    This process is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/45b621b4-a1ff-499e-8b90-9f450fbb77bf.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we have CMSmap ready to run, start bee-box. In this example, it will have
    the IP address `192.168.56.12`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Browse to `http://192.168.56.12/drupal/` to verify that there is a running
    version of Drupal. The result should be as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/88ed0fa1-21e9-4811-9d16-6f9c94adb342.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, launch the scanner against the site. Open a Terminal, go to the directory
    where CMSmap was downloaded, and run the `python cmsmap.py -t http://192.168.56.12/drupal`
    command. The following screenshot displays how the result should look:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/ccd957a6-db40-4996-97f4-9461963be460.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see some vulnerabilities ranked high (the red `[H]`). One of them is
    SA-CORE-2014-005; a quick Google search will tell us that it is an SQL injection
    and this vulnerability is also nicknamed `Drupageddon` (the same name as our target
    site, coincidentally).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see if there''s an easy way to exploit this well-known flaw. Open
    Metasploit''s console (`msfconsole`) and search for `drupageddon`; you should
    find at least one exploit, shown as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/90eeb039-2f7e-4bf0-a575-ad9491a57d8a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Use the `multi/http/drupal_drupageddon` module and set the options according
    to the scenario, using a generic reverse shell. The next screenshot shows the
    final setup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/097cc9d3-0fd7-41af-b8f7-097a381e5fd7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Run the exploit and verify that we have command execution, shown as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/e4860b28-815d-4902-96fc-57ef6ed76c41.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we first downloaded CMSmap from its GitHub source code repository
    using the `git` command-line client with the `clone` command, which makes a local
    copy of the specified repository. Once CMSmap was installed, we checked it was
    ready to execute and saw the usage options, then we ran it against our target.
  prefs: []
  type: TYPE_NORMAL
- en: In the results, we saw a vulnerability rated as high impact by the scanner and
    looked online for information about it, finding that it was an SQL injection with
    several publicly available exploits.
  prefs: []
  type: TYPE_NORMAL
- en: This vulnerability was disclosed in Drupal's security advisory SA-CORE-2014-005
    ([https://www.drupal.org/forum/newsletters/security-advisories-for-drupal-core/2014-10-15/sa-core-2014-005-drupal-core-sql](https://www.drupal.org/forum/newsletters/security-advisories-for-drupal-core/2014-10-15/sa-core-2014-005-drupal-core-sql)).
    According to that, it is an SQL injection vulnerability that can be used to get
    privilege escalation, PHP execution, and, as we saw in our example, command execution
    on the affected host.
  prefs: []
  type: TYPE_NORMAL
- en: 'We chose to look in Metasploit for an existing exploit. The exploit we used
    has two ways of achieving the remote shell: in the first one, it uses the SQLi
    to upload malicious content to Drupal''s cache and trigger that cache entry to
    execute the payload. This was the option used by our exploit as we didn''t change
    the `TARGET` parameter (from `0` to `1`). In the second approach, it will create
    an administrator user in Drupal and use that user to upload the PHP code for the
    server to execute.'
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we got a limited shell on the server with the ability to execute noninteractive
    commands and retrieve information.
  prefs: []
  type: TYPE_NORMAL
