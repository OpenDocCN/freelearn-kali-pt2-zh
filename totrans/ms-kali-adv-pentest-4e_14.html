<html><head></head><body>
  <div id="_idContainer576" class="Basic-Text-Frame">
    <h1 class="chapterNumber">14</h1>
    <h1 id="_idParaDest-316" class="chapterTitle">Embedded Devices and RFID Hacking</h1>
    <p class="normal">The embedded systems market has been given a real boost by the adoption of the <strong class="keyWord">Internet of Things</strong> (<strong class="keyWord">IoT</strong>) by consumers. Modern connected embedded devices are becoming more attractive and are widely deployed across many big corporations, <strong class="keyWord">Small Offices/Home Offices</strong> (<strong class="keyWord">SOHOs</strong>), and <strong class="keyWord">Small and Medium-sized Businesses</strong> (<strong class="keyWord">SMB</strong>) and are being directly utilized by global household consumers. As per <a href="http://www.statista.com"><span class="url">www.statista.com</span></a>, connected IoT devices have grown from 15.41 billion devices in 2015 to 35.82 billion devices in 2021, and there are expected to be 75.44 billion devices by 2025. In the same way, threats have grown, and the security of these devices has become the biggest area of concern to manufacturers and consumers. A recent good example of this is the vulnerabilities found in Realtek chipsets (CVE-2021-35395) that affected 65+ vendors that produce smart devices. The way the attacks originated indicates that they might have been done by the same attackers that created the Mirai botnet attack that left most of the US east coast without internet in 2016.</p>
    <p class="normal">In this chapter, we will cover the basics of embedded systems and the role of peripherals and explore the different tools and techniques that can be employed to perform a traditional hardware/firmware penetration test or product evaluation of a given device using Kali Linux. We will also set up ChameleonMini to emulate an NFC card and replay the stored memory contents to bypass any physical access control during a red teaming exercise or physical penetration testing.</p>
    <p class="normal">In this chapter, you will learn about the following:</p>
    <ul>
      <li class="bulletList">Embedded systems and hardware architecture</li>
      <li class="bulletList">UART serial buses</li>
      <li class="bulletList">USB JTAG</li>
      <li class="bulletList">Unpacking firmware and common bootloaders</li>
      <li class="bulletList">RFID hacking using ChameleonMini</li>
    </ul>
    <h1 id="_idParaDest-317" class="heading-1">Embedded systems and hardware architecture</h1>
    <p class="normal">An embedded system is a combination of hardware and software that is designed to perform a <a id="_idIndexMarker1483"/>specific task. The embedded hardware is usually based on a microcontroller and microprocessors. In this section, we will take a quick look at the <a id="_idIndexMarker1484"/>different architectural elements of an embedded system, including memory and communication between these devices. Pretty much everything that we use on a day-to-day basis is an embedded device, including mobile phones, DVD players, GPS systems, and intelligent voice assistants such as Alexa and other hardware-based solutions.</p>
    <h2 id="_idParaDest-318" class="heading-2">Embedded system basic architecture</h2>
    <p class="normal">The basic <a id="_idIndexMarker1485"/>architecture of an embedded system typically includes a hardware and software component. <em class="italic">Figure 14.1</em> depicts the typical architecture components of a simple embedded device:</p>
    <figure class="mediaobject"><img src="../Images/B17765_14_01.png" alt="Diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 14.1: Basic embedded system architecture</p>
    <p class="normal">The components of an embedded<strong class="keyWord"> </strong>system<strong class="keyWord"> </strong>are as follows:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Software</strong>: This is <a id="_idIndexMarker1486"/>the custom application to control the device and its features; mostly a web application to configure or update the device.<ul>
          <li class="bulletList"><strong class="keyWord">Microprocessor or microcontroller</strong>: Typical embedded devices are based around the <a id="_idIndexMarker1487"/>microprocessor and microcontroller. The <a id="_idIndexMarker1488"/>only difference between a microcontroller and a microprocessor is that microprocessors do not have RAM/ROM, which needs to be added externally. Most of the embedded devices/systems today utilize microcontrollers that have a CPU and a fixed amount of RAM/ROM.</li>
        </ul>
      </li>
      <li class="bulletList"><strong class="keyWord">Hardware</strong>: This <a id="_idIndexMarker1489"/>includes a peripheral device with chipsets, processors such as ARM (most widely deployed), MIPS, Ambarella, Axis CRIS, Atmel AVR, Intel 8051, or Motorola power microcontrollers. <ul>
          <li class="bulletList"><strong class="keyWord">Embedded operating system</strong>: Most embedded systems are Linux-based, and <a id="_idIndexMarker1490"/>they are <strong class="keyWord">real-time operating systems</strong> (<strong class="keyWord">RTOSes</strong>) customized for the device. There might be <a id="_idIndexMarker1491"/>some questions raised in the tester’s mind, such as what is the difference between the operating system and the firmware? The firmware allows device manufacturers to use general-purpose programmable chips instead of custom-purpose hardware. </li>
        </ul>
      </li>
    </ul>
    <h3 id="_idParaDest-319" class="heading-3">Understanding firmware</h3>
    <p class="normal">In electronic systems <a id="_idIndexMarker1492"/>and computing, firmware is software that can connect to specific hardware that provides low-level control. Every device comes with its own firmware from the product’s manufacturer.</p>
    <p class="normal">The following list of categories and types of devices are those that typically come with custom firmware, and they are mostly Linux. The following list is not exhaustive in any way:</p>
    <figure class="mediaobject"><img src="../Images/B17765_14_02.png" alt=""/></figure>
    <p class="packt_figref">Figure 14.2: Different types of devices</p>
    <p class="normal">The following table lists the types of memory utilized in most embedded devices:</p>
    <table id="table001-8" class="table-container">
      <tbody>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Type of memory</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Description</strong></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">DRAM</strong> (<strong class="keyWord">Dynamic Random-Access Memory</strong>)</p>
          </td>
          <td class="table-cell">
            <p class="normal">This is volatile memory that can be accessed in both read and write mode. It is fast and will need access to the memory contents. DRAM is the reason to employ caching mechanisms in some architectures. The DRAM memory access is timed at the very early stages of the bootloader.</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">SRAM</strong> (<strong class="keyWord">Static Random-Access Memory</strong>)</p>
          </td>
          <td class="table-cell">
            <p class="normal">This is volatile memory similar to DRAM that can be accessed in read and write mode. It is faster than DRAM. Mostly, small levels of SRAM that are less than 1 MB will be included on the device (due to commercial reasons).</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">ROM</strong> (<strong class="keyWord">Read-Only Memory</strong>)</p>
          </td>
          <td class="table-cell">
            <p class="normal">This is non-volatile memory that can only be read. A mask bootloader is one example of a ROM in embedded devices.</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Memory-Mapped NOR Flash</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal">This is non-volatile memory that can be accessed in read/write mode. This is used during boot code.</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">NAND Flash</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal">This is a type of non-volatile storage technology that does not require power to retain data.</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">SD</strong> (<strong class="keyWord">Secure Digital</strong>) <strong class="keyWord">Card</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal">This is a non-volatile memory card format used in portable devices.</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="packt_figref">Table 14.1: Different types of memory</p>
    <h3 id="_idParaDest-320" class="heading-3">Different types of firmware</h3>
    <p class="normal">Pretty much <a id="_idIndexMarker1493"/>all embedded devices are powered by different firmware depending on their complexities. Embedded systems that perform heavy tasks definitely need a full operating system such as Linux or Windows NT. The following is a non-exhaustive list of operating systems that are normally found during firmware analysis:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Ambarella</strong>: An <a id="_idIndexMarker1494"/>embedded operating system mostly used in video cameras, drones, and so on.</li>
      <li class="bulletList"><strong class="keyWord">Cisco IOS</strong>: Cisco’s <a id="_idIndexMarker1495"/>Internetwork operating system.</li>
      <li class="bulletList"><strong class="keyWord">DOS</strong>: A disk <a id="_idIndexMarker1496"/>operating system that is considered obsolete. But testers never know what they will find during an assessment.</li>
      <li class="bulletList"><strong class="keyWord">eCos (Embedded Configurable Operating System)</strong>: This is an open-source real-time <a id="_idIndexMarker1497"/>operating system from the eCos community.</li>
      <li class="bulletList"><strong class="keyWord">Junos OS or JunOS</strong>: This <a id="_idIndexMarker1498"/>is Juniper Networks’ custom operating system based on FreeBSD for its router devices.</li>
      <li class="bulletList"><strong class="keyWord">L4 microkernel family</strong>: These <a id="_idIndexMarker1499"/>are second-generation microkernels that look like Unix-like operating systems.</li>
      <li class="bulletList"><strong class="keyWord">VxWorks/Wind River</strong>: A <a id="_idIndexMarker1500"/>popular proprietary real-time operating system.</li>
      <li class="bulletList"><strong class="keyWord">Windows CE/NT</strong>: The <a id="_idIndexMarker1501"/>operating system for Microsoft-enabled embedded compact devices; very rare to find on a device.</li>
    </ul>
    <p class="normal">It is important <a id="_idIndexMarker1502"/>to understand the difference between the firmware and the operating system. <em class="italic">Table 14.2</em> provides the basic differences: </p>
    <table id="table002-4" class="table-container">
      <tbody>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Firmware</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Operating System</strong></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">It is always fixed data/code that is embedded in any peripheral device or electronic appliance.</p>
          </td>
          <td class="table-cell">
            <p class="normal">It is system software that is designed to provide an environment to facilitate multiple programs; it acts as a foundational layer. </p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">It resides in non-volatile memory (ROM), for example, BIOS, keyboards, refrigerators, and washing machines.</p>
          </td>
          <td class="table-cell">
            <p class="normal">It resides on disk, for example, Microsoft Windows, Google Android, and Apple iOS/macOS.</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">It is a low-level operation and is mostly used for a single purpose.</p>
          </td>
          <td class="table-cell">
            <p class="normal">It is a high-level interface and a multi-purpose system that allows different kinds of software to run on multiple hardware.</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="packt_figref">Table 14.2: Firmware versus operating systems</p>
    <h3 id="_idParaDest-321" class="heading-3">Understanding bootloaders</h3>
    <p class="normal">Every device has a bootloader. Bootloaders are nothing but the first piece of software that gets loaded and executed after the mask ROM bootloader. They are primarily put in place to load parts of an operating system into the memory and ensure the system is loaded in the defined state for the kernel. Some bootloaders have a two-step approach; in these scenarios, only step one will know how to load the second step, while the second step will provide access to filesystems, and so on. The following is a list of the bootloaders we have encountered during a product evaluation so far:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">U-Boot</code>: Stands for universal boot—this is open source and pretty much available in all the architecture (68k, ARM, Blackfin, MicroBlaze, MIPS, Nios, SuperH, PPC, RISC-V, and x86).</li>
      <li class="bulletList"><code class="inlineCode">RedBoot</code>: Uses the eCos real-time operating system hardware abstraction layer to provide bootstrap firmware for embedded systems.</li>
      <li class="bulletList"><code class="inlineCode">BareBox</code>: Another open-source, primary bootloader used in embedded devices. It supports RM, Blackfin, MIPS, Nios II, and x86.</li>
    </ul>
    <h3 id="_idParaDest-322" class="heading-3">Common tools</h3>
    <p class="normal">The following list of tools can be utilized while debugging or reverse engineering a device’s firmware. Some of these tools are available as toolkits with Kali Linux:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">binwalk</strong>: This is a reverse engineering tool that can perform analysis and extraction of any image or binary files. It is scriptable and you can add custom modules of the specific firmware.</li>
      <li class="bulletList"><strong class="keyWord">firmware-mod-kit</strong>: This is a collection of toolkits that includes multiple scripts and utilities that can be handy during an assessment to extract and rebuild Linux-based firmware images. Testers can also reconstruct or deconstruct a firmware image.</li>
      <li class="bulletList"><strong class="keyWord">ERESI framework</strong>: This is a software interface with a multi-architecture binary analysis framework to perform reverse engineering and manipulation of programs.</li>
      <li class="bulletList"><strong class="keyWord">cnu-fpu</strong>: Cisco IP phones’ firmware pack/unpacker. This can be found at <a href="https://github.com/kbdfck/cnu-fpu"><span class="url">https://github.com/kbdfck/cnu-fpu</span></a>.</li>
      <li class="bulletList"><strong class="keyWord">ardrone-tool</strong>: This tool handles all the Parrot format files and also allows users to flash through USB and load new firmware. It is available at <a href="https://github.com/scorp2kk/ardrone-tool"><span class="url">https://github.com/scorp2kk/ardrone-tool</span></a>.</li>
    </ul>
    <h1 id="_idParaDest-323" class="heading-1">Firmware unpacking and updating</h1>
    <p class="normal">With a basic understanding of the bootloaders and different types of firmware, we will explore how to unpack some firmware and update it with our custom firmware on a Cisco Meraki MR18 wireless access point (an embedded device with Cisco firmware). Most of the time, during hardware penetration testing, the firmware images will not include all the files to construct a complete embedded system. Typically, we find the following in each embedded device:</p>
    <ul>
      <li class="bulletList">Bootloader (1st/2nd stage)</li>
      <li class="bulletList">Kernel</li>
      <li class="bulletList">Filesystem images</li>
      <li class="bulletList">User-land binaries</li>
      <li class="bulletList">Resources and support files</li>
      <li class="bulletList">Web server/web interface</li>
    </ul>
    <p class="normal">Modern embedded devices prevent the installation of different operating systems using their own firmware, therefore to upgrade the device to a customizable operating system, we will utilize OpenWRT, which is open-source firmware for residential gateways, originally created for Linksys WRT54G wireless routers. It has grown into an embedded Linux distribution and now supports a wide range of devices. With the device restrictions, to perform the upgrade or update it requires a JTAG (which stands for Joint Test Action Group, an industry standard for verifying designs and testing printed circuit boards after manufacture).</p>
    <p class="normal">JTAG can be used more from a <strong class="keyWord">TAP</strong> (<strong class="keyWord">Test Access Port</strong>) perspective no matter how restricted the device is. The manufacturer will usually leave either a serial port or a few TAPs. In our experience, if serial access is not yielding good results or the device is too locked down, it might be easier to go for a JTAG port (but this is not always the case as the device might be completely locked down).</p>
    <p class="normal">JTAG architecture is specified by the chip maker and, in most cases, even with a daisy-chained JTAG. The JTAG follows the main chipset’s specifications for command and control. All the products are assigned with an FCC ID that provides the device’s details. The FCC ID can be searched by visiting <a href="https://www.fcc.gov/oet/ea/fccid"><span class="url">https://www.fcc.gov/oet/ea/fccid</span></a>. We must get the right voltage or we will end up either breaking the device or making the hardware faulty. Once the type of JTAG architecture has been identified, we can start looking at the specifications and commands that are required to configure the connection.</p>
    <p class="normal">We will utilize the <strong class="keyWord">USB JTAG NT</strong> tool, which is preconfigured with a list of devices and different categories and types. This tool can be directly downloaded from <a href="https://www.usbjtag.com/filedownload/"><span class="url">https://www.usbjtag.com/filedownload/</span></a> and we will be utilizing the USB JTAG NT cable for this example. As a key first step, the USB end of the USB JTAG cable must be connected to our Kali Linux and the JTAG end to the circuit board of the device (for more information on how to find the right pins to connect, refer to <a href="https://blog.senr.io/blog/jtag-explained"><span class="url">https://blog.senr.io/blog/jtag-explained</span></a>). The physical connection to the router will look like <em class="italic">Figure 14.3</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_14_03.png" alt=""/></figure>
    <p class="packt_figref">Figure 14.3: USB JTAG NT cable connecting to the Cisco Meraki router</p>
    <p class="normal">Since USB JTAG NT heavily relies on QTLib libraries, to successfully run this tool on Kali Linux, the following steps are involved:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Download the USB JTAG NT from <a href="https://www.usbjtag.com/filedownload/usbjtagnt-for-linux64.php"><span class="url">https://www.usbjtag.com/filedownload/usbjtagnt-for-linux64.php</span></a>.</li>
      <li class="numberedList">Download the QTLib from <a href="https://www.usbjtag.com/filedownload/library-for-linux64.php"><span class="url">https://www.usbjtag.com/filedownload/library-for-linux64.php</span></a>.</li>
      <li class="numberedList">Unzip the archive files by running <code class="inlineCode">tar xvf &lt;nameofthefile.tar&gt;</code>.</li>
      <li class="numberedList">Ensure you set the QT library path by running <code class="inlineCode">export LD_LIBRARY_PATH=/home/kali/Downloads/QtLib</code> (if you have downloaded the files to a different folder ensure that reflects in the path).</li>
      <li class="numberedList">Finally, launch the application by running <code class="inlineCode">./USBJTAGNT</code> in the terminal. Then, you should successfully be able to launch the application without any problems, as shown in <em class="italic">Figure 14.4</em>:<figure class="mediaobject"><img src="../Images/B17765_14_04.png" alt="Graphical user interface, text, application, chat or text message  Description automatically generated"/></figure>
        <p class="packt_figref">Figure 14.4: Successfully loading USB JTAG NT in Kali Linux</p>
      </li>
    </ol>
    <p class="normal">Once you select the <strong class="screenText">Category</strong>, <strong class="screenText">Protocol </strong>type, and <strong class="screenText">Target select</strong>, we will set <strong class="screenText">Router</strong> as the <strong class="screenText">Category</strong>, <strong class="screenText">EJTAG</strong> as the <strong class="screenText">Protocol</strong>, and then select the model of the router for the target. We will utilize OpenWRT to load into the hardware. If the connected JTAG physically works fine, then we are good to debug the device, as shown in <em class="italic">Figure 14.5</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_14_05.png" alt=""/></figure>
    <p class="packt_figref">Figure 14.5: Flushing and installing OpenWRT to the device</p>
    <p class="normal">The <code class="inlineCode">program</code> command is utilized to flush the <strong class="keyWord">OEM</strong> (<strong class="keyWord">Original Equipment Manufacturer</strong>) operating system. Once the program is complete, we can upload a new <code class="inlineCode">.bin</code> file to the device, which will load OpenWRT to the selected router and have full privileges.</p>
    <p class="normal">Once the flush is complete and OpenWRT is loaded, we can verify the communication to the device by direct SSH access root privileges by running <code class="inlineCode">ssh root@192.168.1.1</code> from the Kali Linux terminal. </p>
    <p class="normal">With Windows, you can utilize PuTTY to access the device with default gateway IP (<code class="inlineCode">192.168.1.1</code>) as shown in <em class="italic">Figure 14.6</em> (ensure you have a physical Ethernet cable connected to your router and laptop and set a static IP to your device):</p>
    <figure class="mediaobject"><img src="../Images/B17765_14_06.png" alt=""/></figure>
    <p class="packt_figref">Figure 14.6: Connecting to the device using PuTTY to the Meraki wireless access point with root and no password</p>
    <h1 id="_idParaDest-324" class="heading-1">Introduction to RouterSploit Framework</h1>
    <p class="normal">Similar to the Metasploit Framework, Threat9’s (https://www.threat9.com) RouterSploit Framework is an open-source exploitation framework used to exploit embedded devices (specifically routers). The tool can be installed on Kali by running <code class="inlineCode">sudo apt install routersploit</code> from the terminal. The latest version of RouterSploit is 3.4.1, and it comes with 132 known exploits and 4 different scanners, depending on the device type. This entire section can be performed by a mobile device as we know we can install the Kali on any Android phone as described in the <em class="italic">Kali on Android (non-rooted phones)</em> section in <em class="chapterRef">Chapter 1</em>, <em class="italic">Goal-Based Penetration Testing</em>.</p>
    <p class="normal">The following are the modules of RouterSploit:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">exploits</code>: A module that contacts all the identified vulnerabilities</li>
      <li class="bulletList"><code class="inlineCode">creds</code>: A module to test for login credentials with predefined usernames and passwords</li>
      <li class="bulletList"><code class="inlineCode">scanners</code>: A module that runs the scanning with the preconfigured list of vulnerabilities</li>
      <li class="bulletList"><code class="inlineCode">payloads</code>: A module to generate payloads according to the device type</li>
      <li class="bulletList"><code class="inlineCode">generic/encoders</code>: A module that includes the generic payloads and encoders</li>
    </ul>
    <p class="normal">In the following example, we will go ahead and use RouterSploit’s scanner function to identify if the router (DLink) that we have connected to is vulnerable to any known vulnerabilities or not. We will use <code class="inlineCode">scanners/autopwn</code> against our router that is running on <code class="inlineCode">192.168.0.1</code>, as shown in <em class="italic">Figure 14.7</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_14_07.png" alt="Text  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 14.7: Using Routersploit to exploit a DLink router</p>
    <p class="normal">The scanner will run 132 exploits from the <code class="inlineCode">exploits</code> module. Since we have utilized <code class="inlineCode">autopwn</code>, by the end of the scan you should be able to see the list of vulnerabilities that our router is vulnerable to, as shown in <em class="italic">Figure 14.8</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_14_08.png" alt=""/></figure>
    <p class="packt_figref">Figure 14.8: Output of the autopwn module with a list of exploitable vulnerabilities</p>
    <p class="normal">Once <code class="inlineCode">autopwn</code> is run, you should be able to see the vulnerabilities that can be exploited. In this case, we know the device is vulnerable to two different exploits, so let’s go ahead and use the exploit by running:</p>
    <pre class="programlisting con"><code class="hljs-con">use exploits/routers/dlink/dir_300_320_600_615_info_disclosure
set port 80
run
</code></pre>
    <p class="normal">This exploit does <strong class="keyWord">Local File Inclusion </strong>(<strong class="keyWord">LFI</strong>) and reaches the <code class="inlineCode">httaccess</code> file and extracts the username and password. A successful exploit should result in login information, as shown in <em class="italic">Figure 14.9</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_14_09.png" alt="Text  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 14.9: Successfully extracting the password from the router using RouterSploit</p>
    <p class="normal">Let’s try the other vulnerability to bypass the authentication, without having to log in with valid credentials by manipulating the URLs. We can exploit the router by running <code class="inlineCode">routersploit</code>, as shown in <em class="italic">Figure 14.10</em>; in the case of a router running on port <code class="inlineCode">443</code>, set the <code class="inlineCode">ssl</code> value to <code class="inlineCode">true</code>:</p>
    <pre class="programlisting con"><code class="hljs-con">use exploits/routers/dlink/dir_300_320_615_auth_bypass
run
</code></pre>
    <p class="normal"><img src="../Images/B17765_14_10.png" alt="Text  Description automatically generated"/></p>
    <p class="packt_figref">Figure 14.10: Running the authentication bypass module in RouterSploit</p>
    <p class="normal">Finally, the URL can be utilized to access the router web interface, which will allow direct access to the setup page, as shown in <em class="italic">Figure 14.11</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_14_11.png" alt="Graphical user interface, website  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 14.11: Accessing the router settings without any authentication</p>
    <p class="normal">We have explored RouterSploit to take advantage of the vulnerable routers. Attackers can use a simple non-rooted Android device to perform these attacks. </p>
    <p class="normal">If you’re tasked to perform hardware pen testing on a newly designed hardware, the following section provides a brief methodology that can be used by attackers to get a root shell on a router using a UART device.</p>
    <h1 id="_idParaDest-325" class="heading-1">UART</h1>
    <p class="normal"><strong class="keyWord">UART</strong> stands for <strong class="keyWord">Universal Asynchronous Receiver/Transmitter</strong>. It is one of the first modes of communication to computers. It goes back to 1960 when it was used to connect minicomputers for teletypewriter machines (teletypes). The main purpose of UARTs is to transmit and receive the serial data just like a standalone integrated circuit; it is not a protocol like <strong class="keyWord">SPI</strong> (<strong class="keyWord">Serial Peripheral Interface</strong>) or <strong class="keyWord">I2C</strong> (<strong class="keyWord">Inter-Integrated Circuit</strong>). It is typically used by manufacturers to connect microcontrollers to store and load programs. Every UART device has advantages and disadvantages. The following are the advantages of UART:</p>
    <ul>
      <li class="bulletList">It has only two wires, so it’s pretty straightforward. One is transmit (TX), and the other is receive (RX).</li>
      <li class="bulletList">There is no need for a clock signal.</li>
      <li class="bulletList">Error checking can be performed by a parity bit.</li>
      <li class="bulletList">If both sides are set up, then the structure of the data packet can be changed.</li>
      <li class="bulletList">It’s widely used due to the availability of its documentation throughout the internet.</li>
    </ul>
    <p class="normal">It has the following limitations:</p>
    <ul>
      <li class="bulletList">Testers cannot increase the data frame: it will be limited to 9 bits at most</li>
      <li class="bulletList">There is no way to set up multiple slave or master systems</li>
      <li class="bulletList">UART baud rates must be within 10%</li>
    </ul>
    <p class="normal">In this section, we will be using the <strong class="keyWord">USB to</strong> <strong class="keyWord">TTL</strong> (<strong class="keyWord">Transistor/Transistor Logic</strong>) adapter to perform UART communication by connecting to the serial port of the device’s circuit board.</p>
    <p class="normal">These adapters typically include four ports:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">GND</strong>: Ground (0V) supply</li>
      <li class="bulletList"><strong class="keyWord">VCC</strong>: Voltage power supply, 3.3V (default) or 5V</li>
      <li class="bulletList"><strong class="keyWord">TX</strong>: Serial transmit</li>
      <li class="bulletList"><strong class="keyWord">RX</strong>: Serial receive</li>
    </ul>
    <p class="normal">One big challenge attackers face during a hardware hack is to identify the right serial ports. This could be done by using a multimeter to read the voltage output to confirm the TX (typically, the voltage will keep fluctuating when the device is powered on), RX (initially it will fluctuate, but will be constant after a point), and GND (zero voltage).</p>
    <p class="normal">In this example, we will use a well-known wireless access point (Cisco Meraki MR18) and connect the UART to the TTL device to communicate to the hardware directly, as shown in <em class="italic">Figure 14.12</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_14_12.png" alt=""/></figure>
    <p class="packt_figref">Figure 14.12: Connecting the UART to Cisco Meraki MR18 wireless access point</p>
    <p class="normal">When the right TX/RX and ground are identified (to identify the right UART pins, look for 3 or 4 pins next to each other; however, this might change based on the type of device), we can use Kali Linux to learn about the device that is currently connected by running the <code class="inlineCode">baudrate.py</code> Python file (<a href="https://github.com/PacktPublishing/Mastering-Kali-Linux-for-Advanced-Penetration-Testing-4E/blob/main/Chapter%2014/Baudrate.py"><span class="url">https://github.com/PacktPublishing/Mastering-Kali-Linux-for-Advanced-Penetration-Testing-4E/blob/main/Chapter%2014/Baudrate.py</span></a>). </p>
    <p class="normal">If the serial device is connected, you should be able to see the following screen in your Kali without any issues. Most of the time, configuring a baud rate of 115,200 works for routers:</p>
    <figure class="mediaobject"><img src="../Images/B17765_14_13.png" alt=""/></figure>
    <p class="packt_figref">Figure 14.13: Successfully connecting to the device with a 115,200 baud rate using the Python script</p>
    <p class="normal">Once the device is successfully read by our Kali Linux, we can start interacting with the device by running <code class="inlineCode">screen /dev/ttyUSB0 115200</code> in the command line, which should directly provide shell access, as shown in <em class="italic">Figure 14.14</em>. Testers have to note that in this example, we have used a known router that provides straight root access, which might not be the same with other devices. Devices manufactured recently will prompt a user to enter their username and password:</p>
    <figure class="mediaobject"><img src="../Images/B17765_14_14.png" alt=""/></figure>
    <p class="packt_figref">Figure 14.14: Accessing the device using the screen command</p>
    <p class="normal">It is always useful to understand a device from the debug logs: we have seen hardcoded credentials in plenty of IoT devices. We have learned how to connect to a device using a UART cable and communicate to the device as a highly privileged user. In the next section, we will explore cloning an RFID, which can be utilized during physical pen testing or a red team exercise.</p>
    <h1 id="_idParaDest-326" class="heading-1">Cloning RFID using ChameleonMini</h1>
    <p class="normal"><strong class="keyWord">RFID</strong> stands for <strong class="keyWord">Radio Frequency Identification</strong>, which utilizes radio waves to identify items. At a minimum, the RFID system contains a tag, a reader, and an antenna. There are active and passive RFID tags. Active RFID tags contain their own power source, giving them the ability to broadcast with a read range of up to 100 meters. Passive RFID tags do not have their own power source. Instead, they are powered by electromagnetic energy transmitted from the RFID reader.</p>
    <p class="normal"><strong class="keyWord">NFC</strong> stands for <strong class="keyWord">Near-Field Communication</strong>, which is a subset of RFID but with a high frequency. Both NFC and RFID operate at 13.56 MHz. NFC is also designed to run as an NFC reader and NFC tag, which is a unique feature of NFC devices that allows them to communicate with peers. In this section, we will explore one of the devices that comes in handy during physical pen testing/social engineering or a red team exercise to achieve a set objective. For example, if you are signed up to showcase the real threats of an organization that includes gaining access to an organization’s office premises or data centers or boardrooms, you can use ChameleonMini to store six different UIDs in a credit-card-sized portable device:</p>
    <figure class="mediaobject"><img src="../Images/B17765_14_15.png" alt=""/></figure>
    <p class="packt_figref">Figure 14.15: ChameleonMini device/card cloner</p>
    <p class="normal">The ChameleonMini is a device created by ProxGrind, designed to analyze the security issues around NFC to emulate and clone contactless cards, read RFID tags, and also sniff RF data. For developers, it is freely programmable. This device can be purchased online at <a href="https://lab401.com/"><span class="url">https://lab401.com/</span></a>. In this example, we have used ProxGrind ChameleonMini RevG to demonstrate cloning a UID.</p>
    <p class="normal">In Kali Linux, we can validate the device by directly connecting with the USB. The <code class="inlineCode">lsusb</code> command should display the ChameleonMini as MCS, and every serial device connected to Kali Linux will be listed in <code class="inlineCode">/dev/</code>. In this case, our device is visible as a serial port named <code class="inlineCode">ttyACM0</code>, as shown in <em class="italic">Figure 14.16</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_14_16.png" alt=""/></figure>
    <p class="packt_figref">Figure 14.16: Identifying the device in Kali Linux</p>
    <p class="normal">We can communicate with the serial port directly using <code class="inlineCode">picocom</code> by running <code class="inlineCode">picocom --baud 115200 --echo /dev/ttyACM0</code> as shown in <em class="italic">Figure 14.17</em>. <code class="inlineCode">picocom</code> can be installed by running <code class="inlineCode">apt-get install picocom</code>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_14_17.png" alt=""/></figure>
    <p class="packt_figref">Figure 14.17: Connecting to the device using picocom at a baud rate of 115,200</p>
    <p class="normal">You will require the card that you want to clone. You can use a one-step action to clone the card by placing it on the ChameleonMini. Type <code class="inlineCode">CLONE</code> and the job is done, as shown in <em class="italic">Figure 14.18</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_14_18.png" alt="A picture containing chart  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 14.18: Successfully cloning a card with the configuration</p>
    <p class="normal">The <a id="_idIndexMarker1503"/>following <a id="_idIndexMarker1504"/>details provide the manual way of doing it:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Using the command line, do the following:<ul>
          <li class="bulletList">Once the serial port communication is established between Kali Linux and the device, type the <code class="inlineCode">HELP</code> command to display all the available commands for ChameleonMini.</li>
          <li class="bulletList">ChameleonMini comes with eight slots, each of which can act as an individual NFC card. The slots can be set by using the <code class="inlineCode">SETTINGS=</code> command. For example, we can set the slot to <code class="inlineCode">2</code> by typing the <code class="inlineCode">settings=2</code> command; it should return <code class="inlineCode">100:OK</code>.</li>
          <li class="bulletList">Run <code class="inlineCode">CONFIG?</code> to see the current configuration. The new device should return the following:
            <pre class="programlisting con"><code class="hljs-con">  101:OK WITH TEXT
  NONE
</code></pre>
          </li>
        </ul>
      </li>
      <li class="numberedList">The next step is to place the card reader into <em class="italic">reader</em> mode. This can be achieved by typing <code class="inlineCode">CONFIG=ISO14443A_READER</code>.</li>
      <li class="numberedList">Now we can place the card that needs to be cloned in the card reader and type the <code class="inlineCode">Identify</code> command.</li>
      <li class="numberedList">Once you identify the type of the card, you can set the configuration using the <code class="inlineCode">CONFIG</code> command: in our case, it is MIFARE Classic 1K, so we will run <code class="inlineCode">CONFIG=</code> <code class="inlineCode">MF_CLASSIC_1K</code>.</li>
      <li class="numberedList">Now we have set the configuration, we can steal the UID from the card and then add it to our ChameleonMini by running <code class="inlineCode">UID=CARD NUMBER</code>, as shown in <em class="italic">Figure 14.19</em>:<figure class="mediaobject"><img src="../Images/B17765_14_19.png" alt=""/></figure>
        <div/>
        <p class="packt_figref">Figure 14.19: Cloning the card manually</p>
      </li>
      <li class="numberedList">We <a id="_idIndexMarker1505"/>are now all set to use the ChameleonMini as a card.</li>
      <li class="numberedList">Pentesters <a id="_idIndexMarker1506"/>can also pre-program this to perform the cloning tasks with the use of two buttons on the device while on the move. For example, during social engineering, while the testers talk to the victim company’s staff, they click the button and clone their (NFC) ID cards. This can be performed by the following commands:<ul>
          <li class="bulletList"><code class="inlineCode">LBUTTON=CLONE</code>: This will set a click of the left-hand button to clone the card.</li>
          <li class="bulletList"><code class="inlineCode">RBUTTON=CYCLE_SETTINGS</code>: This will set a click of the right button to rotate the slots. For example, if CARD A is cloned to slot 1 and you wanted <a id="_idIndexMarker1507"/>to clone another card, this can be performed by clicking <a id="_idIndexMarker1508"/>the right-hand button, which will move the CARD A details to slot 2. Then, you can go ahead and press the left-hand button to clone the new card.</li>
        </ul>
      </li>
    </ol>
    <h2 id="_idParaDest-327" class="heading-2">Other tools</h2>
    <p class="normal">There are other tools, such <a id="_idIndexMarker1509"/>as HackRF One, which is a software-defined radio that can also be utilized by pentesters to perform any kind of radio sniffing or transmission of your own signals, or even replay the captured radio packets.</p>
    <p class="normal">We will take a brief example of sniffing a radio frequency in Kali Linux using HackRF One SDR. HackRF libraries need to be installed by running <code class="inlineCode">sudo apt install hackrf gqrx-sdr</code> in the terminal. Testers should be able to identify the device by running <code class="inlineCode">sudo hackrf_info</code> from the terminal. If the device is recognized, you should be able to see the following screenshot with the details of firmware, part ID, and so on:</p>
    <figure class="mediaobject"><img src="../Images/B17765_14_20.png" alt=""/></figure>
    <p class="packt_figref">Figure 14.20: Reading the HackRF device in Kali Linux</p>
    <p class="normal">Pentesters can <a id="_idIndexMarker1510"/>utilize the <code class="inlineCode">kalibrate</code> tool to scan any GSM base stations. This tool <a id="_idIndexMarker1511"/>can be downloaded from <a href="https://github.com/scateu/kalibrate-hackrf"><span class="url">https://github.com/scateu/kalibrate-hackrf</span></a> and can be built using the following commands:</p>
    <pre class="programlisting con"><code class="hljs-con">git clone https://github.com/scateu/kalibrate-hackrf
cd kalibrate-hackrf
./bootstrap
./configure
./make &amp;&amp; make install
</code></pre>
    <p class="normal">Once the installation is complete, <code class="inlineCode">sudo kal</code> will be the tool to utilize to scan a specific band. We will be utilizing the root terminal to run the commands since it has to invoke the hardware, and we can run the tool by mentioning the frequency (<code class="inlineCode">kal –s GSM900</code>), as shown in <em class="italic">Figure 14.21</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_14_21.png" alt=""/></figure>
    <p class="packt_figref">Figure 14.21: Scanning the GSM channels using HackRF within Kali Linux</p>
    <p class="normal">If the testers <a id="_idIndexMarker1512"/>can identify the type of peripherals during an on-site assessment and find that the company is utilizing certain vulnerable hardware, then they can also utilize Crazyradio PA, a long-range 2.4 GHz USB radio dongle that can deliver a payload to any computer that is using the vulnerable device through radio wireless signals.</p>
    <h1 id="_idParaDest-328" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, we took a quick journey into basic embedded systems and their architecture, and we learned about different types of firmware, bootloaders, UART, radio sniffing, and common tools that can be utilized during hardware hacking. We also learned how to unpack firmware and load new firmware on a router using USB JTAG NT. Additionally, we explored using RouterSploit to identify the specific vulnerabilities in the embedded devices. Finally, we learned how to clone a physical RFID/NFC card using a ChameleonMini, which can be utilized during red teaming exercises.</p>
    <p class="normal">We hope this book has helped you to understand the fundamental risks and how attackers use these tools to compromise networks/devices within a few seconds, and how you can use the same tools and techniques to understand your infrastructure’s vulnerabilities, as well as the importance of remediation and patch management before your own infrastructure is compromised. On that note, this chapter concludes <em class="italic">Mastering Kali Linux for Advanced Penetration Testing – Fourth Edition</em>.</p>
  </div>
</body></html>