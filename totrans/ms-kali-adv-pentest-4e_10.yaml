- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exploitation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The key purpose of a penetration test is to exploit a data system and gain
    the credentials or direct access to the data of interest. It is exploitation that
    gives penetration testing its meaning. In this chapter, we will examine various
    means of exploiting systems, including both public exploits and available exploit
    frameworks. By the end of this chapter, you should be able to understand the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The Metasploit Framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The exploitation of targets using Metasploit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using public exploits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing sample Windows-specific exploits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Empire PowerShell Framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Metasploit Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Metasploit Framework** (**MSF**) is an open-source tool designed to facilitate
    penetration testing. Written in the Ruby programming language, it uses a modular
    approach to facilitating exploits during the exploitation phase in cyber kill
    chain methodology. This makes it easier to develop and code exploits, and it also
    allows for complex attacks to be easily implemented.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 10.1* depicts an overview of the MSF architecture and components:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/B17765_10_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.1: Metasploit architecture and its components'
  prefs: []
  type: TYPE_NORMAL
- en: 'The framework can be split into three main sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MSF is built using various functions and libraries and a programming language,
    such as Ruby. To utilize these functions, penetration testers must understand
    what these functions are, how to trigger them, what parameters should be passed
    to the function, and what the expected results are.
  prefs: []
  type: TYPE_NORMAL
- en: 'All of the libraries are listed in the `/usr/share/Metasploit-framework/lib/`
    folder, as shown in *Figure 10.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text  Description automatically generated](../Images/B17765_10_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.2: Metasploit libraries folder'
  prefs: []
  type: TYPE_NORMAL
- en: REX
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: REX is a library included in Metasploit that was initially developed by Jackob
    Hanmack and was made official by the Rapid 7 development team later on. This library
    provides various classes that are useful for exploit development. In the current
    MSF, REX handles all of the core functions such as socket connections, raw functions,
    and other reformatting.
  prefs: []
  type: TYPE_NORMAL
- en: Framework core
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This library is located in `/usr/share/metasploit-framework/lib/msf/core`, which
    provides the basic **Application Programming Interface** (**API**) for all the
    new modules that are going to be written.
  prefs: []
  type: TYPE_NORMAL
- en: Framework base
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This library provides a good API for sessions, a shell, Meterpreter, VNC, and
    other default APIs, but it is dependent on Framework core.
  prefs: []
  type: TYPE_NORMAL
- en: Other extended parts that can be a part of MSF include custom plugins, protocol
    tools, security tools, web services, and other integration services.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MSF used to have multiple interfaces, such as a command-line interface, web
    interface, and others. All of the interfaces were sunset by the Rapid 7 development
    team in the latest versions (Community and Pro). In this chapter, we will explore
    the console and GUI (Armitage) interfaces. The console interface is the fastest
    because it presents attack commands, and it has the required configuration parameters
    in an easy-to-use interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'To access this interface, enter `sudo msfconsole` in a command prompt. *Figure
    10.3* shows the splash screen that appears when the application launches:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, chart  Description automatically generated](../Images/B17765_10_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.3: Metasploit console main menu'
  prefs: []
  type: TYPE_NORMAL
- en: Modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'MSF consists of modules that are combined to affect an exploit. The modules
    and their specific functions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exploits**: The code fragments that target specific vulnerabilities. Active
    exploits will exploit a specific target, run until completed, and then exit (for
    example, a buffer overflow). Passive exploits wait for incoming hosts, such as
    web browsers or FTP clients, and exploit them when they connect.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Payloads**: These are the malicious code that implement commands immediately
    following a successful exploitation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Auxiliary modules**: These modules do not establish or directly support access
    between the tester and the target system; instead, they perform related functions
    such as scanning, fuzzing, or sniffing, which support the exploitation phase.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Post modules**: Following a successful attack, these modules run on compromised
    targets to gather useful data and pivot the attacker deeper into the target network.
    We will learn more about the post modules in *Chapter 11*, *Action on the Objective
    and Lateral Movement*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Encoders**: When exploits must bypass antivirus defenses, these modules encode
    the payload so that it cannot be detected using signature matching techniques.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**No operations** (**NOPs**): These are used to facilitate buffer overflows
    during attacks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These modules are used together to conduct reconnaissance and launch attacks
    against targets. The steps for exploiting a target system using MSF can be summarized
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Choose and configure an exploit (the code that compromises a specific vulnerability
    on the target system).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the target system to determine whether it is susceptible to attack by
    the exploit. This step is optional and is usually omitted to minimize detection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose and configure the payload (the code that will be executed on the target
    system following a successful exploitation; for example, a reverse shell from
    the compromised system back to the source).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose an encoding technique to bypass detection controls (IDs/IPs or antivirus
    software).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute the exploit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Database setup and configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is fairly simple to set up the new version of Metasploit, since Metasploit
    does not run as a service anymore, since version `msf3`:'
  prefs: []
  type: TYPE_NORMAL
- en: Start PostgreSQL by running `sudo systemctl start postgresql.service` in the
    terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initialize the Metasploit database by running `sudo msfdb init`. Unless it is
    your first time doing this, the initialization will create the `msf` database,
    create a role, and add the `msf_test` and `msf` databases to the `/usr/share/metasploit-framework/config/database.yml`
    configuration file; otherwise, by default, the `msf` database will be created
    in the prebuild of Kali Linux, as shown in *Figure 10.4*:![Text  Description automatically
    generated](../Images/B17765_10_04.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 10.4: Initializing the Metasploit database'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, you are ready to access `msfconsole`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once inside the console, you can verify the status of the database by typing
    `db_status`. You should be able to see the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the case of there being multiple targets, all of which are different company
    units, or maybe two different companies, it is a good practice to create a workspace
    within Metasploit. This can be achieved by running the `workspace` command in
    the `msfconsole`. The following extract shows the help menu, where you can add/delete
    workspaces so that you can organize these exploits to achieve your objective:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following example represents a simple **Unreal IRCD** attack against the
    target Linux-based operating system. When installed as a virtual machine (covered
    in *Chapter 1*, *Goal-Based Penetration Testing*), Metasploitable3 Ubuntu running
    on 10.10.10.8 can be scanned using the `db_nmap` command, which identifies open
    ports and associated applications. An excerpt of the `db_nmap` scan is shown in
    *Figure 10.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![Text  Description automatically generated](../Images/B17765_10_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.5: Running db_nmap scans within Metasploit'
  prefs: []
  type: TYPE_NORMAL
- en: When the --save option is used, all the output of the scan results will be saved
    in `/root/.msf4/local/ folder`. Several applications were identified by `nmap`
    in the preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: If the scan was completed using `nmap` separately, those results can also be
    imported into Metasploit using the `db_import` command. The `nmap` output will
    normally produce three types of output, that is, `xml`, `nmap`, and `gnmap`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `.xml` format can be imported into the database using the Nmap `nokogiri`
    parser. Once the results have been imported into the database, multiple options
    can be utilized in the case of a large `nmap` dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](../Images/B17765_10_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.6: Importing independent Nmap scans into Metasploit'
  prefs: []
  type: TYPE_NORMAL
- en: 'As a tester, we should investigate each one for any known vulnerabilities.
    If we run the `services` command in the `msfconsole`, the database should include
    the host and its listed services, as shown in *Figure 10.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text  Description automatically generated](../Images/B17765_10_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.7: Listing all the services within Metasploit'
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the first places to start is Metasploit’s own collection of exploits.
    This can be searched from the command line using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The search returned a particular exploit for the `UnrealIRCd` service. *Figure
    10.8* shows an excerpt of the exploit that’s available. If the testers choose
    to exploit any other listed service, they can search for keywords in Metasploit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application, chat or text message  Description
    automatically generated](../Images/B17765_10_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.8: Keyword searching within the Metasploit console for exploits'
  prefs: []
  type: TYPE_NORMAL
- en: The new version of Metasploit indexes modules and allows testers to just enter
    the number in the index to use it. The `exploit/unix/irc/unreal_ircd_3281_backdoor`
    exploit was selected for use in the remainder of this example because it is ranked
    as excellent. This ranking was determined by the Metasploit development team and
    identifies how reliably the exploit works for a skilled tester against a stable
    target system. In real life, multiple variables (tester skills, protective devices
    on the network, and modifications to the operating system and hosted applications)
    can work together to significantly alter the reliability of the exploit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additional information pertaining to that exploit was obtained using the following
    `info` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The returned information includes references as well as the information that’s
    shown in *Figure 10.9*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated with medium confidence](../Images/B17765_10_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.9: Detailed information about the exploit using the info command'
  prefs: []
  type: TYPE_NORMAL
- en: 'To instruct Metasploit that we will attack the target with this exploit, we
    issue the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Metasploit changes the command prompt from `msf>` to `msf exploit(unix/irc/unreal_ircd_3281_backdoor)
    >`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Metasploit prompts the tester to select the payload (a reverse shell from the
    compromised system back to the attacker) and sets the other variables, which are
    listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Remote host** (**RHOST**): This is the IP address of the system being attacked.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Remote port** (**RPORT**): This is the port number that is used for the exploit.
    In this case, we can see that the service has been exploited on default port `6667`,
    but in our case, the same service is running on port `6697`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Local host** (**LHOST**): This is the IP address of the system that’s used
    to launch the attack.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The attack is launched by entering the `exploit` command at the Metasploit prompt
    after all variables have been set. Metasploit initiates the attack and confirms
    that a reverse shell between Kali Linux and the target system is open. In other
    exploits, a successful exploit is presented by using `command shell 1 opened`
    and giving the IP addresses that originate and terminate the reverse shell.
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify that a shell is present, the tester can issue queries for the hostname,
    username (`uname -a`), and `whoami` to confirm that the results are specific to
    the target system that is located at a remote location. Take a look at *Figure
    10.10*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](../Images/B17765_10_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.10: Successfully exploiting UnrealIRC using Metasploit with a reverse
    shell'
  prefs: []
  type: TYPE_NORMAL
- en: This exploit can further be explored by using post-exploit modules. Run Meterpreter
    in the background by pressing *Ctrl* + *Z*. You should receive `Background session
    1? [y/N] y enter y`.
  prefs: []
  type: TYPE_NORMAL
- en: When a system is compromised to this extent, it is ready for the post-exploitation
    activities (see *Chapter 11*, *Action on the Objective and Lateral Movement*,
    and *Chapter 13*, *Command and Control*, to find out how to escalate the privilege
    and maintain access to the system).
  prefs: []
  type: TYPE_NORMAL
- en: Exploiting targets using MSF
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MSF is equally effective against vulnerabilities in the operating system as
    well as third-party applications. We will take an example for both scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Single targets using a simple reverse shell
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this example, we’ll exploit two different vulnerabilities. The first one
    is the famous ProxyLogon vulnerability that the Hafnium threat actor group exploited
    by misuing Microsoft Exchange Server in March 2021, which stormed the internet
    and led to many cybersecurity incidents and also financial fraud around the globe.
    There are four vulnerabilities that were primarily exploited:'
  prefs: []
  type: TYPE_NORMAL
- en: '**CVE-2021-26855**: **Server Side Request Forgery** (**SSRF**) – Where attackers
    are able to submit specifically crafted HTTP requests remotely without any authentication
    and the server accepts untrusted connections on TCP port `443`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CVE-2021-26857** – An insecure deserialization vulnerability within the Microsoft
    Exchange **Unified Messaging Service** (**UMS**), allowing attackers to run malicious
    code under a high-privilege SYSTEM account. This can be exploited either with
    SSRF or stolen credentials.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CVE-2021-26858** and **CVE-2021-27065** – These both relate to arbitrary
    file write vulnerability to write files to a given directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following example, we will be demonstrating a combination of **CVE-2021-26855**,
    to bypass the authentication and additionally impersonate an administrator account,
    and **CVE-2021-27065** to write an arbitrary file with the payload to provide
    us with remote code execution on the server.
  prefs: []
  type: TYPE_NORMAL
- en: As the first step, attackers will need the target running on-premises Microsoft
    Exchange Server exposed and enumerate all the email addresses to perform a successful
    attack. Testers can leverage the Python ProxyShell enumeration script to list
    all the users who are connected to the Exchange servers. This script is available
    at [https://github.com/PacktPublishing/Mastering-Kali-Linux-for-Advanced-Penetration-Testing-4E/blob/main/Chapter%2010/ProxyShell-enumerate.py](https://github.com/PacktPublishing/Mastering-Kali-Linux-for-Advanced-Penetration-Testing-4E/blob/main/Chapter%2010/ProxyShell-enumerate.py).
  prefs: []
  type: TYPE_NORMAL
- en: 'Attackers can run `python3 proxyshell-enumerate.py –u <Exchange server IP`>.
    The output of the script against the target should display all the email addresses
    within the Exchange server, as seen in *Figure 10.11*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/B17765_10_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.11: Enumeration of user email addresses on the Exchange server'
  prefs: []
  type: TYPE_NORMAL
- en: 'To initiate this attack, the first step is to open MSF by running the following,
    as shown in *Figure 10.12*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/B17765_10_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.12: Running the exploit on the Exchange vulnerability'
  prefs: []
  type: TYPE_NORMAL
- en: If there are any error messages or if the exploit is completed without a Meterpreter
    shell, ensure you disable Defender in the Microsoft Exchange Server by running
    `Set-MpPreference -DisableRealtimeMonitoring $true` in PowerShell as an administrator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Successful exploitation results in arbitrary code execution under the context
    of the high-privileged SYSTEM user. Successful execution of the code should provide
    you with the Meterpreter shell shown in *Figure 10.13*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/B17765_10_13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.13: Successful exploitation leading to the Meterpreter HTTPS reverse
    shell'
  prefs: []
  type: TYPE_NORMAL
- en: 'When the exploit is completed, it should open up the Meterpreter reverse shell
    between two systems. The Meterpreter prompt session will be opened up and the
    tester can effectively access the remote system with a command shell. One of the
    first steps after the compromise is to verify that you are on the target system.
    As you can see in *Figure 10.14*, the `sysinfo` command identifies the computer
    name and operating system, verifying a successful attack:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/B17765_10_14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.14: System information of the compromised server'
  prefs: []
  type: TYPE_NORMAL
- en: The second exploit that we will explore in this section is MS070-10, which rocked
    the world with WannaCry ransomware by exploiting EternalBlue back in April 2017\.
    The vulnerability exists in the way the SMB version was implemented in Windows,
    specifically, SMBv1 and NBT over TCP ports `445` and port `139` – which is used
    to share data in a secure way.
  prefs: []
  type: TYPE_NORMAL
- en: 'A successful exploit results in an adversary being able to run arbitrary code
    on the remote system. Although this exploit is old, many organizations still have
    to rely on some legacy systems. This might be due to various reasons, such as
    OEM dependency or the business simply cannot get rid of of old systems, such as
    Windows XP, 7, 2003, Windows 2008, and Windows 2008 R2\. To demonstrate how easy
    it is to exploit these legacy systems, we would utilize Metasploitable3 (running
    on `10.10.10.4`) to conduct this exploitation by setting the following in the
    Kali terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/B17765_10_15.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.15: Exploitation of EternalBlue using Metasploit'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, exploitation should provide us with a similar Meterpreter shell to
    what we saw in the previous exploit. The `hashdump` command should disclose all
    the usernames and password hashes, as shown in *Figure 10.16*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated with low
    confidence](../Images/B17765_10_16.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.16: Extracting usernames and hashes using hashdump within Meterpreter'
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, to store this information for the enhancement of lateral movement
    within the network, testers can utilize the `incognito` and `kiwi` modules within
    the `msfconsole`.
  prefs: []
  type: TYPE_NORMAL
- en: Exploiting multiple targets using MSF resource files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'MSF resource files are basically line-separated text files that include a sequence
    of commands that need to be executed in `msfconsole`. Let’s go ahead and create
    a resource file that can exploit the same vulnerability on multiple hosts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Save the file as `multiexploit.rc`. Now you are ready to invoke the resource
    file by running `msfconsole -r filename.rc`, where `-r` refers to the resource
    file. The preceding resource file will exploit the same vulnerability sequentially.
    Once the first exploit is complete, the specification of `exploit -j` will move
    the running exploit to the background, allowing the next exploit to proceed. Once
    all of the targets’ exploitation is complete, we should be able to see multiple
    Meterpreter shells available in Metasploit.
  prefs: []
  type: TYPE_NORMAL
- en: If the exploit is designed to run only on one host, it may not be possible to
    enter multiple hosts or IP ranges in the exploit. However, the alternative is
    to run the same exploit with different port numbers per host. We will be discussing
    pre-existing MSF resource files that can be utilized while escalating privileges
    in more detail in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Using public exploits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every attacker always has their eyes out, looking for public exploits and modifying
    them according to their requirements. The latest exploit was on August 6, 2021,
    that is, ProxyLogon, which shook most of the companies running on-premises Exchange
    servers that host all their mission-critical business emails, thus creating an
    awareness of what information theft malware is all about. However, in this section,
    we will take a deep dive into utilizing known available exploit forums and also
    how we can onboard them into our Kali Linux system.
  prefs: []
  type: TYPE_NORMAL
- en: Locating and verifying publicly available exploits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many a time, penetration testers find a zero-day exploit during their tests,
    which they normally inform the company of. However, in the case of real attackers,
    any vulnerabilities that are found will be made into an exploit, which is then
    sold for money/fame to companies such as VUPEN. One of the important aspects of
    penetration testing is to find publicly available exploits on the internet and
    provide proof of concept.
  prefs: []
  type: TYPE_NORMAL
- en: 'The initial exploit database that was born on the internet was Milw0rm. Using
    the same concept, we can see multiple similar databases that can be utilized by
    the penetration testing community. The following is a list of places where attackers
    would primarily look for exploits:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exploit-DB** (**EDB**): The name says it all—it is a database archive of
    public exploits on the internet, along with the software versions that are vulnerable.
    EDB was developed by vulnerability researchers and penetration testers, who are
    driven by the community.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Penetration testers often use Exploit-DB as a proof of concept rather than
    an advisory tool, making it more valuable during a penetration test or red team
    exercise:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: EDB is embedded into Kali Linux 2.0 as part of the build release and it has
    made it fairly simple to search for all the available exploits through SearchSploit.
    The advantage of EDB is that it’s also **common vulnerabilities and exposures **(**CVEs**)
    compatible. Wherever applicable, the exploits will include the CVE details.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SearchSploit:** SearchSploit is a simple utility in Kali Linux for finding
    all the exploits from EDB with a keyword search to narrow down an attack. Once
    you open the terminal and type `searchsploit exchange windows remote`, you should
    be able to see the following:![](../Images/B17765_10_17.png)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Figure 10.17: Searching for custom exploits from searchsploit'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Compiling and using exploits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Attackers will collate all the relevant exploits, publish and compile them,
    and make them ready to use as a weapon to exploit the target. In this section,
    we will take a deep dive into compiling different types of files and add all the
    exploits written in Ruby that have `msfcore` as the base of Metasploit modules.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling C files and executing exploits
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Older versions of exploits are written in C, especially buffer overflow attacks.
    Let’s look at an example of compiling a C file from the EDB and make an exploit
    for a vulnerable Apache server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Attackers can utilize a GNU compiler collection to compile a C file into an
    executable with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the file is compiled without any error or warning, attackers should be
    able to see the exploit running, as shown in *Figure 10.18*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/B17765_10_18.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.18: Compiling a C file and running it from EDB'
  prefs: []
  type: TYPE_NORMAL
- en: Adding the exploits that are written using the MSF as a base
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Copy the exploit file/script either from `exploit-db.com` directly from the
    browser or from `/usr/share/exploitdb/exploits/`, depending on the platform and
    the type of exploit you are running.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we will use `/usr/share/exploitdb/exploits/windows/remote/16756.rb`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the Ruby script as a custom exploit to the Metasploit module, move or copy
    the file to `/usr/share/metasploit-framework/modules/exploits/windows/http/`,
    and name the file `NewExploit.rb`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the file has been copied or moved to its new location, you must restart
    `msfconsole` just to ensure that the file has been loaded into the available module
    in Metasploit. You will be able to use the module with your custom name that you
    set as part of the available Metasploit module:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](../Images/B17765_10_19.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.19: Adding custom exploits to the Metasploit Framework from EDB'
  prefs: []
  type: TYPE_NORMAL
- en: That concludes adding an existing exploit in EDB to Metasploit. We will explore
    writing our own custom exploit in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Developing a Windows exploit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Exploit development is a tough art that requires attackers to have a fair bit
    of understanding of the assembly language and underlying system architecture.
    We can utilize the following five-stage approach to develop a custom exploit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Text, application  Description automatically generated](../Images/B17765_10_20.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.20: Five-stage custom exploit development'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will cover some basics that are required to develop a Windows
    exploit by building a vulnerable application. From the exploit development perspective,
    the following are the basic terms that penetration testers must understand when
    they develop an exploit:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Registers**: All of the processes execute via registers; these are used to
    store information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**x86**: This includes 32-bit systems that are mostly Intel-based; 64-bit systems
    are represented as x64.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Assembly language**: This includes low-level programming languages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Buffer**: This is a static memory holder in a program that stores data on
    top of the stack or heap.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Debugger**: Debuggers are the programs that can be utilized so that you can
    see the runtime of a program while executing. You can also use them to look at
    the state of registry and memory. Some of the tools that we will be using are
    immunity debuggers, GDB, and OllyDbg.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ShellCode**: This is the code that is created by the attackers in a successful
    exploitation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are the different types of registers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**EAX**: This is a 32-bit register that is used as an accumulator and stores
    data and operands.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**EBX**: This is a 32-bit base register and acts as a pointer to the data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ECX**: This is a 32-bit register that’s used for looping purposes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**EDX**: This is a 32-bit data register that stores I/O pointers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ESI/EDI**: These are 32-bit index registers that act as data pointers for
    all the memory operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**EBP**: This is a 32-bit stack data pointer register.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Extended Instruction Pointer** (**EIP**): This is a 32-bit program counter/instruction
    pointer that holds the next instruction to be executed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Extended Stack Pointer** (**ESP**): This is a 32-bit stack pointer register
    that points exactly to where the stack is pointing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SS**, **DS**, **ES**, **CS**, **FS**, and **GS**: These are 16-bit segment
    registers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NOP**: This stands for no operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JMP**: This stands for jump instructions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identify the vulnerability through fuzzing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Attackers must be able to identify the right fuzzing parameters in any given
    application to find a vulnerability and then exploit it. In this section, we will
    look at an example of a **vulnerable server**, which was created by Stephen Bradshaw.
  prefs: []
  type: TYPE_NORMAL
- en: This vulnerable software can be downloaded from [https://github.com/PacktPublishing/Mastering-Kali-Linux-for-Advanced-Penetration-Testing-4E/tree/main/Chapter%2010/](https://github.com/PacktPublishing/Mastering-Kali-Linux-for-Advanced-Penetration-Testing-4E/tree/main/Chapter%2010/)
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we will be using Windows 10 to host the vulnerable server.
    Once the application is downloaded, we will be unzipping the file and running
    the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'This should open TCP port `9999` for the remote clients to connect to. When
    the vulnerable server is up and running, you should be able to see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/B17765_10_21.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.21: Vulnerable server running on Windows 10'
  prefs: []
  type: TYPE_NORMAL
- en: 'Attackers can connect to the server on port `9999`, using `netcat` to communicate
    to the server from Kali Linux, as shown in *Figure 10.22*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/B17765_10_22.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.22: Connecting to the vulnerable server from Kali Linux'
  prefs: []
  type: TYPE_NORMAL
- en: Fuzzing is a technique in which attackers specifically send malformed packets
    to the target to generate errors in the application or create general failures.
    These failures indicate bugs that exist in the code written by the developer of
    the application.
  prefs: []
  type: TYPE_NORMAL
- en: The attacker can find out how it can be exploited to allow remote access by
    running their own code. Now that the application is accessible and everything
    is set, attackers can begin the art of fuzzing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although there are a number of fuzzing tools available, SPIKE is one of the
    defaults that is installed on Kali Linux. SPIKE is a fuzzing toolkit that’s used
    to create fuzzers by providing scripting capabilities; however, it is written
    in the C language. The following is a list of interpreters written in SPIKE that
    can be utilized:'
  prefs: []
  type: TYPE_NORMAL
- en: '`generic_chunked`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`generic_send_tcp`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`generic_send_udp`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`generic_web_server_fuzz`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`generic_web_server_fuzz2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`generic_listen_tcp`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SPIKE allows you to add your own set of scripts without having to write a few
    hundred lines of code in C. Other fuzzing tools that attackers can consider are
    Peach Fuzzer, BooFuzz, and FilFuzz.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once attackers connect to the target application, they should be able to see
    multiple options available in the vulnerable server, which they can then play
    with. This includes `STATS`, `RTIME`, `LTIME`, `SRUN`, `TRUN`, `GMON`, `GDOG`,
    `KSTET`, `GTER`, `HTER`, `LTER`, and `KSTAN` as part of valid commands that take
    input. We will utilize the `generic_send_tcp` interpreter to fuzz the application.
    The format to use the interpreter is as follows: `. /generic_send_tcp host port
    spike_script SKIPVAR SKIPSTR`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`host`: This is the target host or IP.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`port`: This is the port number to be connected to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spike_script`: This is the SPIKE script to run on the interpreter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SKIPVAR` and `SKIPSTR`: This allows the testers to jump into the middle of
    the fuzzing session, as defined in the SPIKE script.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As the key next step, let’s go ahead and create a simple SPIKE script for `readline`,
    run `SRUN`, and assign a string value as the parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The script will read the first line (`s_readline`) of the input after connecting
    to the IP/hostname and then run `SRUN`, along with a randomly generated value.
    Note that to run a SPIKE script, it must be saved with the `.spk` file format.
    Now let’s save the file with the above three lines as `exploitfuzzer.spk` and
    run the SPIKE script against the target, as shown in *Figure 10.23*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/B17765_10_23.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.23: Fuzzing the vulnerable server with SRUN'
  prefs: []
  type: TYPE_NORMAL
- en: 'After fuzzing the application, it confirms no server crash or anything similar,
    so the `SRUN` parameter is not vulnerable. The next step is to pick another one.
    This time, we will pick `TRUN` as the parameter to fuzz within the same script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the `exploitfuzz.spk` file and run the same command, as shown in *Figure
    10.24*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/B17765_10_24.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.24: Fuzzing the vulnerable server with TRUN'
  prefs: []
  type: TYPE_NORMAL
- en: Fuzzing the application with TRUN has resulted in the application crashing,
    so now we can confirm that this function can be abused and exploited. As a key
    next step, we must now debug and replicate the crash in a more verbose way.
  prefs: []
  type: TYPE_NORMAL
- en: Debug and replicate the crash
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'On the server side, we must debug the application. To perform debugging, we
    will download Immunity Debugger from [https://www.immunityinc.com/products/debugger/](https://www.immunityinc.com/products/debugger/).
    This debugger is used mostly in finding exploits, analyzing malware, and reverse
    engineering any binary files. The vulnerable server can be attached as a process
    to the debugger after running `vulnserver.exe` or can be directly executable and
    opened by the debugger, as shown in *Figure 10.25*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text  Description automatically generated](../Images/B17765_10_25.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.25: Loading vulnserver using Immunity Debugger'
  prefs: []
  type: TYPE_NORMAL
- en: Once the application runs through the debugger and the fuzzing script is run
    from our Kali Linux, as seen in *Figure 10.25*, you should now be able to see
    that the server has crashed on the victim’s PC.
  prefs: []
  type: TYPE_NORMAL
- en: 'The debugger also gives us some useful information on exception offset `41414141`, which
    we can take note of (which is converted as `AAAA`) in the **Registers** section
    within Immunity Debugger, as shown in *Figure 10.26*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](../Images/B17765_10_26.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.26: Registers after the vulnserver crash due to fuzzing'
  prefs: []
  type: TYPE_NORMAL
- en: 'To conduct the successful buffer overflow for the given application involves
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Finding the right length of the spiking
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fuzzing the right pattern
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finding the offset
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Overwriting the EIP
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finding the right address of the JMP ESP operation
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Checking for bad characters and placing a NOPS sled
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generating shellcode
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Setting up listeners and exploiting
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The first step is to identify exactly how many characters caused the server
    crash and what buffer size can be utilized. We will start debugging the application
    that has crashed and take a look at the ESP address in the **Registers** section,
    right-click within Immunity Debugger, and click on **Follow in Dump** to see where
    the payload was inserted initially and note down the memory address `00ACF1F0`,
    as shown in *Figure 10.27*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/B17765_10_27.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.27: Initial memory where the fuzzing began'
  prefs: []
  type: TYPE_NORMAL
- en: If we traverse all the way to the end where the fuzzing AAA stops, you will
    see `00ACFD98`, as seen in *Figure 10.28*. Note that these addresses will change
    according to the operating system that you utilize while debugging or disassembling
    the executable.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/B17765_10_28.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.28: End of the fuzzing memory address'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the start and end addresses, let’s use `python3` to identify
    the length of the buffer by running `python3` in the terminal and just simply
    put `0x00ACFD98` (the end of the memory address) and `0x00ACF1F0` (the start of
    the memory address), as seen below. It should provide us with the buffer length:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we have a buffer length of `2984`. The next stage is to control
    the execution of our exploit code.
  prefs: []
  type: TYPE_NORMAL
- en: Control the application execution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We now have the length of the buffer. The next step is to identify the right
    offset to EIP to control it. Let’s write a quick Python script to connect the
    vulnerable server with the exact length that crashed the server, save the file
    as `crash.py`, and run it against the target IP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The next step is to create a pattern using MSF by locating the `/usr/share/etasploit-framework/tools/exploit/`
    folder and running `./pattern_create -l 2984` in the Kali Linux terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can either output the content that is generated into a file or copy it
    from the terminal. Alternatively, you can add to your Python program by adding
    another variable. This time, we will disable the buffer and use the pattern that
    was created by the exploit tool with a length of `2984`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, running `crash.py` against the target will result in the server crashing
    again. However, all of the `A` characters are replaced by the pattern that was
    created. On the vulnerable server, we should be able to see the registers from
    Immunity Debugger, which provides the next instruction that will be stored in
    `EIP`, as shown in *Figure 10.29*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](../Images/B17765_10_29.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.29: EIP of the application after injecting the pattern'
  prefs: []
  type: TYPE_NORMAL
- en: That’s the end of fuzzing with the next EIP `386F4337`. To create a Windows-specific
    exploit, we must identify the right offset of the EIP. This can be extracted by
    exploit tools such as `pattern_offset`, which takes the input of the EIP with
    the same length that was used to create the pattern.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that an offset match was found in the pattern that was created with
    the EIP. Now, we know that buffer `2003` is enough to crash the server, and we
    can begin the overflow and see if we can overwrite the EIP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon execution of the preceding Python code from Kali Linux, you should see
    the EIP that we overwrote. If everything is correct, you should see the following
    on the server side with the EIP as `42424242` in the immunity debugger:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/B17765_10_30.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.30: Successfully overwriting the EIP address'
  prefs: []
  type: TYPE_NORMAL
- en: Identify the right bad characters and generate shellcode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our next task is to identify the address of JMP ESP, since our payload will
    be loaded into the ESP register. For that, we will utilize the `mona.py` script,
    which is a Python tool that speeds up searches while developing exploits. This
    tool can be downloaded directly from [https://github.com/PacktPublishing/Mastering-Kali-Linux-for-Advanced-Penetration-Testing-4E/blob/main/Chapter%2010/mona.py](https://github.com/PacktPublishing/Mastering-Kali-Linux-for-Advanced-Penetration-Testing-4E/blob/main/Chapter%2010/mona.py).
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon downloading the Python script, it should be placed in the `PyCommands`
    folder of Immunity Debugger’s installed location (`c:\program files(x86)\Immunity
    Inc\Immunity Debugger\Pycommands\`). Once the `mona.py` script is placed in PyCommands,
    testers need to reopen Immunity Debugger and run `!mona jmp –r esp` . in the Immunity
    terminal. That should display the JMP ESP. In our case, it is `0x62501203`, as
    shown in *Figure 10.31*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](../Images/B17765_10_31.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.31: Running mona to identify the JMP ESP address'
  prefs: []
  type: TYPE_NORMAL
- en: If the mona display goes away, just do `!mona help` in the same terminal within
    Immunity Debugger to bring the screen back. Now we are all set to create the payload.
  prefs: []
  type: TYPE_NORMAL
- en: You can use mona to identify bad chars. Testers can utilize any public material
    to find more ways to exploit the vulnerability. This topic deserves a book on
    its own.
  prefs: []
  type: TYPE_NORMAL
- en: To create a default array in mona, you can use `!mona bytearray`, which will
    generate output of two files named `bytearray.txt` and `bytearray.bin` with all
    the bad characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will go ahead and create a Windows payload with `''\x00''` as a bad character
    using `msfvenom` by running the following command in the terminal. This will generate
    a shellcode that will provide a Meterpreter reverse shell on the attacker’s IP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Obtain the shell
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finally, we are in the last stage of creating the full-fledged exploit—we just
    need to add a NOP sled and then overflow the buffer and write our shellcode to
    the system running the vulnerable application server. The following code extract
    is the full Python code for exploiting the vulnerable server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the final Python script as `exploit.py` and before you execute, ensure
    that your listener is up in Metasploit by running the following commands in the
    terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Everything is now set. Attackers will now be able to perform and craft a Windows-specific
    exploit using Python programming. The next step is to run `exploit.py` from the
    terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The successful exploitation will overwrite the buffer with our shellcode and
    then execute it to spawn a reverse shell to the attacker, as shown in *Figure
    10.32*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](../Images/B17765_10_32.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.32: Successful TCP reverse shell from vulnserver'
  prefs: []
  type: TYPE_NORMAL
- en: That concludes the five-stage approach to developing a Windows-specific exploit.
    We will explore the PowerShell Empire framework, which can be leveraged by attackers
    during post-exploitation activities.
  prefs: []
  type: TYPE_NORMAL
- en: PowerShell Empire framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The initial Empire tool was one of the most powerful post-exploitation tools,
    which was based on Python 2.7, but progress has been quiet for the last 3 years.
    The same fork of this project was picked up with active contributions from BC-Security
    and has now been rewritten in Python 3 and is used by penetration testers around
    the globe to perform a variety of different attacks in penetration tests to demonstrate
    system vulnerabilities. This tool runs PowerShell agents that, by nature, are
    persistent. It also utilizes other important tools, such as `mimikatz`. In this
    section, we will look closer at how to use PowerShell’s Empire framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'This tool can be installed by running `sudo apt install powershell-empire`
    in the terminal. Once the application is installed, testers should be able to
    see the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](../Images/B17765_10_33.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.33: PowerShell Empire’s main menu'
  prefs: []
  type: TYPE_NORMAL
- en: 'Attackers need to first run the server before connecting the client. So the
    first step would be to run `sudo powershell-empire server` and then run `sudo
    powershell-empire client`, and that should bring us to the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](../Images/B17765_10_34.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.34: PowerShell Empire’s client menu'
  prefs: []
  type: TYPE_NORMAL
- en: 'The current Empire tool has around 393 built-in modules. The following table
    provides a list of commands that are crucial when using the Powershell Empire
    tool, since it is similar to Metasploit; however, these commands are used in their
    own particular way:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Command** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `agents` | Access a list of agents that are connected |'
  prefs: []
  type: TYPE_TB
- en: '| `creds` | Add/display credentials to/from the database |'
  prefs: []
  type: TYPE_TB
- en: '| `exit` | Exit Empire |'
  prefs: []
  type: TYPE_TB
- en: '| `help` | Display the help menu |'
  prefs: []
  type: TYPE_TB
- en: '| `interact` | Interact with a particular agent |'
  prefs: []
  type: TYPE_TB
- en: '| `list` | List active agents or listeners |'
  prefs: []
  type: TYPE_TB
- en: '| `listeners` | Interact with active listeners |'
  prefs: []
  type: TYPE_TB
- en: '| `load` | Load Empire modules from a nonstandard folder |'
  prefs: []
  type: TYPE_TB
- en: '| `reload` | Reload one (or all) Empire modules |'
  prefs: []
  type: TYPE_TB
- en: '| `reset` | Reset a global option (for example, IP whitelists) |'
  prefs: []
  type: TYPE_TB
- en: '| `searchmodule` | Search Empire module names/descriptions |'
  prefs: []
  type: TYPE_TB
- en: '| `set` | Set a global option (for example, IP whitelists) |'
  prefs: []
  type: TYPE_TB
- en: '| `show` | Show a global option (for example, IP whitelists) |'
  prefs: []
  type: TYPE_TB
- en: '| `usemodule` | Use an Empire module |'
  prefs: []
  type: TYPE_TB
- en: '| `usestager` | Use an Empire stager |'
  prefs: []
  type: TYPE_TB
- en: 'Table 10.1: PoweShell Empire commands'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four important roles that the Empire tool consists of:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listeners**: This is similar to the Meterpreter listener, waiting for the
    connection from the compromised systems. Listener management provides the interface
    to create listeners locally with different types—`dbx`, `http`, `http_com`, `http_foreign`,
    `http_hop`, and `meterpreter`. We will explore `http`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stagers**: Stagers provide a list of modules for macOS (OS X), Windows, and
    other operating systems. These are DLLs, macros, one-liners, and others that can
    be utilized using an external device to perform more informed social engineering
    and physical console attacks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Agents**: The agents are the zombies that connect to the listeners. All of
    the agents can be accessed by running the `agent` command, which will take us
    straight to the agents menu.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Logging and downloads**: This section can only be accessed when a successful
    agent is connected to the listeners. Similar to Meterpreter, the Empire tool allows
    us to run `mimikatz` on the local machine via PowerShell and export the details
    to perform more focused attacks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first thing we must do is set up the local listeners. The `listeners` command
    will help us jump to the listener menu. If there are any active listeners, then
    those will be displayed. Use the `listener http` command to create a listener,
    as shown in *Figure 10.35*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text  Description automatically generated](../Images/B17765_10_35.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.35: Different types of listeners'
  prefs: []
  type: TYPE_NORMAL
- en: By running the following within the PowerShell Empire client terminal, you should
    set up the Empire listener.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the listeners have been selected, by default, port `80` is set. If you
    are running an HTTP service, you can change the port number by typing `set Port
    portnumber`. Always remember that all of the commands in the Empire tool are case-sensitive.
    You can utilize the tab feature, which will autocorrect the command and provide
    options. To get the stager, use the `usestager multi/launcher` and then set the
    `Listener` to `http`, as seen in *Figure 10.36*, and that’s it. When we run the
    `execute` command, we should have the PowerShell script that we can run on the
    target machines:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](../Images/B17765_10_36.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.36: Successfully creating a payload using the stagers'
  prefs: []
  type: TYPE_NORMAL
- en: We have now explored the PowerShell Empire framework. We will be taking a deep
    dive into this tool in the coming chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we focused on the fundamentals of exploitation and the different
    tools that convert findings from reconnaissance into a defined action that establishes
    the right connection between the tester and the target.
  prefs: []
  type: TYPE_NORMAL
- en: Kali provides several tools to facilitate the development, selection, and activation
    of exploits, including the internal Exploit-DB as well as several frameworks that
    simplify the use and management of these exploits. We took a deep dive into the
    MSF and learned how to compile different types of files from Exploit-DB into a
    real exploit.
  prefs: []
  type: TYPE_NORMAL
- en: We also focused on how to develop Windows exploits by identifying different
    fuzzing techniques. We also loaded the shell code into the custom exploits. Additionally,
    we took a quick tour using the PowerShell Empire tool, which can be instrumental
    for pentesters once the exploitation phase is complete.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter (*Chapter 11*, *Action on the Objective and Lateral Movement*),
    we will learn about the most important part of the attackers’ cyber kill chain
    as well as post-exploitation, privilege escalation, lateral movement in the network,
    compromising domain trusts, and port forwarding.
  prefs: []
  type: TYPE_NORMAL
