- en: Chapter 11. WPS and Probes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '|   | *"Nothing is new under the sun."* |   |'
  prefs: []
  type: TYPE_TB
- en: '|   | --*Popular Saying* |'
  prefs: []
  type: TYPE_TB
- en: '*This chapter incorporates the new techniques related to attacking WPS and
    probe monitoring and also covers the pineapple tool that makes much of wireless
    testing a lot easier. These attacks and tools have appeared since the publication
    of the original book, and we''ll be making sure we''re being as holistic as possible.*'
  prefs: []
  type: TYPE_NORMAL
- en: WPS attacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Wireless Protected Setup** (**WPS**) was introduced in 2006 to help users
    without wireless knowledge to have secure networks. The idea was that their Wi-Fi
    device would have a single hidden hardcoded value that would allow access with
    key memorization. New devices would be authenticated through a button press on
    the Wi-Fi router. Individuals outside the house without access to the device would
    not be able to have access, thus reducing the issues surrounding remembering WPA
    keys or setting short ones.'
  prefs: []
  type: TYPE_NORMAL
- en: In late 2011, a security vulnerability was disclosed enabling brute-force attacks
    on the WPS authentication system. The traffic required to negotiate a WPS exchange
    was spoofable, and the WPS pin itself is only eight characters between 0-9\. To
    start with, this provides only 100,000,000 possibilities in comparison with an
    eight-character azAZ09 password having 218,340,105,584,896 combinations.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there are further vulnerabilities:'
  prefs: []
  type: TYPE_NORMAL
- en: Of the eight characters of the WPS pin, the last character is a checksum of
    the previous seven and therefore predictable, leaving a maximum of 10,000,000
    options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition, the first four and the following three of the remaining characters
    are checked separately, which means that there are 104 + 103 options or 11,000
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Through the two decisions made in the authentication mechanism, we have gone
    from 100,000,000 possible combinations to 11,000\. This equates to a six-hour
    difference when brute-forcing the algorithm. It is these decisions that make attacks
    against WPS viable.
  prefs: []
  type: TYPE_NORMAL
- en: In the next lab exercise, we will go through identifying and attacking vulnerable
    WPS setups with Wash and Reaver.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – WPS attack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow the given instructions to get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Before we attack a WPS-enabled access point, we need to create one. The TP-Link
    we use has this feature turned on by default, which is worrying but handy. To
    double-check this, we can log onto our router and click on **WPS**. It should
    look like the following:![Time for action – WPS attack](graphics/B09903_11_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now we''ve confirmed that it''s ready. We need to set up our target. We need
    to set up our testing environment. We''re going to use the Wash tool, and Wash
    requires a monitoring interface to function. As we have done many times before,
    we need to set up one with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Time for action – WPS attack](graphics/B09903_11_02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'We have a monitoring interface set up as `wlan0mon`, and we can call Wash with
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Time for action – WPS attack](graphics/B09903_11_03.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Wash will display all the nearby devices that support WPS as well as whether
    they have WPS active or unlocked and what version is running:![Time for action
    – WPS attack](graphics/B09903_11_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can see the `Wireless Lab` network supports WPS. It uses version 1 and it''s
    not locked. Fantastic. We take note of the MAC address, which in my case is `E8:94:F6:62:1E:8E`,
    as this will be used to target our next tool: `reaver`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Reaver attempts to brute-force the WPS pin for a given MAC address. The syntax
    for starting this is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Time for action – WPS attack](graphics/B09903_11_05.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Once it is started, the tool runs through all the possible combinations for
    the WPS and attempts to authenticate. Once it does this, it will return the WPS
    code and the password, as shown in the following screenshot:![Time for action
    – WPS attack](graphics/B09903_11_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With WPA-PSK in hand, we can authenticate normally now. I left my device with
    the default WPA-PSK that matches the WPS pin. If, however, you want to authenticate
    with the WPS pin, you can do this by specifying the pin in `reaver` with the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Replace my pin with your own.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We successfully identified a wireless network with a vulnerable instance of
    WPS active with Wash. We then used Reaver to recover the WPA key and the WPS pin.
    With this information, we could then authenticate with the network and continue
    a network penetration test.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero – rate limiting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous exercise, we attacked an entirely unprotected WPS installation.
    There are multiple methods that can be used to further secure installations without
    removing WPS altogether.
  prefs: []
  type: TYPE_NORMAL
- en: Make an attempt to set the WPS pin to an arbitrary value and try again, to see
    whether Reaver is as effective at cracking it.
  prefs: []
  type: TYPE_NORMAL
- en: Acquire a wireless router that allows you to rate-limit the WPS attempts. Try
    and configure your attack to avoid triggering lockouts.
  prefs: []
  type: TYPE_NORMAL
- en: Probe sniffing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have spoken about probes previously, and how they can be used to identify
    hidden networks and perform effective rogue access point attacks. They can also
    be used to identify individuals as targets or track them on a mass scale with
    minimal equipment.
  prefs: []
  type: TYPE_NORMAL
- en: When a device wishes to connect to a network, it sends a probe request that
    contains its own MAC address and the name of the network it wishes to connect
    to. We can use tools such as `airodump-ng` to track these. However, if we wish
    to identify whether an individual was present at a specific location at a specific
    time or look for trends in Wi-Fi usage, we will need to use a different approach.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will utilize `tshark` and Python to collect data. You will
    receive the code and an explanation of what is being done.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – collecting data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow the given instructions to get started:'
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we need a device that's looking for multiple networks. Generally,
    a normal smartphone such as an Android device or iPhone will do the trick. Desktops
    don't generally make good targets as they tend to remain in one location. Newer
    iPhones and Android devices may have probe requests disabled or obfuscated, so
    do check before you give up.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you have your device, make sure the Wi-Fi is turned on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then set up your monitoring interface as we have done many times before:![Time
    for action – collecting data](graphics/B09903_11_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The next thing to be done is to look for probe requests with `tshark` via the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The screenshot of the following command is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Time for action – collecting data](graphics/B09903_11_08.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Your output at this point is a little rough, as the default output from `tshark`
    is not designed to be readable, just to have as much information in it as possible.
    It should look like the following:![Time for action – collecting data](graphics/B09903_11_09.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can clearly see the MAC address and SSID of the probe request; however,
    this output can be improved. We can use the following command to make it more
    readable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The screenshot of the following command is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Time for action – collecting data](graphics/B09903_11_10.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: The output here is much more readable:![Time for action – collecting data](graphics/B09903_11_11.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'So, now we have the output in a readable format, what next? What we do is create
    a Python script that will run the command and record the output for later analysis.
    Before running the code, you will need to ensure that you have your monitoring
    interface ready and that a file called `results.txt` is created in the directory
    you are in. The Python script is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s get briefed on the Python script:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`import subprocess` and `import datetime`: This allow us to refer to the `subprocess`
    and `datetime` libraries. The `subprocess` library allows us to monitor the interface
    from the Linux command line, and `datetime` allows us to get the accurate time
    and date readings.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`results = open("results.txt", "a")`: This opens a file with the append rights
    and assigns it to `results`. The append rights only allow the script to add to
    the contents of the file. This stops the file from constantly being overwritten.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`while 1`: This line means run until stopped.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cmd = subprocess.check_output(["tshark –n –i wlan0mon –T fields -e wlan.sa
    –e wlan.ssid –c 100"], shell=True)`: This opens a shell to perform our previously
    tested `tshark` command. The only difference this time is `-c 100`. What this
    flag does is limit the command to 100 queries. This allows us to return the results
    to ourselves without having to stop the program. Since we said run forever after
    writing the results, the script will restart again. This line takes the output
    from the shell and assigns it to the variable `cmd`. The script will display a
    count to 100, stop, and then restart. This means that if you want it to end, you
    have to kill the process.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`split = cmd.split("\n")`: This takes the variable and splits it by line.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`for value in split[:-1]`: This repeats the following action for each line
    in the output, ignoring the first line that contains headers.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`if value.strip()`: This checks to see if the value is empty before continuing
    to account for non-probe requests.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`value = value.split("\t")`: This breaks each line into further smaller chunks
    using the tab character as the delimiter.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following three lines take each chunk of text and assign it to a variable:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '`results.write(MAC+" "+SSID+" "+time+"\r\n")`: This takes all the values, writes
    them to a file separated by spaces, and ends with a return and a new line for
    neatness. The output will be neat lines of text written to the file.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We took the input from probe requests and output them to a file using Python.
    You may ask yourself what the purpose of this is. This can be achieved by simply
    performing the original `tshark` command and adding a `>> results.txt` command
    to the end. You would be correct; however, what we have created is a framework
    for integration with other tools, visualization platforms, databases, and services.
  prefs: []
  type: TYPE_NORMAL
- en: For example, using the WiGLE database that maps SSIDs to locations, you can
    add a few lines of code to take the SSID variable and query the WiGLE database.
    Alternatively, you could set up a MySQL database and output the results there
    to perform the SQL commands on it. This section has provided you with the first
    steps to create your own probe-monitoring tools. Through experimentation and using
    this simple code as the first step, a multitude of useful tools can be created.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero – extension ideas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Research which tools are available that allow visualization or data analytics
    and are easily integrated with Python. Tools such as Maltego have free versions
    that can be used to plot information.
  prefs: []
  type: TYPE_NORMAL
- en: Set yourself up a MySQL database to record the data and reconfigure the preceding
    Python script to output the results to the database. Then, build another script
    (or do it in the same one) to retrieve the data and output it to Maltego.
  prefs: []
  type: TYPE_NORMAL
- en: Reconfigure the script to query WiGLE, and collect geolocation data for probe
    requests. Output this data through Maltego.
  prefs: []
  type: TYPE_NORMAL
- en: Make an attempt to set up a web-based frontend through Flask, Django, or PHP
    to display your results. Investigate currently existing solutions for presenting
    the data and attempting to emulate or improve them through a discussion with their
    creators.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed the attacks against WPS that have come about since
    the release of the original book and also performed an initial foray into integrating
    wireless tools with Python. Alas, we have come to end of the book, I hope it's
    been informative and interesting.
  prefs: []
  type: TYPE_NORMAL
