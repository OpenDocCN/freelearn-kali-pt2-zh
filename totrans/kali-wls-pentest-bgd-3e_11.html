<html><head></head><body><div class="chapter" title="Chapter&#xA0;11.&#xA0;WPS and Probes"><div class="titlepage"><div><div><h1 class="title"><a id="ch11"/>Chapter 11. WPS and Probes</h1></div></div></div><div class="blockquote"><table border="0" cellpadding="0" cellspacing="0" class="blockquote" summary="Block quote" width="100%"><tr><td valign="top"> </td><td valign="top"><p><span class="emphasis"><em>"Nothing is new under the sun."</em></span></p></td><td valign="top"> </td></tr><tr><td valign="top"> </td><td align="right" colspan="2" style="text-align: center" valign="top">--<span class="attribution"><span class="emphasis"><em>Popular Saying</em></span></span></td></tr></table></div><p>
<span class="emphasis"><em>This chapter incorporates the new techniques related to attacking WPS and probe monitoring and also covers the pineapple tool that makes much of wireless testing a lot easier. These attacks and tools have appeared since the publication of the original book, and we'll be making sure we're being as holistic as possible.</em></span>
</p><div class="section" title="WPS attacks"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec98"/>WPS attacks</h1></div></div></div><p>
<span class="strong"><strong>Wireless Protected Setup</strong></span> (<span class="strong"><strong>WPS</strong></span>) was introduced in 2006 to help users without wireless knowledge <a class="indexterm" id="id311"/>to have secure networks. The idea was that their Wi-Fi device would have a single hidden hardcoded value that would allow access with <a class="indexterm" id="id312"/>key memorization. New devices would be authenticated through a button press on the Wi-Fi router. Individuals outside the house without access to the device would not be able to have access, thus reducing the issues surrounding remembering WPA keys or setting short ones.</p><p>In late 2011, a security vulnerability was disclosed enabling brute-force attacks on the WPS authentication system. The traffic required to negotiate a WPS exchange was spoofable, and the WPS pin itself is only eight characters between 0-9. To start with, this provides only 100,000,000 possibilities in comparison with an eight-character azAZ09 password having 218,340,105,584,896 combinations.</p><p>However, there are further vulnerabilities:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Of the eight <a class="indexterm" id="id313"/>characters of the WPS pin, the last character is a checksum of the previous seven and therefore predictable, leaving a maximum of 10,000,000 options</li><li class="listitem" style="list-style-type: disc">In addition, the first four and the following three of the remaining characters are checked separately, which means that there are 104 + 103 options or 11,000</li></ul></div><p>Through the two decisions made in the authentication mechanism, we have gone from 100,000,000 possible <a class="indexterm" id="id314"/>combinations to 11,000. This equates to a six-hour difference when brute-forcing the algorithm. It is these decisions that make attacks against WPS viable.</p><p>In the next lab exercise, we will go through identifying and attacking vulnerable WPS setups with Wash and Reaver.</p></div></div>
<div class="section" title="Time for action &#x2013; WPS attack"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec99"/>Time for action – WPS attack</h1></div></div></div><p>Follow the given instructions to get started:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Before we <a class="indexterm" id="id315"/>attack a WPS-enabled access point, we need to create one. The TP-Link we use has this feature turned on by default, which is worrying but handy. To double-check this, we can log onto our router and click on <span class="strong"><strong>WPS</strong></span>. It should look like the following:<div class="mediaobject"><img alt="Time for action – WPS attack" src="graphics/B09903_11_01.jpg"/></div></li><li class="listitem">Now we've confirmed that it's ready. We need to set up our target. We need to set up our testing environment. We're going to use the Wash tool, and Wash requires a monitoring interface to function. As we have done many times before, we need to set up one with the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>airmon-ng start wlan0</strong></span>
</pre></div><p>The <a class="indexterm" id="id316"/>output will be as follows:</p><div class="mediaobject"><img alt="Time for action – WPS attack" src="graphics/B09903_11_02.jpg"/></div></li><li class="listitem">We have a monitoring interface set up as <code class="literal">wlan0mon</code>, and we can call Wash with the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>wash -i wlan0mon</strong></span>
</pre></div><div class="mediaobject"><img alt="Time for action – WPS attack" src="graphics/B09903_11_03.jpg"/></div></li><li class="listitem">Wash will display all the nearby devices that support WPS as well as whether they have WPS active or unlocked and what version is running:<div class="mediaobject"><img alt="Time for action – WPS attack" src="graphics/B09903_11_04.jpg"/></div></li><li class="listitem">We can see the <code class="literal">Wireless Lab</code> network supports WPS. It uses version 1 and it's not <a class="indexterm" id="id317"/>locked. Fantastic. We take note of the MAC address, which in my case is <code class="literal">E8:94:F6:62:1E:8E</code>, as this will be used to target our next tool: <code class="literal">reaver</code>.</li><li class="listitem">Reaver attempts to brute-force the WPS pin for a given MAC address. The syntax for starting this is as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>reaver -i wlan0mon -b &lt;mac&gt; -vv</strong></span>
</pre></div><p>The output will be as follows:</p><div class="mediaobject"><img alt="Time for action – WPS attack" src="graphics/B09903_11_05.jpg"/></div></li><li class="listitem">Once it is started, the tool runs through all the possible combinations for the WPS and attempts to authenticate. Once it does this, it will return the WPS code and the <a class="indexterm" id="id318"/>password, as shown in the following screenshot:<div class="mediaobject"><img alt="Time for action – WPS attack" src="graphics/B09903_11_06.jpg"/></div></li><li class="listitem">With WPA-PSK in hand, we can authenticate normally now. I left my device with the default WPA-PSK that matches the WPS pin. If, however, you want to authenticate with the WPS pin, you can do this by specifying the pin in <code class="literal">reaver</code> with the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>reaver -i wlan0mon -b &lt;mac&gt; -vv -p 88404148</strong></span>
</pre></div><p>Replace my pin with your own.</p></li></ol></div><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec85"/>
<span class="emphasis"><em>What just happened?</em></span>
</h2></div></div></div><p>We successfully <a class="indexterm" id="id319"/>identified a wireless network with a vulnerable instance of WPS active with Wash. We then used Reaver to recover the WPA key and the WPS pin. With this information, we could then authenticate with the network and continue a network penetration test.</p></div><div class="section" title="Have a go hero – rate limiting"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec86"/>Have a go hero – rate limiting</h2></div></div></div><p>In the previous exercise, we attacked an entirely unprotected WPS installation. There are multiple methods that <a class="indexterm" id="id320"/>can be used to further secure installations without removing WPS altogether.</p><p>Make an attempt to set the WPS pin to an arbitrary value and try again, to see whether Reaver is as effective at cracking it.</p><p>Acquire a wireless router that allows you to rate-limit the WPS attempts. Try and configure your attack to avoid triggering lockouts.</p></div></div>
<div class="section" title="Probe sniffing"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec100"/>Probe sniffing</h1></div></div></div><p>We have spoken about probes previously, and how they can be used to identify hidden networks and perform effective rogue access point attacks. They can also be used to identify individuals as targets or track them on a mass scale with minimal equipment.</p><p>When a device <a class="indexterm" id="id321"/>wishes to connect to a network, it sends a probe request that contains its own MAC address and the name of the network it wishes to connect to. We can use tools such as <code class="literal">airodump-ng</code> to track these. However, if we wish to identify whether an individual was present at a specific location at a specific time or look for trends in Wi-Fi usage, we will need to use a different approach.</p><p>In this section, we will utilize <code class="literal">tshark</code> and Python to collect data. You will receive the code and an explanation of what is being done.</p></div>
<div class="section" title="Time for action &#x2013; collecting data"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec101"/>Time for action – collecting data</h1></div></div></div><p>Follow the given instructions to get started:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First of all, we <a class="indexterm" id="id322"/>need a device that's looking for multiple networks. Generally, a normal smartphone such as an Android device or iPhone will do the trick. Desktops don't generally make good targets as they tend to remain in one location. Newer iPhones and Android devices may have probe requests disabled or obfuscated, so do check before you give up.</li><li class="listitem">Once you have your device, make sure the Wi-Fi is turned on.</li><li class="listitem">Then set up your monitoring interface as we have done many times before:<div class="mediaobject"><img alt="Time for action – collecting data" src="graphics/B09903_11_07.jpg"/></div></li><li class="listitem">The next thing to be done is to look for probe requests with <code class="literal">tshark</code> via the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>tshark -n -i wlan0mon subtype probereq</strong></span>
</pre></div><p>The <a class="indexterm" id="id323"/>screenshot of the following command is as follows:</p><div class="mediaobject"><img alt="Time for action – collecting data" src="graphics/B09903_11_08.jpg"/></div></li><li class="listitem">Your output at this point is a little rough, as the default output from <code class="literal">tshark</code> is not designed to be readable, just to have as much information in it as possible. It should look like the following:<div class="mediaobject"><img alt="Time for action – collecting data" src="graphics/B09903_11_09.jpg"/></div></li><li class="listitem">You can clearly see the MAC address and SSID of the probe request; however, this <a class="indexterm" id="id324"/>output can be improved. We can use the following command to make it more readable:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>tshark –n –i wlan0mon –T fields -e wlan.sa –e wlan.ssid</strong></span>
</pre></div><p>The screenshot of the following command is as follows:</p><div class="mediaobject"><img alt="Time for action – collecting data" src="graphics/B09903_11_10.jpg"/></div></li><li class="listitem">The output here is much more readable:<div class="mediaobject"><img alt="Time for action – collecting data" src="graphics/B09903_11_11.jpg"/></div></li><li class="listitem">So, now we have the output in a readable format, what next? What we do is create a Python script that will run the command and record the output for later analysis. Before running the code, you will need to ensure that you have your monitoring interface ready and that a file called <code class="literal">results.txt</code> is created in the directory <a class="indexterm" id="id325"/>you are in. The Python script is as follows:<div class="informalexample"><pre class="programlisting">import subprocess
import datetime
results = open("results.txt", "a")
while 1:
    cmd = subprocess.check_output(["tshark –n –i wlan0mon –T fields -e wlan.sa –e wlan.ssid –c 100"], shell=True)
    split = cmd.split("\n")
    for value in split[:-1]:
           if value.strip():
                   splitvalue = value.split("\t")
                   MAC = str(splitvalue[0])
                   SSID = str(splitvalue[1])
                   time = str(datetime.datetime.now())
                   results.write(MAC+" "+SSID+" "+time+"\r\n")</pre></div><p>Let's get briefed on the Python script:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">import subprocess</code> and <code class="literal">import datetime</code>: This allow us to refer to the <code class="literal">subprocess</code> and <code class="literal">datetime</code> libraries. The <code class="literal">subprocess</code> library allows us to monitor the interface from <a class="indexterm" id="id326"/>the Linux command line, and <code class="literal">datetime</code> allows us to get the accurate time and date readings.</li><li class="listitem" style="list-style-type: disc"><code class="literal">results = open("results.txt", "a")</code>: This opens a file with the append rights and assigns it to <code class="literal">results</code>. The append rights only allow the script to add to the contents of the file. This stops the file from constantly being overwritten.</li><li class="listitem" style="list-style-type: disc"><code class="literal">while 1</code>: This line means run until stopped.</li><li class="listitem" style="list-style-type: disc"><code class="literal">cmd = subprocess.check_output(["tshark –n –i wlan0mon –T fields -e wlan.sa –e wlan.ssid –c 100"], shell=True)</code>: This opens a shell to perform our previously tested <code class="literal">tshark</code> command. The only difference this time is <code class="literal">-c 100</code>. What this flag does is limit the command to 100 queries. This allows us to return the results to ourselves without having to stop the program. Since we said run forever after writing the results, the script will restart again. This line takes the output from the shell and assigns it to the variable <code class="literal">cmd</code>. The script will display a count to 100, stop, and then restart. This means that if you want it to end, you have to kill the process.</li><li class="listitem" style="list-style-type: disc"><code class="literal">split = cmd.split("\n")</code>: This takes the variable and splits it by line.</li><li class="listitem" style="list-style-type: disc"><code class="literal">for value in split[:-1]</code>: This repeats the following action for each line in the output, ignoring the first line that contains headers.</li><li class="listitem" style="list-style-type: disc"><code class="literal">if value.strip()</code>: This checks to see if the value is empty before continuing to account for non-probe requests.</li><li class="listitem" style="list-style-type: disc"><code class="literal">value = value.split("\t")</code>: This breaks each line into further smaller chunks using the tab character as the delimiter.</li><li class="listitem" style="list-style-type: disc">The following three lines take each chunk of text and assign it to a variable:<div class="informalexample"><pre class="programlisting">MAC = str(splitvalue[0])
SSID = str(splitvalue[1])
time = str(datetime.datetime.now())</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">results.write(MAC+" "+SSID+" "+time+"\r\n")</code>: This takes all the values, writes them to a file separated by spaces, and ends with a return and a new line for neatness. The output will be neat lines of text written to the file.</li></ul></div></li></ol></div><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec87"/>
<span class="emphasis"><em>What just happened?</em></span>
</h2></div></div></div><p>We took the <a class="indexterm" id="id327"/>input from probe requests and output them to a file using Python. You may ask yourself what the purpose of this is. This can be achieved by simply performing the original <code class="literal">tshark</code> command and adding a <code class="literal">&gt;&gt; results.txt</code> command to the end. You would be correct; however, what we have created is a framework for integration with other tools, visualization platforms, databases, and services.</p><p>For example, using the WiGLE database that maps SSIDs to locations, you can add a few lines of code to take the SSID variable and query the WiGLE database. Alternatively, you could set up a MySQL database and output the results there to perform the SQL commands on it. This section has provided you with the first steps to create your own probe-monitoring tools. Through experimentation and using this simple code as the first step, a multitude of useful tools can be created.</p></div><div class="section" title="Have a go hero – extension ideas"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec88"/>Have a go hero – extension ideas</h2></div></div></div><p>Research which tools are available that allow visualization or data analytics and are easily <a class="indexterm" id="id328"/>integrated with Python. Tools such as Maltego have free versions that can be used to plot information.</p><p>Set <a class="indexterm" id="id329"/>yourself up a MySQL database to record the data and reconfigure the preceding Python script to output the results to the database. Then, build another script (or do it in the same one) to retrieve the data and output it to Maltego.</p><p>Reconfigure the script to query WiGLE, and collect geolocation data for probe requests. Output this data through Maltego.</p><p>Make an <a class="indexterm" id="id330"/>attempt to set up a web-based frontend through Flask, Django, or PHP to display your results. Investigate currently existing solutions for presenting the data and attempting to emulate or improve them through a discussion with their creators.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec102"/>Summary</h1></div></div></div><p>In this chapter, we discussed the attacks against WPS that have come about since the release of the original book and also performed an initial foray into integrating wireless tools with Python. Alas, we have come to end of the book, I hope it's been informative and interesting.</p></div></body></html>