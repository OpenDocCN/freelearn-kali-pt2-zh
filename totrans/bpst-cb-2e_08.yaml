- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Evaluating Input Validation Checks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Failure to validate any input received from the client before using it in the
    application code is one of the most common security vulnerabilities found in web
    applications. This flaw is the source of major security issues, such as SQL injection
    and **Cross-Site Scripting** (**XSS**). Web penetration testers must evaluate
    and determine whether any input is reflected back or executed upon by the application.
    We’ll learn how to use Burp Suite to perform such tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Testing for reflected cross-site scripting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing for stored cross-site scripting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing for HTTP verb tampering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing for HTTP parameter pollution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing for SQL injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing for command injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To complete the recipes in this chapter, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: OWASP Broken Web Applications (VM)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OWASP Mutillidae link
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Burp Suite Proxy Community or Professional ([https://portswigger.net/burp/](https://portswigger.net/burp/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing for reflected cross-site scripting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reflected cross-site scripting occurs when malicious JavaScript is injected
    into an input field, parameter, or header and, after returning from the web server,
    is executed within the browser. Reflected XSS occurs when the execution of JavaScript
    reflects in the browser only and is not a permanent part of the web page. Penetration
    testers need to test all client values sent to the web server to determine whether
    XSS is possible.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using OWASP Mutillidae II, let’s determine whether the application protects
    against reflected XSS.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'From the OWASP Mutillidae II menu, select **Login** by navigating to **OWASP
    2013** | **A3 - Cross Site Scripting (XSS)** | **Reflected (First Order)** | **Pen
    Test** **Tool Lookup**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.1 – Multillidae landing page](image/B21173_08_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 – Multillidae landing page
  prefs: []
  type: TYPE_NORMAL
- en: 'Select a tool from the drop-down listing and click the **Lookup Tool** button.
    Any value from the drop-down list will work for this recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.2 – Pentest tool vote](image/B21173_08_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.2 – Pentest tool vote
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch to Burp Suite **Proxy** | **HTTP history** and find the HTTP message
    you just created by selecting the lookup tool. Note that in the request is a parameter
    called **ToolID**. In the following example, the value is **3**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.3 – Proxy HTTP history view](image/B21173_08_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.3 – Proxy HTTP history view
  prefs: []
  type: TYPE_NORMAL
- en: 'Flip over to the **Response** tab and note the JSON returned from the request.
    You can find the JavaScript function in the response more easily by typing **PenTest**
    in the search box at the bottom. Note that **tool_id** is reflected in a response
    parameter called **toolIDRequested**. This may be an attack vector for XSS:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.4 – toolIDRequested and tool_id](image/B21173_08_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.4 – toolIDRequested and tool_id
  prefs: []
  type: TYPE_NORMAL
- en: 'Send the request over to **Repeater**. Add an XSS payload within the **ToolID**
    parameter immediately following the equals sign. Use a simple payload such as
    **<script>alert(1);</script>**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.5 – XSS payload in the ToolID parameter](image/B21173_08_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.5 – XSS payload in the ToolID parameter
  prefs: []
  type: TYPE_NORMAL
- en: 'Click **Send** and examine the returned JSON response, searching for **PenTest**.
    Notice our payload is returned exactly as input. It looks like the developer is
    not sanitizing any of the input data before using it. Let’s exploit the flaw:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.6 – Payload reflected in response](image/B21173_08_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.6 – Payload reflected in response
  prefs: []
  type: TYPE_NORMAL
- en: Since we are working with JSON instead of HTML, we will need to adjust the payload
    to match the structure of the JSON returned. We will fool the JSON into thinking
    the payload is legitimate. We will modify the original **<script>alert(1);</script>**
    payload to **"}} )%****3balert(1)%3b//** instead.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Switch to the Burp Suite **Proxy** | **Intercept** tab. Turn **Interceptor**
    on with the **Intercept is** **on** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return to Firefox, select another tool from the drop-down list, and click the
    **Lookup** **Tool** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'While **Proxy** | **Interceptor** has the request paused, insert the new payload
    of **"}} )%3balert(1)%3b//** immediately after the **ToolID** number:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.7 – Modified XSS payload for JSON](image/B21173_08_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.7 – Modified XSS payload for JSON
  prefs: []
  type: TYPE_NORMAL
- en: Click the **Forward** button. Turn **Interceptor** off by toggling to **Intercept**
    **is off**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Return to the Firefox browser and see the pop-up alert box displayed. You’ve
    successfully shown a **proof of concept** (**PoC**) for the reflected XSS vulnerability:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 8.8 – Evidence of XSS vulnerabili\uFEFFt\uFEFFy](image/B21173_08_008.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 8.8 – Evidence of XSS vulnerability
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Due to inadequate input cleansing prior to using data received from the client,
    in this case, the penetration testing tool’s identifier is reflected in the response
    as it is received from the client, allowing an attack vector for an XSS attack.
  prefs: []
  type: TYPE_NORMAL
- en: Testing for stored cross-site scripting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Stored cross-site scripting occurs when malicious JavaScript is injected into
    an input field, parameter, or header and, after returning from the web server,
    is executed within the browser and becomes a permanent part of the page. Stored
    XSS occurs when the malicious JavaScript is stored in the database and is used
    later to populate the display of a web page. Penetration testers need to test
    all client values sent to the web server to determine whether XSS is possible.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using OWASP Mutillidae II, let’s determine whether the application protects
    against stored cross-site scripting.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'From the OWASP Mutillidae II menu, select **Login** by navigating to **OWASP
    2013** | **A3 - Cross Site Scripting (XSS)** | **Persistent (First Order)** |
    **Add to** **your blog**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.9 – Navigation to the stored XSS lesson](image/B21173_08_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.9 – Navigation to the stored XSS lesson
  prefs: []
  type: TYPE_NORMAL
- en: 'Place some verbiage into the text area. Before clicking the **Save Blog Entry**
    button, let’s try a payload with the entry:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.10 – Save your blog entry](image/B21173_08_010..jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.10 – Save your blog entry
  prefs: []
  type: TYPE_NORMAL
- en: After clicking the **Save Blog Entry** button, you should immediately see the
    popup of the JavaScript stored on the page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.11 – Evidence of stored XSS vulnerability](image/B21173_08_011..jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.11 – Evidence of stored XSS vulnerability
  prefs: []
  type: TYPE_NORMAL
- en: Click the **OK** button to close the popups. Reload the page and you will see
    the alert popup again. This is because your malicious script has become a permanent
    part of the page. You’ve successfully shown a PoC for the stored XSS vulnerability!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Stored or persistent XSS occurs because the application not only neglects to
    sanitize the input but also stores the input within the database. Therefore, when
    a page is reloaded and populated with database data, the malicious script is executed
    along with that data.
  prefs: []
  type: TYPE_NORMAL
- en: Testing for HTTP verb tampering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HTTP requests can include methods beyond **GET** and **POST**. As a penetration
    tester, it is important to determine which other HTTP verbs (that is, methods)
    the web server allows. Support for other verbs may disclose sensitive information
    (for example, **TRACE**) or allow for a dangerous invocation of application code
    (for example, **DELETE**). Let’s see how Burp Suite can help test for HTTP verb
    tampering.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using Altoro Mutual ([https://demo.testfire.net](https://demo.testfire.net)),
    let’s determine whether the application has a **POST** request we can manipulate
    into using a **GET** instead. If possible, the **GET** request will expose sensitive
    data within the query string. We will login first, then map the application to
    look for something interesting like a money movement transaction.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Navigate to [https://demo.testfire.net](https://demo.testfire.net). Click the
    **Sign** **In** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.12 – Altoro Mutual landing page](image/B21173_08_012..jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.12 – Altoro Mutual landing page
  prefs: []
  type: TYPE_NORMAL
- en: You are brought to the login form.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.13 – Altoro Mutual login page](image/B21173_08_013..jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.13 – Altoro Mutual login page
  prefs: []
  type: TYPE_NORMAL
- en: After login, navigate to **Transfer Funds** using the left menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.14 – Navigate to the Transfer Funds page](image/B21173_08_014..jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.14 – Navigate to the Transfer Funds page
  prefs: []
  type: TYPE_NORMAL
- en: On the **Transfer Funds** page, select the **Checking** account and type an
    amount of money in the **Amount to Transfer** field. Do not transfer the money
    yet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.15 – Select the account to transfer to and type the amount](image/B21173_08_015..jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.15 – Select the account to transfer to and type the amount
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to **Proxy** | **Intercept** and toggle **Intercept** **is on**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.16 – Turn proxy intercept on](image/B21173_08_016..jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.16 – Turn proxy intercept on
  prefs: []
  type: TYPE_NORMAL
- en: Return to the browser and click the **Transfer** **Money** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.17 – Click the Transfer Money button](image/B21173_08_017..jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.17 – Click the Transfer Money button
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside **Proxy** | **Intercept**, you can easily change the verb from **POST**
    to **GET** by right-clicking and selecting **Change** **request method**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.18 – Change POST to GET](image/B21173_08_018..jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.18 – Change POST to GET
  prefs: []
  type: TYPE_NORMAL
- en: Note how the request is now a **GET** request and the account numbers are now
    exposed in the query string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.19 – See sensitive data in the GET query string](image/B21173_08_019..jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.19 – See sensitive data in the GET query string
  prefs: []
  type: TYPE_NORMAL
- en: Click the **Forward** button and toggle **Proxy** | **Intercept** **is off**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Notice the transfer was still successful as a **GET** request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 8.20 – Transfer was successfu\uFEFFl](image/B21173_08_020..jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 8.20 – Transfer was successful
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Testing for HTTP verb tampering includes sending requests against the application
    using different HTTP methods and analyzing the response received. In this recipe,
    the web developers allowed both a **POST** and a **GET** verb to be used in a
    transfer of funds between two accounts. Why is this a finding? Because the original
    **POST** request held sensitive data in the body of the request, whereas a **GET**
    request exposes the data in a query string, which is captured easily in web logs
    of servers and sniffed on the network wire. As a tester, you need to perform this
    type of test against login sequences and other areas of the application where
    you see sensitive data.
  prefs: []
  type: TYPE_NORMAL
- en: Testing for HTTP parameter pollution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**HTTP parameter pollution** (**HPP**) is an attack in which multiple HTTP
    parameters are sent to the web server with the same name. The intention is to
    determine whether the application responds in an unanticipated manner, allowing
    exploitation. For example, in a **GET** request, additional parameters can be
    added to the query string—in this fashion: **"&name=value"**—where **name** is
    a duplicate parameter name already known by the application code. Likewise, HPP
    attacks can be performed on **POST** requests by duplicating a parameter name
    in the **POST** body data.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using OWASP Mutillidae II, let’s determine whether the application allows HPP
    attacks.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'From the OWASP Mutillidae II menu, select **Login** by navigating to **OWASP
    2013** | **A1 - Injection (Other)** | **HTTP Parameter Pollution** | **Poll Question**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.21 – Navigate to the HTTP Parameter Pollution lesson](image/B21173_08_021..jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.21 – Navigate to the HTTP Parameter Pollution lesson
  prefs: []
  type: TYPE_NORMAL
- en: 'Select a tool from one of the radio buttons, add your initials, and click the
    **Submit** **Vote** button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.22 – Vote for a tool](image/B21173_08_022..jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.22 – Vote for a tool
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch to the Burp Suite **Proxy** | **HTTP history** tab and find the request
    you just performed from the **User Poll** page. Note the parameter named **choice**.
    The value of this parameter is **nmap**. Right-click and send this request to
    **Repeater**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.23 – Send to Repeater](image/B21173_08_023..jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.23 – Send to Repeater
  prefs: []
  type: TYPE_NORMAL
- en: Switch to Burp Suite **Repeater** and add another parameter with the same name
    to the query string. Let’s pick another tool from the **User Poll** list and append
    it to the query string, for example, **&choice=tcpdump**. This will add two choices,
    **&choice=nmap** (original) and **&choice=tcpdump**. Click **Send** to send the
    request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Examine the response. Which choice did the application code accept? This is
    easy to find by searching for the **Your choice was** string. Clearly, the duplicate
    choice parameter value is the one the application code accepted to count in the
    **User** **Poll** vote:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 8.24 – Validate your change was accepted by the se\uFEFFr\uFEFFver](image/B21173_08_024..jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 8.24 – Validate your change was accepted by the server
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The application code fails to check against multiple parameters with the same
    name when passed into a function. The result is that the application usually acts
    upon the last parameter match provided. This can result in odd behavior and unexpected
    results.
  prefs: []
  type: TYPE_NORMAL
- en: Testing for SQL injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A SQL injection attack involves an attacker providing input to the database,
    which is received and used without any validation or sanitization. The result
    is divulging sensitive data, modifying data, or even bypassing authentication
    mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using the OWASP Mutillidae II **Login** page, let’s determine whether the application
    is vulnerable to **SQL injection** (**SQLi**) attacks.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'From the OWASP Mutillidae II menu, select **Login** by navigating to **OWASP
    2013** | **A1-Injection (SQL)** | **SQLi – Bypass Authentication** | **Login**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.25 – Navigate to the SQL injection authentication bypass lesson](image/B21173_08_025..jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.25 – Navigate to the SQL injection authentication bypass lesson
  prefs: []
  type: TYPE_NORMAL
- en: On the **Login** screen, place invalid credentials in the **Username** and **Password**
    textboxes. For example, the username is **' or 1=1--** with no password. Click
    the **Login** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.26 – Login using SQLi payload](image/B21173_08_026..jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.26 – Login using SQLi payload
  prefs: []
  type: TYPE_NORMAL
- en: Switch to the Burp Suite **Proxy** | **HTTP history** tab. Find the request
    with the payload of **' or 1=1--<space>** within the **username** parameter and
    click the **Login** button. Use **Inspector** to see the contents of the SQL injection
    payload more easily.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.27 – Use Inspector to see your URL-encoded payload](image/B21173_08_027..jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.27 – Use Inspector to see your URL-encoded payload
  prefs: []
  type: TYPE_NORMAL
- en: Return to the Firefox browser and note you are now logged in as admin!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 8.28 – Verify SQLi payload wo\uFEFFrked](image/B21173_08_028..jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 8.28 – Verify SQLi payload worked
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Without knowing any credentials, you can use a SQL injection payload, such as
    **' or 1=1--<space>**, to bypass the authentication mechanism. The application
    contains a SQL injection vulnerability because the SQL code used in the backend
    application is constructed using the values of the textbox as is, without any
    sanitization of user input. The admin account is the first account created in
    the database, so the database defaulted to that account when the SQL injection
    payload executed.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can re-do this recipe and use a SQL injection wordlist from **wfuzz** within
    Burp Suite **Intruder** to test many different payloads in the **Username** field.
    Examine the response for each attack in the results table to determine whether
    the payload successfully performed a SQL injection and you are logged in to the
    application.
  prefs: []
  type: TYPE_NORMAL
- en: The construction of SQL injection payloads requires some knowledge of the backend
    database and the syntax required. A great resource to assist in the construction
    of SQL injection payloads is [https://pentestmonkey.net/category/cheat-sheet/sql-injection](https://pentestmonkey.net/category/cheat-sheet/sql-injection).
  prefs: []
  type: TYPE_NORMAL
- en: Testing for command injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Command injection involves an attacker attempting to invoke a system command,
    normally performed in a terminal session, within an HTTP request instead. Many
    web applications allow system commands through the UI for troubleshooting purposes.
    A web penetration tester must test whether the web page allows further commands
    on the system that should normally be restricted.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, you will need the SecLists payload for Unix commands on a
    Unix- or Linux-based operating system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/danielmiessler/SecLists/blob/master/Fuzzing/UnixAttacks.fuzzdb.txt](https://github.com/danielmiessler/SecLists/blob/master/Fuzzing/UnixAttacks.fuzzdb.txt)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download the SecLists payload from GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/danielmiessler/SecLists](https://github.com/danielmiessler/SecLists)'
  prefs: []
  type: TYPE_NORMAL
- en: Using the OWASP Mutillidae II **DNS Lookup** page, let’s determine whether the
    application is vulnerable to command injection attacks.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'From the OWASP Mutillidae II menu, select **DNS Lookup** by navigating to **OWASP
    2013** | **A1-Injection (Other)** | **Command Injection** | **DNS Lookup**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.29 – Navigate to the Command Injection lesson](image/B21173_08_029..jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.29 – Navigate to the Command Injection lesson
  prefs: []
  type: TYPE_NORMAL
- en: 'On the **DNS Lookup** page, type the IP address **127.0.0.1** in the textbox
    and click the **Lookup** **DNS** button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.30 – Type in an IP address](image/B21173_08_030..jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.30 – Type in an IP address
  prefs: []
  type: TYPE_NORMAL
- en: Switch to the Burp Suite **Proxy** | **HTTP history** tab and look for the request
    you just performed. Right-click on **Send** **to Intruder**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the **Intruder** | **Positions** tab, clear all suggested payload markers
    with the **Clear $** button. In the **target_host** parameter, place a pipe symbol
    (**|**) immediately following the **127.0.0.1** IP address. After the pipe symbol,
    place an **X**. Highlight the **X** and click the **Add $** button to wrap the
    **X** with payload markers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.31 – Add a substitution marker at the end of the parameter along
    with a pipe](image/B21173_08_031..jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.31 – Add a substitution marker at the end of the parameter along with
    a pipe
  prefs: []
  type: TYPE_NORMAL
- en: 'In the **Intruder** | **Payloads** tab, click the **Load** button. Browse to
    the location where you downloaded the **SecLists-master** wordlists from GitHub.
    Navigate to the location of the **UnixAttacks.fuzzdb.txt** wordlist and use the
    following to populate the **Payload settings [Simple list]** box: **SecLists-master/Fuzzing/UnixAttacks.fuzzdb.txt**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.32 – Load wordlist](image/B21173_08_032..jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.32 – Load wordlist
  prefs: []
  type: TYPE_NORMAL
- en: Uncheck the **Payload encoding** box at the bottom of the **Payloads** tab page
    and then click the **Start** **Attack** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Allow the attack to continue until you reach payload **50**. Notice the responses
    through the **Render** tab are around payload **45** or so. We can perform commands,
    such as **id** on the operating system, which displays the results of the commands
    on the web page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 8.33 – Evidence of command injection e\uFEFFxploit](image/B21173_08_033..jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 8.33 – Evidence of command injection exploit
  prefs: []
  type: TYPE_NORMAL
- en: We can also right-click this request from the results table and send to **Repeater**
    to perform the attack again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.34 – Send to Repeater](image/B21173_08_034..jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.34 – Send to Repeater
  prefs: []
  type: TYPE_NORMAL
- en: In **Repeater**, click **Send**, and on the response, click the **Render** tab
    to view the results of the command injection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 8.35 – Repeat exploit to see ev\uFEFFidence](image/B21173_08_035..jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 8.35 – Repeat exploit to see evidence
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Failure to define and validate user input against an acceptable list of system
    commands can lead to command injection vulnerabilities. In this case, the application
    code does not confine system commands available through the UI, allowing visibility
    and execution of commands on the operating system that should be restricted.
  prefs: []
  type: TYPE_NORMAL
