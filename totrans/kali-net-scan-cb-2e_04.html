<html><head></head><body>
        <section id="4B7I41-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Port Scanning</h1>
            

            <article>
                
<p class="calibre5">This chapter includes the following recipes:</p>
<ul class="calibre18">
<li class="calibre19">Port scanning with Scapy</li>
<li class="calibre19">Port scanning with Nmap</li>
<li class="calibre19">Port scanning with Metasploit</li>
<li class="calibre19">Port scanning with hping3</li>
<li class="calibre19">Port scanning with DMitry</li>
<li class="calibre19">Port scanning with Netcat</li>
<li class="calibre19">Port scanning with masscan</li>
</ul>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="4C62M1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Introduction</h1>
            

            <article>
                
<p class="calibre5">Identifying open ports on a target system is the next step to defining the attack surface of a target. Open ports correspond to the networked services that are running on a system. Programming errors or implementation flaws can make these services vulnerable to attack and can sometimes lead to total system compromise. To determine the possible attack vectors, one must first enumerate the open ports on all of the remote systems within the project's scope. These open ports correspond to services that may be addressed with either UDP or TCP traffic. Both TCP and UDP are transport protocols. <strong class="calibre1">Transmission Control Protocol</strong> (<strong class="calibre1">TCP</strong>) is the more commonly used of the two and provides connection-oriented communication. <strong class="calibre1">User Datagram Protocol</strong> (<strong class="calibre1">UDP</strong>) is a non connection-oriented protocol that is sometimes used with services for which speed of transmission is more important than data integrity. The penetration testing technique used to enumerate these services is called <strong class="calibre1">port scanning</strong>. Unlike host discovery, which was discussed in the previous chapter, these techniques should yield enough information to identify whether a service is associated with a given port on the device or server. Prior to addressing the specific recipes listed, we will discuss some of the underlying principles that should be understood about port scanning.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="4D4J81-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">UDP port scanning</h1>
            

            <article>
                
<p class="calibre5">Because TCP is a more commonly used transport-layer protocol, services that operate over UDP are frequently forgotten. Despite the natural tendency to overlook UDP services, it is absolutely critical that these services be enumerated to acquire a complete understanding of the attack surface of any given target. UDP scanning can often be challenging, tedious, and time consuming. The first three recipes in this chapter will cover how to perform a UDP port scan with different tools in Kali Linux. To understand how these tools work, it is important to understand the two different approaches to UDP scanning that will be used. One technique, which will be addressed in the first recipe, is to rely exclusively on ICMP port-unreachable responses. This type of scanning relies on the assumption that any UDP ports that are not associated with a live service will return an ICMP port-unreachable response, and a lack of this response is interpreted as an indication of a live service. While this approach can be effective in some circumstances, it can also return inaccurate results in cases where the host is not generating port-unreachable responses or the port-unreachable replies are rate limited or are filtered by a firewall. An alternative approach, which is addressed in the second and third recipes, is to use service-specific probes to attempt to solicit a response, which would indicate that the expected service is running on the targeted port. While this approach can be highly effective, it can also be very time consuming.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="4E33Q1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">TCP port scanning</h1>
            

            <article>
                
<p class="calibre5">Throughout this chapter, several different approaches to TCP scanning will be addressed. These techniques include stealth scanning, connect scanning, and zombie scanning. To understand how these scanning techniques work, it is important to understand how TCP connections are established and maintained. TCP is a connection-oriented protocol, and data is only transported over TCP after a connection has been established between two systems. The process associated with establishing a TCP connection is often referred to as the three-way handshake. This name alludes to the three steps involved in the connection process. The following diagram illustrates this process in graphical form:</p>
<div class="p"><img class="alignnone85" src="../images/00420.jpeg"/></div>
<p class="calibre5">A TCP <strong class="calibre1">SYN</strong> packet is sent from the device that wishes to establish a connection with a port of the device that it desires to connect with. If the service associated with the receiving port accepts the connection, it will reply to the requesting system with a TCP packet that has both the <strong class="calibre1">SYN</strong> and <strong class="calibre1">ACK</strong> bits activated. The connection is established only when the requesting system responds with a TCP <strong class="calibre1">ACK</strong> response. This three-step process establishes a TCP session between the two systems. All of the TCP port scanning techniques will perform some variation of this process to identify live services on remote hosts.</p>
<p class="calibre5">Both connect scanning and stealth scanning are fairly easy to understand. Connect scanning is used to establish a full TCP connection for each port that is scanned. This is to say that for each port that is scanned, the full three-way handshake is completed. If a connection is successfully established, the port is then determined to be open. On the other hand, stealth scanning does not establish a full connection. Stealth scanning is also referred to as SYN scanning or half-open scanning. For each port that is scanned, a single SYN packet is sent to the destination port, and all ports that reply with a SYN+ACK packet are assumed to be running live services. Since no final ACK is sent from the initiating system, the connection is left half open. This is referred to as stealth scanning because logging solutions that only record established connections will not record any evidence of the scan.</p>
<p class="calibre5">The final method of TCP scanning that will be discussed in this chapter is a technique called <strong class="calibre1">zombie scanning</strong>. The purpose of zombie scanning is to map open ports on a remote system without producing any evidence that you have interacted with that system. The principles behind how zombie scanning works are somewhat complex. Carry out the process of zombie scanning with the following steps:</p>
<ol class="calibre20">
<li value="1" class="calibre19">Identify a remote system for your zombie. This system should have the following characteristics:
<ul class="calibre30">
<li class="calibre19">It is idle and does not communicate actively with other systems on the network</li>
<li class="calibre19">It uses an incremental IPID sequence</li>
</ul>
</li>
<li value="2" class="calibre19">Send a SYN+ACK packet to this zombie host and record the initial IPID value.</li>
<li value="3" class="calibre19">Send a SYN packet with a spoofed source IP address of the zombie system to the scan target system.</li>
<li value="4" class="calibre19">Depending on the status of the port on the scan target, one of the following two things will happen:
<ul class="calibre30">
<li class="calibre19">If the port is open, the scan target will return a SYN+ACK packet to the zombie host, which it believes sent the original SYN request. In this case, the zombie host will respond to this unsolicited SYN+ACK packet with an RST packet and thereby increment its IPID value by one.</li>
<li class="calibre19">If the port is closed, the scan target will return an RST response to the zombie host, which it believes sent the original SYN request. This RST packet will solicit no response from the zombie, and the IPID will not be incremented.</li>
</ul>
</li>
<li value="5" class="calibre19">Send another SYN+ACK packet to the zombie host, and evaluate the final IPID value of the returned RST response. If this value has incremented by one, then the port on the scan target is closed, and if the value has incremented by two, then the port on the scan target is open.</li>
</ol>
<p class="calibre5">The following diagram shows the interactions that take place when a zombie host is used to scan an open port:</p>
<div class="p"><img class="image-border67" src="../images/00345.jpeg"/></div>
<p class="calibre5">To perform a zombie scan, an initial <strong class="calibre1">SYN/ACK</strong> request should be sent to the zombie system to determine the current <strong class="calibre1">IPID</strong> value in the returned <strong class="calibre1">RST</strong> packet. Then, a spoofed <strong class="calibre1">SYN</strong> packet is sent to the scan target with a source IP address of the zombie system. If the port is open, the scan target will send a <strong class="calibre1">SYN/ACK</strong> response back to the zombie. Since the zombie did not actually send the initial <strong class="calibre1">SYN</strong> request, it will interpret the <strong class="calibre1">SYN/ACK</strong> response as unsolicited and send an <strong class="calibre1">RST</strong> packet back to the target, thereby incrementing its <strong class="calibre1">IPID</strong> by one. Finally, another <strong class="calibre1">SYN/ACK</strong> packet should be sent to the zombie, which will return an <strong class="calibre1">RST</strong> packet and increment the <strong class="calibre1">IPID</strong> one more time. An <strong class="calibre1">IPID</strong> that has incremented by two from the initial response is indicative of the fact that all of these events have transpired and that the destination port on the scanned system is open. Alternatively, if the port on the scan target is closed, a different series of events will transpire, which will only cause the final <strong class="calibre1">RST</strong> response <strong class="calibre1">IPID</strong> value to increment by one.</p>
<p class="calibre5">The following diagram is an illustration of the sequence of events associated with the zombie scan of a closed port:</p>
<div class="p"><img class="image-border68" src="../images/00426.jpeg"/></div>
<p class="calibre5">If the destination port on the scan target is closed, an <strong class="calibre1">RST</strong> packet will be sent to the zombie system in response to the initially spoofed <strong class="calibre1">SYN</strong> packet. Since the <strong class="calibre1">RST</strong> packet solicits no response, the <strong class="calibre1">IPID</strong> value of the zombie system will not be incremented. As a result, the final <strong class="calibre1">RST</strong> packet returned to the scanning system in response to the <strong class="calibre1">SYN/ACK</strong> packet will have the <strong class="calibre1">IPID</strong> incremented by only one. This process can be performed for each port that is to be scanned, and it can be used to map open ports on a remote system without leaving any evidence that a scan was performed by the scanning system.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="4F1KC1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Port scanning with Scapy (UDP, stealth, connect, and zombie)</h1>
            

            <article>
                
<p class="calibre5">Scapy is a tool that can be used to craft and inject custom packets into a network. We will begin by using Scapy to scan for active UDP services. This can be done by sending an empty UDP packet to destination ports and then identifying the ports that do not respond with an ICMP port-unreachable response.</p>
<p class="calibre5">Next, we will use Scapy to perform a TCP stealth scan. A TCP port stealth scan performs a partial, three-way TCP handshake on target ports to identify whether the ports are accepting connections or not. This type of scan is referred to as a stealth scan, SYN scan, or half-open scan.</p>
<p class="calibre5">Next, we will use Scapy to perform a TCP connect scan. Generally, TCP connect scanning is an easier process than SYN scanning. This is because TCP connect scanning does not require the elevated privileges that are needed to generate and inject the raw packets used in SYN scanning. Scapy is the one major exception to this. It is actually very difficult and impractical to perform a full, three-way TCP handshake with Scapy. However, for the sake of understanding the process better, we will see how to use Scapy to perform a connect scan.</p>
<p class="calibre5">Finally, we will use Scapy to perform zombie scans. It is possible to identify the open ports on a target system without ever giving that system any indication that you interacted with it. This extremely stealthy form of scanning is referred to as zombie scanning and can only be performed if another system exists on the network that has low network activity and incremental IPID sequencing.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="4G04U1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre5">To use Scapy to perform UDP scanning, you will need to have a remote system that is running network services over UDP. In the examples provided, an instance of Metasploitable2 is used to perform this task. To use Scapy to perform stealth and connect TCP scans, you will need to have a remote system that is running accessible network services over TCP. In the examples provided, an instance of Metasploitable2 is used to perform this task. To use Scapy to perform a zombie scan, you will need to have a remote system that is running TCP services and another remote system that has incremental IPID sequencing. In the examples provided, an installation of Metasploitable2 is used as a scan target, and an installation of Windows XP is used as an incremental IPID zombie.</p>
<p class="calibre5">For more information on how to set up Metasploitable2, refer to <a href="part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426" target="_blank" class="calibre6">Chapter 1</a>, <em class="calibre15">Getting Started</em>. Additionally, this section will require a script to be written to the filesystem using a text editor such as Vim or GNU nano. For more information on how to write scripts, refer to the <em class="calibre15">Using text editors (Vim and GNU nano)</em> recipe in <a href="part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426" target="_blank" class="calibre6">Chapter 1</a>, <em class="calibre15">Getting Started</em>.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="4GULG1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it…</h1>
            

            <article>
                
<p class="calibre5">Let's start with UDP port scanning with Scapy.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section>

            <header id="4HT622-cf89710d791c4a3bb78ec273d9322426">
                </header><h1 class="header-title" id="calibre_pb_0">UDP port scanning with Scapy</h1>
            

            <article>
                
<p class="calibre5">Using Scapy, we can quickly develop an understanding of the underlying principles of UDP scanning. To positively confirm the existence of a UDP service on any given port, we will need to solicit a reply from that service. This can prove to be very difficult, as many UDP services will only reply to service-specific requests. Knowledge of any particular service can make it easier to positively identify that service; however, there are general techniques that can be used to determine, with a reasonable amount of accuracy, whether a service is running on a given UDP port. The technique that we will use with Scapy is to identify closed UDP ports with ICMP port-unreachable replies:</p>
<ol class="calibre20">
<li value="1" class="calibre19">To send a UDP request to any given port, we first need to build layers of that request. The first layer that we will need to construct is the IP layer:</li>
</ol>
<div class="p"><img class="image-border69" src="../images/00430.jpeg"/></div>
<ol start="2" class="calibre20">
<li value="2" class="calibre19">To build the IP layer of our request, we need to assign the <kbd class="calibre16">IP</kbd> object to the <kbd class="calibre16">i</kbd> variable. By calling the <kbd class="calibre16">display()</kbd> function, we can identify the attribute configurations of the object. By default, both the sending and receiving addresses are set to the loopback address, <kbd class="calibre16">127.0.0.1</kbd>. These values can be modified by changing the destination address, by setting <kbd class="calibre16">i.dst</kbd> to be equal to the string value of the address we wish to scan. On calling the <kbd class="calibre16">display()</kbd> function again, we see that not only has the destination address been updated, but Scapy also automatically updates the source IP address to the address associated with the default interface. Now that we have constructed the IP layer of the request, we can proceed to the UDP layer:</li>
</ol>
<div class="p"><img class="alignnone86" src="../images/00399.jpeg"/></div>
<ol start="3" class="calibre20">
<li value="3" class="calibre19">To build the UDP layer of our request, we use the same technique we used for the IP layer. In the example provided, the UDP object was assigned to the <kbd class="calibre16">u</kbd> variable. As mentioned previously, the default configurations can be identified by calling the <kbd class="calibre16">display()</kbd> function. Here, we can see that the default value for both the source and destination ports are listed as <kbd class="calibre16">domain</kbd>. As you might likely suspect, this is to indicate the DNS service associated with port the <kbd class="calibre16">53</kbd>. DNS is a common service that can often be discovered on networked systems. To confirm this, one can call the value directly by referencing the variable name and attribute. This can then be modified by setting the attribute equal to the new port destination value, as follows:</li>
</ol>
<div class="p"><img class="alignnone87" src="../images/00419.jpeg"/></div>
<ol start="4" class="calibre20">
<li value="4" class="calibre19">In the preceding example, the destination port is set to <kbd class="calibre16">123</kbd>, which is the <strong class="calibre1">Network Time Protocol</strong> (<strong class="calibre1">NTP</strong>) port. Now that we have created both the IP and UDP layers, we need to construct the request by stacking these layers:</li>
</ol>
<div class="p"><img class="image-border70" src="../images/00438.jpeg"/></div>
<ol start="5" class="calibre20">
<li value="5" class="calibre19">We can stack the IP and UDP layers by separating the variables with a forward slash. These layers can then be set equal to a new variable that will represent the entire request. We can then call the <kbd class="calibre16">display()</kbd> function to view the configurations for the request. Once the request has been built, it can be passed to the <kbd class="calibre16">sr1()</kbd> function so that we can analyze the response:</li>
</ol>
<div class="p"><img class="image-border71" src="../images/00441.jpeg"/></div>
<ol start="6" class="calibre20">
<li value="6" class="calibre19">This same request can be performed without independently building and stacking each layer. Instead, we can use a single one-line command by calling the functions directly and passing them the appropriate arguments, as follows:</li>
</ol>
<div class="p"><img class="image-border72" src="../images/00444.jpeg"/></div>
<ol start="7" class="calibre20">
<li value="7" class="calibre19">Note that the response for these requests includes an ICMP packet that has the type field indicating that the host is unreachable and code field indicating that the port is unreachable. This response is commonly returned if the UDP port is closed. Now, we should attempt to modify the request so that it is sent to a destination port that corresponds to an actual service on the remote system. To do this, we change the destination port back to the port <kbd class="calibre16">53</kbd> and then send the request again, as follows:</li>
</ol>
<div class="p"><img class="image-border73" src="../images/00328.jpeg"/></div>
<ol start="8" class="calibre20">
<li value="8" class="calibre19">When the same request is sent to an actual service, no reply is received. This is because the DNS service running on the system's UDP port <kbd class="calibre16">53</kbd> will only respond to service-specific requests. Knowledge of this discrepancy can be used to scan for ICMP host-unreachable replies, and we can then identify potential services by flagging the non-responsive ports:</li>
</ol>
<pre class="calibre24">
        #!/usr/bin/python<br class="title-page-name"/><br class="title-page-name"/>        import logging<br class="title-page-name"/>        logging.getLogger("scapy.runtime").setLevel(logging.ERROR)<br class="title-page-name"/><br class="title-page-name"/>        from scapy.all import *<br class="title-page-name"/>        import time<br class="title-page-name"/>        import sys<br class="title-page-name"/><br class="title-page-name"/>        if len(sys.argv) != 4:<br class="title-page-name"/>          print "Usage - ./udp_scan.py [Target-IP] [First Port]<br class="title-page-name"/>            [Last Port]"<br class="title-page-name"/>          print "Example - ./upd_scan.py 10.0.0.5 1 100"<br class="title-page-name"/>          print "Example will UDP port scan ports 1 through<br class="title-page-name"/>            100 on 10.0.0.5"<br class="title-page-name"/>          sys.exit()<br class="title-page-name"/>        else:<br class="title-page-name"/>          ip = sys.argv[1]<br class="title-page-name"/>          start = int(sys.argv[2])<br class="title-page-name"/>          end = int(sys.argv[3])<br class="title-page-name"/><br class="title-page-name"/>        for port in range(start,end):<br class="title-page-name"/>          ans = sr1(IP(dst=ip)/UDP(dport=port),timeout=5,verbose =0)<br class="title-page-name"/>          time.sleep(1)<br class="title-page-name"/>          if ans == None:<br class="title-page-name"/>            print port<br class="title-page-name"/>          else:<br class="title-page-name"/>            pass
</pre>
<ol start="9" class="calibre20">
<li value="9" class="calibre19">The provided Python script sends a UDP request to each of the first hundred ports in sequence. In case no response is received, the port is identified as being open. Make sure you modify the permissions of the file by running <kbd class="calibre16">chmod 777 udp_scan.py</kbd>. By running this script, we can identify all the ports that don't return an ICMP host-unreachable reply:</li>
</ol>
<div class="p"><img class="image-border74" src="../images/00450.jpeg"/></div>
<ol start="10" class="calibre20">
<li value="10" class="calibre19">A timeout of 5 seconds is used to adjust for latent responses that result from ICMP host-unreachable rate limiting. Even with this rather large response acceptance window, scanning in this fashion can still be unreliable at times. It is for this reason that UDP probing scans are often a more effective alternative.</li>
</ol>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section>

            <header id="4IRMK2-cf89710d791c4a3bb78ec273d9322426">
                </header><h1 class="header-title" id="calibre_pb_0">Stealth scanning with Scapy</h1>
            

            <article>
                
<p class="calibre5">The following steps demonstrate scanning with Scapy:</p>
<ol class="calibre20">
<li value="1" class="calibre19">To demonstrate how a SYN scan is performed, we craft a TCP SYN request using Scapy and identify the responses associated with an open port, closed port, and non-responsive system.</li>
<li value="2" class="calibre19">To send a TCP SYN request to any given port, we first need to build the layers of this request. The first layer that we need to construct is the IP layer:</li>
</ol>
<div class="p"><img class="image-border75" src="../images/00494.jpeg"/></div>
<ol start="2" class="calibre20">
<li value="2" class="calibre19">To build the IP layer for our request, we need to assign the <kbd class="calibre16">IP</kbd> object to the <kbd class="calibre16">i</kbd> variable. By calling the <kbd class="calibre16">display()</kbd> function, we identify the attribute configurations for the object. By default, both the sending and receiving addresses are set to the loopback address, <kbd class="calibre16">127.0.0.1</kbd>. These values can be modified by changing the destination address, by setting <kbd class="calibre16">i.dst</kbd> equal to the string value of the address that we wish to scan. By calling the <kbd class="calibre16">display()</kbd> function again, we see that not only has the destination address been updated, but Scapy also automatically updates the source IP address to the address associated with the default interface.</li>
<li value="3" class="calibre19">Now that we have constructed the IP layer for the request, we can proceed to the TCP layer:</li>
</ol>
<div class="p"><img class="image-border76" src="../images/00457.jpeg"/></div>
<ol start="4" class="calibre20">
<li value="4" class="calibre19">To build the TCP layer for our request, we use the same technique that we used for the IP layer. In the example provided, the <kbd class="calibre16">TCP</kbd> object was assigned to the <kbd class="calibre16">t</kbd> variable. As mentioned previously, we can identify the default configurations by calling the <kbd class="calibre16">display()</kbd> function. Here, we can see that the default value for the destination port is the HTTP port <kbd class="calibre16">80</kbd>. For our initial scan, we leave the default TCP configuration as is.</li>
<li value="5" class="calibre19">Now that we have created both the IP and TCP layers, we need to construct the request by stacking these layers as follows:</li>
</ol>
<div class="p"><img class="image-border77" src="../images/00624.jpeg"/></div>
<ol start="6" class="calibre20">
<li value="6" class="calibre19">We can stack the IP and TCP layers by separating the variables with a forward slash. These layers can then be set equal to a new variable that will represent the entire request. We can then call the <kbd class="calibre16">display()</kbd> function to view the configurations for the request. Once the request has been built, it can then be passed to the <kbd class="calibre16">sr1()</kbd> function so that we can analyze the response, as follows:</li>
</ol>
<div class="p"><img class="image-border78" src="../images/00016.jpeg"/></div>
<ol start="7" class="calibre20">
<li value="7" class="calibre19">We can perform this same request without independently building and stacking each layer. Instead, we can use a single, one-line command by calling the functions directly and passing them the appropriate arguments, as follows:</li>
</ol>
<div class="p"><img class="image-border79" src="../images/00030.jpeg"/></div>
<ol start="8" class="calibre20">
<li value="8" class="calibre19">Note that when a SYN packet is sent to the TCP port <kbd class="calibre16">80</kbd> of a target web server, which is running an HTTP service on that port, the response has a TCP flag value of <kbd class="calibre16">SA</kbd>, which indicates that both the SYN and ACK flag bits are activated. This response indicates that the specified destination port is open and accepting connections. A different response will be returned if the same type of packet is sent to a port that is not accepting connections:</li>
</ol>
<div class="p"><img class="image-border80" src="../images/00356.jpeg"/></div>
<ol start="9" class="calibre20">
<li value="9" class="calibre19">When a SYN request is sent to a closed port, a response is returned with a TCP flag value of <kbd class="calibre16">RA</kbd>, which indicates that both the RST and ACK flag bits are activated. The ACK bit is merely used to acknowledge that the request was received, and the RST bit is used to discontinue the communication because the port is not accepting connections. Alternatively, if a SYN packet is sent to a system that is down or behind a firewall that is filtering such requests, it is likely that no response will be received. Due to this, a timeout option should always be used when the <kbd class="calibre16">sr1()</kbd> function is used in a script, to ensure that the script does not get hung up on unresponsive hosts:</li>
</ol>
<div class="p"><img class="image-border81" src="../images/00056.jpeg"/></div>
<ol start="10" class="calibre20">
<li value="10" class="calibre19">If the timeout value is not specified when this function is used against an unresponsive host, the function will continue indefinitely. In the demonstration, a timeout value of 1 second was provided for the completion of the function. The response value can be evaluated to determine whether a reply was received. Let's check that out.</li>
</ol>
<ol start="11" class="calibre20">
<li value="11" class="calibre19">Using Python makes it easy to test the variable to identify whether a value has been assigned to it by the <kbd class="calibre16">sr1()</kbd> function. This can be used as a preliminary check to determine whether any responses are being received. For responses that are received, subsequent checks can be performed to determine whether the response is indicating a port that is open or closed. All of this can easily be sequenced in a Python script, as follows:</li>
</ol>
<pre class="calibre24">
        #!/usr/bin/python<br class="title-page-name"/><br class="title-page-name"/>        import logging<br class="title-page-name"/>        logging.getLogger("scapy.runtime").setLevel(logging.ERROR)<br class="title-page-name"/><br class="title-page-name"/>        from scapy.all import *<br class="title-page-name"/>        import sys<br class="title-page-name"/><br class="title-page-name"/>        if len(sys.argv) != 4:<br class="title-page-name"/>            print "Usage - ./syn_scan.py [Target-IP] [First Port]<br class="title-page-name"/>              [Last Port]"<br class="title-page-name"/>            print "Example - ./syn_scan.py 10.0.0.5 1 100"<br class="title-page-name"/>            print "Example will TCP SYN scan ports 1 through<br class="title-page-name"/>              100 on 10.0.0.5"<br class="title-page-name"/>            sys.exit()<br class="title-page-name"/>        else:<br class="title-page-name"/>            ip = sys.argv[1]<br class="title-page-name"/>            start = int(sys.argv[2])<br class="title-page-name"/>            end = int(sys.argv[3])<br class="title-page-name"/><br class="title-page-name"/>        for port in range(start,end):<br class="title-page-name"/>            ans = sr1(IP(dst=ip)/TCP(dport=port),timeout=1,verbose =0)<br class="title-page-name"/>            if ans == None:<br class="title-page-name"/>                pass<br class="title-page-name"/>            else:<br class="title-page-name"/>                if int(ans[TCP].flags) == 18:<br class="title-page-name"/>                    print port<br class="title-page-name"/>                else:<br class="title-page-name"/>                    pass
</pre>
<ol start="12" class="calibre20">
<li value="12" class="calibre19">In the provided Python script, the user is prompted to enter an IP address, and the script then performs a SYN scan on the defined port sequence. The script then evaluates the response from each connection attempt to determine whether the response has the SYN and ACK TCP flags activated. The TCP flag for SYN+ACK is 0x12, which translates to 18 in decimal. If these flags, and only these flags, are present in the response, the corresponding port number received is then output:</li>
</ol>
<div class="p"><img class="image-border82" src="../images/00069.jpeg"/></div>
<ol start="13" class="calibre20">
<li value="13" class="calibre19">Upon running the script, the output will indicate any of the first <kbd class="calibre16">100</kbd> ports that are open on the system by providing the IP address:</li>
</ol>
<div class="p"><img class="image-border83" src="../images/00082.jpeg"/></div>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section>

            <header id="4JQ762-cf89710d791c4a3bb78ec273d9322426">
                </header><h1 class="header-title" id="calibre_pb_0">Connect scanning with Scapy</h1>
            

            <article>
                
<p class="calibre5">Let's perform the following steps to run the connect scan with Scapy:</p>
<ol class="calibre20">
<li value="1" class="calibre19">It can be difficult to run a full connect scan with Scapy because the system kernel remains unaware of your packet meddling with Scapy and attempts to prevent you from establishing a full three-way handshake with the remote system.</li>
<li value="2" class="calibre19">You can see this activity in action by sending a SYN request and sniffing the associated traffic with Wireshark or TCP dump.</li>
<li value="3" class="calibre19">When you receive a SYN+ACK response from the remote system, the Linux kernel will interpret it as an unsolicited response because it remains unaware of your request made in Scapy, and the system will automatically respond with a TCP RST packet, thereby discontinuing the handshake process. Consider the following example:</li>
</ol>
<pre class="calibre24">
        #!/usr/bin/python<br class="title-page-name"/><br class="title-page-name"/>        import logging<br class="title-page-name"/>        logging.getLogger("scapy.runtime").setLevel(logging.ERROR)<br class="title-page-name"/>        from scapy.all import *<br class="title-page-name"/><br class="title-page-name"/>        response = sr1(IP(dst="172.16.69.128")/TCP(dport=80,flags='S'))<br class="title-page-name"/>        reply = sr1(IP(dst="172.16.69.128")<br class="title-page-name"/>        /TCP(dport=80,flags='A',ack=(response[TCP].seq + 1)))
</pre>
<ol start="4" class="calibre20">
<li value="4" class="calibre19">This Python script can be used as a proof of concept to demonstrate the problem of the system breaking the three-way handshake. The script assumes that you are directing it toward a live system with an open port and therefore assumes that a SYN+ACK reply will be returned in response to the initial SYN request. Even though the final ACK reply is sent to complete the handshake, the RST packet prevents the connection from being established.</li>
<li value="5" class="calibre19">We can demonstrate this further by viewing the packets being sent and received:</li>
</ol>
<pre class="calibre24">
        #!/usr/bin/python<br class="title-page-name"/><br class="title-page-name"/>        import logging<br class="title-page-name"/>        logging.getLogger("scapy.runtime").setLevel(logging.ERROR)<br class="title-page-name"/>        from scapy.all import *<br class="title-page-name"/><br class="title-page-name"/>        SYN = IP(dst="172.16.69.128")/TCP(dport=80,flags='S')<br class="title-page-name"/><br class="title-page-name"/>        print "-- SENT --"<br class="title-page-name"/>        SYN.display()<br class="title-page-name"/><br class="title-page-name"/>        print "nn-- RECEIVED --"<br class="title-page-name"/>        response = sr1(SYN,timeout=1,verbose=0)<br class="title-page-name"/>        response.display()<br class="title-page-name"/><br class="title-page-name"/>        if int(response[TCP].flags) == 18:<br class="title-page-name"/>            print "nn-- SENT --"<br class="title-page-name"/>            ACK = IP(dst="172.16.69.128")/<br class="title-page-name"/>            TCP(dport=80,flags='A',ack=(response[TCP].seq + 1))<br class="title-page-name"/>            response2 = sr1(ACK,timeout=1,verbose=0)<br class="title-page-name"/>            ACK.display()<br class="title-page-name"/>            print "nn-- RECEIVED --"<br class="title-page-name"/>            response2.display()<br class="title-page-name"/>        else:<br class="title-page-name"/>            print "SYN-ACK not returned"
</pre>
<ol start="5" class="calibre20">
<li value="5" class="calibre19">In this Python script, each sent packet is displayed prior to transmission, and each received packet is displayed when it arrives. On examining the TCP flags that are activated in each packet, it becomes clear that the three-way handshake has failed. Consider the output that is generated by the script:</li>
</ol>
<div class="p"><img class="alignnone88" src="../images/00098.jpeg"/></div>
<ol start="6" class="calibre20">
<li value="6" class="calibre19">In the output from the script, four packets can be seen. The first packet is the sent SYN request, the second packet is the received SYN+ACK reply, the third packet is the sent ACK reply, and an RST packet is then received in response to the final ACK reply. It is this final packet that indicates that a problem was encountered when establishing the connection. It is possible to perform a full three-way handshake with Scapy, but it requires some tampering with the local iptables on the system. Specifically, you can only complete the handshake if you suppress the RST packets that are sent to the remote system that you are trying to connect with. By establishing a filtering rule using iptables, it is possible to drop the RST packets to complete the three-way handshake without interference from the system (this configuration is not recommended for continued functional usage).</li>
<li value="7" class="calibre19">To demonstrate the successful completion of the full three-way handshake, we establish a listening TCP service using Netcat and then attempt to connect to the open socket using Scapy:</li>
</ol>
<div class="p"><img class="image-border47" src="../images/00111.jpeg"/></div>
<ol start="8" class="calibre20">
<li value="8" class="calibre19">In the example provided, a listening service was opened on the TCP port <kbd class="calibre16">4444</kbd>. We can then modify the script that was discussed previously to attempt to connect to the Netcat TCP service on the port <kbd class="calibre16">4444</kbd>, as follows:</li>
</ol>
<pre class="calibre24">
        #!/usr/bin/python<br class="title-page-name"/><br class="title-page-name"/>        import logging<br class="title-page-name"/>        logging.getLogger("scapy.runtime").setLevel(logging.ERROR)<br class="title-page-name"/>        from scapy.all import *<br class="title-page-name"/><br class="title-page-name"/>        response = sr1(IP(dst="172.16.36.135")/<br class="title-page-name"/>        TCP(dport=4444,flags='S'))<br class="title-page-name"/>        reply = sr1(IP(dst="172.16.36.135")/<br class="title-page-name"/>        TCP(dport=4444,flags='A',ack=(response[TCP].seq + 1)))
</pre>
<ol start="9" class="calibre20">
<li value="9" class="calibre19">In this script, a SYN request was sent to the listening port, and then an ACK reply was sent in response to the anticipated SYN+ACK reply. To validate that the connection attempt is still interrupted by a system-generated RST packet, this script should be executed while Wireshark is being run to capture the request sequence.</li>
</ol>
<ol start="10" class="calibre20">
<li value="10" class="calibre19">We apply a filter to Wireshark to isolate the connection attempt sequence. The filter used was <kbd class="calibre16">tcp &amp;&amp; (ip.src == 172.16.69.128 || ip.dst == 172.16.69.128)</kbd>. This filter is used to only display the TCP traffic going to or from the system being scanned. This is shown in the following screenshot:</li>
</ol>
<div class="p"><img class="image-border47" src="../images/00375.jpeg"/></div>
<ol start="11" class="calibre20">
<li value="11" class="calibre19">Now that we have identified the exact problem, we can establish a filter that will allow us to suppress this system-generated RST response. This filter can be established by modifying the local iptables, as follows:</li>
</ol>
<div class="packt_tip">Modifying the local iptables in the following manner will impair the way your system handles the TCP/IP transactions with the destination system by blocking all outbound RST responses. Ensure that the created iptables rule is removed upon completion of this recipe, or flush the iptables afterward with the following command: <kbd class="calibre28">iptables --flush</kbd>.</div>
<div class="p"><img class="image-border84" src="../images/00135.jpeg"/></div>
<ol start="12" class="calibre20">
<li value="12" class="calibre19">In the example provided, the local iptables were modified to suppress all TCP RST packets going to the destination address of our scanned host. The <kbd class="calibre16">--list</kbd> option can then be used to view the iptable entries and verify that a configuration change has been made. To perform another connection attempt, we need to ensure that Netcat is still listening on the port <kbd class="calibre16">4444</kbd> of our target, as follows:</li>
</ol>
<div class="p"><img class="image-border85" src="../images/00148.jpeg"/></div>
<ol start="13" class="calibre20">
<li value="13" class="calibre19">The same Python script that was introduced previously should be run again, with Wireshark capturing the traffic in the background. Using the previously discussed display filter, we can easily focus on the traffic we need. Note that all of the steps of the three-way handshake have now been completed without any interruption by system-generated RST packets, as shown in the following screenshot:</li>
</ol>
<div class="p"><img class="image-border47" src="../images/00164.jpeg"/></div>
<ol start="14" class="calibre20">
<li value="14" class="calibre19">Additionally, if we take a look at our Netcat service, which is running on the target system, we notice that a connection has been established. This is further evidence to confirm that a successful connection was established. </li>
<li value="15" class="calibre19">While this is a useful exercise to understand and troubleshoot TCP connections, it is important not to leave the iptable entry in place. RST packets are an important component of TCP communications, and suppressing these responses altogether can drastically impair proper communication functionality. The following commands can be used to flush our iptables rules and verify that the flush was successful:</li>
</ol>
<div class="p"><img class="image-border86" src="../images/00179.jpeg"/></div>
<ol start="16" class="calibre20">
<li value="16" class="calibre19">As is demonstrated in the example provided, the <kbd class="calibre16">--flush</kbd> option should be used to clear the iptable entries that were made. We can verify that the iptable entries have been removed using the <kbd class="calibre16">--list</kbd> option one more time.</li>
</ol>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="4KONO1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Zombie scanning with Scapy</h1>
            

            <article>
                
<p class="calibre5">A value that exists in all IP packets is an ID number. Depending on the system, this ID number might be generated randomly, might always be zeroed out, or might increment by one with each IP packet that is sent. If a host with incremental IPID sequencing is discovered and that host is not interacting with other networked systems, it can be used as a means to identify open ports on other systems. We can identify the IPID sequencing patterns of a remote system by sending a series of IP packets and analyzing the responses:</p>
<div class="p"><img src="../images/00391.jpeg" class="calibre32"/></div>
<p class="calibre5">If we send two IP packets to an idle Windows system, we can examine the integer value of the ID attribute under the IP layer of the response.</p>
<div class="packt_infobox">Note that the reply to the first request had the ID <kbd class="calibre28">61</kbd>, and the reply to the second request had the ID <kbd class="calibre28">62</kbd>.</div>
<p class="calibre5">This host does, indeed, have incremental IPID sequencing, and assuming it remains idle, it can be used as an effective zombie for zombie scanning:</p>
<ol start="1" class="calibre20">
<li value="1" class="calibre19">To perform a zombie scan, an initial SYN+ACK request must be sent to the zombie system to determine the current IPID value in the returned RST packet.</li>
<li value="2" class="calibre19">Then, a spoofed SYN packet is sent to the scan target with the source IP address of the zombie system. If the port is open, the scan target will send a SYN+ACK response back to the zombie. Since the zombie did not actually send the initial SYN request, it will interpret the SYN+ACK request as unsolicited and send an RST packet back to the target, thereby incrementing its IPID by one.</li>
<li value="3" class="calibre19">Finally, another SYN+ACK packet should be sent to the zombie, which will return an RST packet and increment the IPID one more time. An IPID that has incremented by two from the initial response indicates that all of these events have transpired and that the destination port on the scanned system is open.</li>
<li value="4" class="calibre19">Alternatively, if the port on the scan target is closed, a different series of events will transpire, which will only cause the final RST response to be incremented by one. If the destination port on the scan target is closed, an RST packet will be sent to the zombie system in response to the initially spoofed SYN packet.</li>
<li value="5" class="calibre19">Since an RST packet solicits no response, the IPID value of the zombie system is not incremented. As a result, the final RST packet returned to the scanning system in response to the SYN+ACK packet will have incremented by only one.</li>
<li value="6" class="calibre19">To streamline this process, the following script can be written in Python, which will both identify a usable zombie system and also perform the zombie scan against the scan target:</li>
</ol>
<pre class="calibre24">
       #!/usr/bin/python<br class="title-page-name"/><br class="title-page-name"/>       import logging<br class="title-page-name"/>       logging.getLogger("scapy.runtime").setLevel(logging.ERROR)<br class="title-page-name"/>       from scapy.all import *<br class="title-page-name"/><br class="title-page-name"/>       def ipid(zombie):<br class="title-page-name"/>           reply1 = sr1(IP(dst=zombie)<br class="title-page-name"/>           /TCP(flags="SA"),timeout=2,verbose=0)<br class="title-page-name"/>           send(IP(dst=zombie)/TCP(flags="SA"),verbose=0)<br class="title-page-name"/>           reply2 = sr1(IP(dst=zombie)<br class="title-page-name"/>           /TCP(flags="SA"),timeout=2,verbose=0)<br class="title-page-name"/>           if reply2[IP].id == (reply1[IP].id + 2):<br class="title-page-name"/>               print "IPID sequence is incremental and target appears <br class="title-page-name"/>                 to be idle. ZOMBIE LOCATED"<br class="title-page-name"/>               response = raw_input("Do you want to use this zombie to <br class="title-page-name"/>                 perform a scan? (Y or N): ")<br class="title-page-name"/>               if response == "Y":<br class="title-page-name"/>                   target = raw_input("Enter the IP address of the<br class="title-page-name"/>                     target system: ")<br class="title-page-name"/>                   zombiescan(target,zombie)<br class="title-page-name"/>           else:<br class="title-page-name"/>               print "Either the IPID sequence is not incremental or <br class="title-page-name"/>                 the target is not idle. NOT A GOOD ZOMBIE"<br class="title-page-name"/><br class="title-page-name"/>       def zombiescan(target,zombie):<br class="title-page-name"/>           print "nScanning target " + target + " with zombie "<br class="title-page-name"/>            + zombie<br class="title-page-name"/>           print "n---------Open Ports on Target--------n"<br class="title-page-name"/>           for port in range(1,100):<br class="title-page-name"/>                try:<br class="title-page-name"/>                   start_val = sr1(IP(dst=zombie)<br class="title-page-name"/>                   /TCP(flags="SA",dport=port),timeout=2,verbose=0)<br class="title-page-name"/>                   send(IP(src=zombie,dst=target)<br class="title-page-name"/>                   /TCP(flags="S",dport=port),verbose=0)<br class="title-page-name"/>                   end_val = sr1(IP(dst=zombie)<br class="title-page-name"/>                   /TCP(flags="SA"),timeout=2,verbose=0)<br class="title-page-name"/>       if end_val[IP].id == (start_val[IP].id + 2):<br class="title-page-name"/>          print port<br class="title-page-name"/>       except:<br class="title-page-name"/>           pass<br class="title-page-name"/><br class="title-page-name"/>       print "-----------Zombie Scan Suite------------n"<br class="title-page-name"/>       print "1 - Identify Zombie Hostn"<br class="title-page-name"/>       print "2 - Perform Zombie Scann"<br class="title-page-name"/>       ans = raw_input("Select an Option (1 or 2): ")<br class="title-page-name"/>       if ans == "1":<br class="title-page-name"/>           zombie = raw_input("Enter IP address to test<br class="title-page-name"/>            IPID sequence: ")<br class="title-page-name"/>           ipid(zombie)<br class="title-page-name"/>       else:<br class="title-page-name"/>           if ans == "2":<br class="title-page-name"/>           zombie = raw_input("Enter IP address for zombie system: ")<br class="title-page-name"/>           target = raw_input("Enter IP address for scan target: ")<br class="title-page-name"/>           zombiescan(target,zombie)
</pre>
<ol start="7" class="calibre20">
<li value="7" class="calibre19">Upon executing this script, the user is prompted with two options. By selecting option <kbd class="calibre16">1</kbd>, we can scan or evaluate a target's IPID sequence to determine whether the host is a usable zombie. Assuming that the host is idle and has incremental IPID sequencing, the host will be flagged as a zombie, and the user will be asked to use the zombie to perform a scan.</li>
<li value="8" class="calibre19">If the scan is performed, the previously discussed process will be executed for each of the first 100 TCP port addresses, as follows:</li>
</ol>
<div class="p"><img class="image-border87" src="../images/00394.jpeg"/></div>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="4LN8A1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works…</h1>
            

            <article>
                
<p class="calibre5">In this recipe, UDP scanning is performed by identifying the ports that do not respond with ICMP port-unreachable responses. This process can be highly time consuming as ICMP port-unreachable responses are often throttled. It can also, at times, be an unreliable approach as some systems do not generate these responses, and ICMP is often filtered by firewalls.</p>
<p class="calibre5">Stealth scans are performed by sending an initial SYN packet request to a target TCP port on a remote system, and the status of this port is determined by the type of response that is returned. If the remote system returns a SYN+ACK response, then it is prepared to establish a connection, and one can assume that the port is open. If the service returns an RST packet, it is an indication that the port is closed and not accepting connections. Furthermore, if no response is returned, then a firewall might be present between the scanning system and remote system that is dropping the requests. This could also be an indication that the machine is down or that there is no system associated with the destination IP address.</p>
<p class="calibre5">TCP connect scans operate by performing a full three-way handshake to establish a connection with all of the scanned ports on the remote target system. A port's status is determined based on whether a connection was established or not. If a connection was established, the port is determined to be open. If a connection could not be established, the port is determined to be closed.</p>
<p class="calibre5">Zombie scanning is a stealthy way to enumerate open ports on a target system without leaving any trace of interaction with it. Using a combination of spoofed requests sent to the target system and legitimate requests sent to the zombie system, we can map the open ports on the target system by evaluating the IPID values of the responses from the zombie.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="4MLOS1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Port scanning with Nmap (UDP, stealth, connect, zombie)</h1>
            

            <article>
                
<p class="calibre5">Nmap can be utilized to perform UDP, TCP stealth, TCP connect, and zombie scans. In this section, we will discuss how to conduct each of these types of scans. The Nmap approach to UDP scanning is more complex and attempts to identify live services by injecting service-specific probe requests in an effort to solicit a positive response that confirms the existence of a given service. We will also discuss how Nmap handles stealth and TCP connect scanning. Finally, we will look at a highly effective scanning mode Nmap has for zombie scanning.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="4NK9E1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre5">To use Nmap to perform UDP, TCP stealth, TCP connect, or zombie scans, you will need to have a remote system that is running network services over UDP and TCP. In the examples provided, an instance of Metasploitable2 is used as a scan target, and an installation of Windows XP is used as an incremental IPID zombie. In the examples provided, a combination of Linux and Windows systems is used.</p>
<p class="calibre5">For more information on how to set up systems in a local lab environment, refer to the <em class="calibre15">Installing Metasploitable2</em> and <em class="calibre15">Installing Windows Server</em> recipes in <a href="part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426" target="_blank" class="calibre6">Chapter 1</a>, <em class="calibre15">Getting Started</em>. Additionally, this section will require a script to be written to the filesystem using a text editor such as Vim or GNU nano. For more information on how to write scripts, refer to the <em class="calibre15">Using text editors (Vim and <span>GNU n</span>ano)</em> recipe in <a href="part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426" target="_blank" class="calibre6">Chapter 1</a>, <em class="calibre15">Getting Started</em>.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="4OIQ01-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it…</h1>
            

            <article>
                
<p class="calibre5">Let's start with UDP scanning with Nmap.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="4PHAI1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">UDP scanning with Nmap</h1>
            

            <article>
                
<p class="calibre5">UDP scanning can often be challenging, time consuming, and tedious. Many systems will rate-limit ICMP host-unreachable replies and can drastically increase the amount of time required to scan a large number of ports and/or systems. Fortunately, the developers of Nmap have a more complex and much more effective tool to identify UDP services on remote systems.</p>
<ol class="calibre20">
<li value="1" class="calibre19">To perform a UDP scan with Nmap, the <kbd class="calibre16">-sU</kbd> option should be used with the IP address of the host that is to be scanned:</li>
</ol>
<div class="p"><img class="image-border88" src="../images/00396.jpeg"/></div>
<ol start="2" class="calibre20">
<li value="2" class="calibre19">Although Nmap is built to solicit replies from UDP ports with custom payloads for many services, it still requires a large amount of time to even scan the default 1,000 ports when no other arguments are used to specify the destination ports. As you can see from the scan metadata at the bottom of the output, the default scan required nearly 20 minutes to complete. Alternatively, we can shorten the required scan time by performing targeted scans, as shown in the following command:</li>
</ol>
<div class="p"><img class="image-border47" src="../images/00239.jpeg"/></div>
<ol start="3" class="calibre20">
<li value="3" class="calibre19">The amount of time required to perform UDP scans can be drastically reduced if we specify the particular ports that need to be scanned. This can be done by performing a UDP scan and specifying the port with the <kbd class="calibre16">-p</kbd> option.</li>
<li value="4" class="calibre19">In the preceding example, we are performing a scan only on the port <kbd class="calibre16">53</kbd> to attempt to identify a DNS service. A scan can also be performed on multiple specified ports, as follows:</li>
</ol>
<div class="p"><img class="image-border47" src="../images/00404.jpeg"/></div>
<ol start="5" class="calibre20">
<li value="5" class="calibre19">In the example provided, a scan was performed on the first 100 ports. This was done using dash notation and specifying both the first and last port to be scanned. Nmap then spins up multiple processes that will be used to simultaneously scan all of the ports between and including these two values.</li>
</ol>
<ol start="6" class="calibre20">
<li value="6" class="calibre19">On some occasions, a UDP analysis will need to be performed on multiple systems. A range of hosts can be scanned with Nmap using dash notation and by defining the range of values for the last octet, as follows:</li>
</ol>
<div class="p"><img class="image-border89" src="../images/00407.jpeg"/></div>
<ol start="7" class="calibre20">
<li value="7" class="calibre19">In the example provided, scans were performed on all live hosts within the <kbd class="calibre16">172.16.69.0/24</kbd> range. Each host was scanned to identify whether a DNS service was running on the port <kbd class="calibre16">53</kbd>. Another alternative option would be to scan multiple hosts using an input list of IP addresses.</li>
</ol>
<ol start="8" class="calibre20">
<li value="8" class="calibre19">To do this, the <kbd class="calibre16">-iL</kbd> option should be used, and it should be passed as either the name of a file in the same directory or the full path of a file in a separate directory. An example of the former is as follows:</li>
</ol>
<div class="p"><img class="image-border90" src="../images/00412.jpeg"/></div>
<ol start="9" class="calibre20">
<li value="9" class="calibre19">In the example provided, a scan was performed to determine whether an NTP service was running on the port <kbd class="calibre16">123</kbd> on any of the systems within the <kbd class="calibre16">iplist.txt</kbd> file in the execution directory.</li>
</ol>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="4QFR41-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Stealth scanning with Nmap</h1>
            

            <article>
                
<p class="calibre5">As with most scanning requirements, Nmap has an option that simplifies and streamlines the process of performing TCP stealth scans:</p>
<ol start="1" class="calibre20">
<li value="1" class="calibre19">To perform TCP stealth scans with Nmap, the <kbd class="calibre16">-sS</kbd> option should be used with the IP address of the host that is to be scanned:</li>
</ol>
<div class="p"><img class="image-border47" src="../images/00297.jpeg"/></div>
<ol start="2" class="calibre20">
<li value="2" class="calibre19">In the example provided, a SYN scan was performed on the TCP port <kbd class="calibre16">80</kbd> of the specified IP address. Similar to the technique explained with Scapy, Nmap listens for a response and identifies the open ports by analyzing the TCP flags that are activated in any responses received. We can also use Nmap to perform scans on multiple specified ports by passing a comma-delimited list of port numbers, as follows:</li>
</ol>
<div class="p"><img class="image-border47" src="../images/00312.jpeg"/></div>
<ol start="3" class="calibre20">
<li value="3" class="calibre19">In the example provided, a SYN scan was performed on the ports <kbd class="calibre16">21</kbd>, <kbd class="calibre16">80</kbd>, and <kbd class="calibre16">443</kbd> of the specified target IP address. We can also use Nmap to scan a sequential series of hosts by indicating the first and last port numbers to be scanned, separated using dash notation:</li>
</ol>
<div class="p"><img class="image-border91" src="../images/00329.jpeg"/></div>
<ol start="4" class="calibre20">
<li value="4" class="calibre19">In the example provided, a SYN scan was performed on the TCP ports <kbd class="calibre16">20</kbd> through <kbd class="calibre16">25</kbd>. In addition to providing us with the ability to specify the ports to be scanned, Nmap also has a preconfigured list of 1,000 commonly used ports. We can perform a scan on these ports by running Nmap without supplying any port specifications:</li>
</ol>
<div class="p"><img class="image-border92" src="../images/00423.jpeg"/></div>
<ol start="5" class="calibre20">
<li value="5" class="calibre19">In the example provided, the 1,000 common ports defined by Nmap were scanned to identify a large number of open ports on the Metasploitable2 system. Although this technique is effective in identifying most services, it might fail to identify obscure services or uncommon port associations.</li>
</ol>
<ol start="6" class="calibre20">
<li value="6" class="calibre19">If a scan is to be performed on all possible TCP ports, all of the possible port address values need to be scanned. The portions of the TCP header that define the source and destination port addresses are both 16 bits in length. Moreover, each bit can retain a value of 1 or 0. As such, there are 2<sup class="calibre33">16</sup>, or 65,536, possible TCP port addresses. For the total possible address space to be scanned, a port range of 0 to 65535 needs to be supplied, as follows:</li>
</ol>
<div class="p"><img src="../images/00361.jpeg" class="calibre34"/></div>
<ol start="7" class="calibre20">
<li value="7" class="calibre19">In the example provided, all of the 65,536 possible TCP addresses were scanned on the Metasploitable2 system. Take note of the fact that more services were identified in this scan than were identified in the standard Nmap 1,000 scan. This is evidence of the fact that a full scan is always best practice when attempting to identify all of the possible attack surface on a target. Nmap can also be used to scan TCP ports on a sequential series of hosts, using dash notation:</li>
</ol>
<div class="p"><img src="../images/00381.jpeg" class="calibre35"/></div>
<ol start="8" class="calibre20">
<li value="8" class="calibre19">In the example provided, a SYN scan of the TCP port <kbd class="calibre16">80</kbd> was performed on all of the hosts within the range of addresses specified. Although this particular scan was only performed on a single port, Nmap also has the ability to scan multiple ports and ranges of ports on multiple systems simultaneously. Additionally, Nmap can also be configured to scan hosts based on an input list of IP addresses. This can be done using the <kbd class="calibre16">-iL</kbd> option and then specifying either the filename, if the file exists in the execution directory, or the path of the file. Nmap then cycles through each address in the input list and performs the specified scan against that address:</li>
</ol>
<div class="p"><img src="../images/00434.jpeg" class="calibre36"/></div>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="4REBM1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Connect scanning with Nmap</h1>
            

            <article>
                
<p class="calibre5">Nmap has an option that simplifies and streamlines the process of performing TCP connect scans:</p>
<ol class="calibre20">
<li value="1" class="calibre19">To perform TCP connect scans with Nmap, the <kbd class="calibre16">-sT</kbd> option should be used with the IP address of the host to be scanned, as follows:</li>
</ol>
<div class="p"><img class="image-border47" src="../images/00436.jpeg"/></div>
<ol start="2" class="calibre20">
<li value="2" class="calibre19">In the example provided, a TCP connect scan was performed on the TCP port <kbd class="calibre16">80</kbd> of the specified IP address. Similar to the technique used with Scapy, Nmap listens for a response and identifies open ports by analyzing the TCP flags that are activated in any responses received. We can also use Nmap to perform scans on multiple specified ports by passing a comma-delimited list of port numbers, as follows:</li>
</ol>
<div class="p"><img class="image-border93" src="../images/00439.jpeg"/></div>
<ol start="3" class="calibre20">
<li value="3" class="calibre19">In the example provided, a TCP connect scan was performed on the ports <kbd class="calibre16">21</kbd>, <kbd class="calibre16">80</kbd>, and <kbd class="calibre16">443</kbd> of the specified target IP address. We can also use Nmap to scan a sequential series of hosts by indicating the first and last port numbers to be scanned, separated using dash notation:</li>
</ol>
<div class="p"><img class="image-border94" src="../images/00455.jpeg"/></div>
<ol start="4" class="calibre20">
<li value="4" class="calibre19">In the example provided, a TCP connect scan was performed on the TCP ports <kbd class="calibre16">20</kbd> through <kbd class="calibre16">25</kbd>. In addition to providing the ability to specify the ports to be scanned, Nmap also has a preconfigured list of 1,000 commonly used ports. We can scan these ports by running Nmap without supplying any port specifications:</li>
</ol>
<div class="p"><img class="image-border95" src="../images/00274.jpeg"/></div>
<ol start="5" class="calibre20">
<li value="5" class="calibre19">In the example provided, the 1,000 common ports defined by Nmap were scanned to identify a large number of open ports on the Metasploitable2 system. Although this technique is effective in identifying most services, it might fail to identify obscure services or uncommon port associations.</li>
<li value="6" class="calibre19">To scan all of the possible TCP ports, all possible port address values must be scanned. The portions of the TCP header that define the source and destination port addresses are both 16 bits in length. Furthermore, each bit can retain a value of 1 or 0. As such, there are 2<sup class="calibre33">16</sup>, or 65,536, possible TCP port addresses. For the total possible address space to be scanned, a port range of <kbd class="calibre16">0-65535</kbd> needs to be supplied, as follows:</li>
</ol>
<div class="p"><img class="image-border96" src="../images/00447.jpeg"/></div>
<ol start="7" class="calibre20">
<li value="7" class="calibre19">In the example provided, all of the possible 65,536 TCP addresses were scanned on the Metasploitable2 system. Take note of the fact that more services were identified in this scan than in the standard Nmap 1,000 scan. This is evidence of the fact that a full scan is always best practice when attempting to identify all of the possible attack surfaces on a target. Nmap can also be used to scan TCP ports on a sequential series of hosts using dash notation:</li>
</ol>
<div class="p"><img class="image-border97" src="../images/00446.jpeg"/></div>
<ol start="8" class="calibre20">
<li value="8" class="calibre19">In the example provided, a TCP connect scan of the TCP port <kbd class="calibre16">80</kbd> was performed on all hosts within the range of hosts specified. Although this particular scan was only performed on a single port, Nmap can also scan multiple ports and ranges of ports on multiple systems simultaneously. Additionally, Nmap can also be configured to scan hosts based on an input list of IP addresses.</li>
</ol>
<ol start="9" class="calibre20">
<li value="9" class="calibre19">This can be done using the <kbd class="calibre16">-iL</kbd> option and then by specifying either the filename, whether the file exists in the execution directory, or the path of the file. Nmap then cycles through each address in the input list and performs the specified scan against that address, as follows:</li>
</ol>
<div class="p"><img class="image-border47" src="../images/00453.jpeg"/></div>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="4SCS81-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Zombie scanning with Nmap</h1>
            

            <article>
                
<p class="calibre5">These steps will help you to perform a zombie scan on the Nmap:</p>
<ol class="calibre20">
<li value="1" class="calibre19">Zombie scans can also be performed with an option in Nmap. However, prior to using the Nmap zombie scan, we can quickly find any viable zombie candidates by sweeping an entire address range and assessing the IPID sequencing patterns with Metasploit.</li>
</ol>
<ol start="2" class="calibre20">
<li value="2" class="calibre19">To do this, we need to open Metasploit with the <kbd class="calibre16">msfconsole</kbd> command and then select the IPID sequencing <kbd class="calibre16">auxiliary</kbd> module for use, as follows:</li>
</ol>
<div class="p"><img class="image-border47" src="../images/00583.jpeg"/></div>
<ol start="3" class="calibre20">
<li value="3" class="calibre19">This <kbd class="calibre16">auxiliary</kbd> module can be used to perform a scan on a sequential series of host addresses or on a network range, as defined by the CIDR notation. For the speed of the scan to be increased, the <kbd class="calibre16">THREADS</kbd> variable should be increased to the desired number of concurrent tasks, as follows:</li>
</ol>
<div class="p"><img class="image-border98" src="../images/00460.jpeg"/></div>
<ol start="4" class="calibre20">
<li value="4" class="calibre19">Once the desired values for the required variables have been populated, we can verify the configurations of the scan again using the <kbd class="calibre16">show options</kbd> command. The IPID sequence scan can then be executed using the <kbd class="calibre16">run</kbd> command:</li>
</ol>
<div class="p"><img class="image-border99" src="../images/00557.jpeg"/></div>
<ol start="5" class="calibre20">
<li value="5" class="calibre19">As the IPID sequence scanning module sweeps through the provided network range, it will identify the IPID sequencing patterns of discovered hosts and indicate whether they are zeros, randomized, or incremental.</li>
</ol>
<ol start="6" class="calibre20">
<li value="6" class="calibre19">An ideal candidate for zombie scanning is a host that has both incremental IPID sequencing and is not interacting heavily with other systems on the network. Once an incremental idle host has been identified, we can perform the zombie scan in Nmap using the <kbd class="calibre16">-sI</kbd> option and by passing it the IP address of the zombie host that needs to be used for scanning:</li>
</ol>
<div class="p"><img class="alignnone89" src="../images/00137.jpeg"/></div>
<ol start="7" class="calibre20">
<li value="7" class="calibre19">In the example provided, a zombie scan was performed on the first 100 TCP ports of the scan target, <kbd class="calibre16">172.16.69.128</kbd>. The idle host at <kbd class="calibre16">172.16.69.128</kbd> was used as the zombie, and the <kbd class="calibre16">-Pn</kbd> option was used to prevent Nmap from attempting to ping the scan target.</li>
<li value="8" class="calibre19">In this demonstration, we identified and enumerated all of the listed open ports and never interacted directly with the scanned target. Instead, source-spoofed packets were sent to the scan target, and the only direct interaction was between the scanning system and the zombie host.</li>
</ol>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="4TBCQ1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works…</h1>
            

            <article>
                
<p class="calibre5">While Nmap still has to contend with many of the same challenges associated with UDP scanning, it is still a highly effective solution because it is optimized to use a combination of the most effective and quickest techniques possible to identify live services.</p>
<p class="calibre5">The underlying principle behind how SYN scanning is performed with Nmap is the same as has already been discussed. However, with multithreaded capabilities, Nmap is a fast and highly effective way to perform these types of scans.</p>
<p class="calibre5">Tools that perform TCP connect scans operate by performing a full three-way handshake to establish a connection with all scanned ports on the remote target system. A port's status is determined based on whether a connection was established or not. If a connection was established, the port is determined to be open. If a connection could not be established, the port is determined to be closed.</p>
<p class="calibre5">The underlying principle behind zombie scanning is the same as was discussed when performing this task with Scapy in the previous recipe. However, using the Nmap zombie-scanning mode allows us to use an integrated and well-known tool to perform this same task quickly.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="4U9TC1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Port scanning with Metasploit (UDP, stealth, and connect)</h1>
            

            <article>
                
<p class="calibre5">Metasploit has auxiliary modules that can be used to perform UDP, SYN, and TCP connect scanning. Using Metasploit for scanning as well as exploitation can be an effective way to cut down on the total number of tools required to complete a penetration test. This specific recipe demonstrates how we can use Metasploit to perform port scanning.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="4V8DU1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre5">To use Metasploit to perform UDP, TCP stealth, and TCP full connect scans, you will need to have a remote system that is running network services over UDP and TCP. In the examples provided, an instance of Metasploitable2 is used to perform this task. For more information on how to set up Metasploitable2, refer to <a href="part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426" target="_blank" class="calibre6">Chapter 1</a>, <em class="calibre15">Getting Started</em>.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="506UG1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it…</h1>
            

            <article>
                
<p class="calibre5">Let's start with UDP scanning with Metasploit.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="515F21-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">UDP scanning with Metasploit</h1>
            

            <article>
                
<p class="calibre5">Prior to defining the module to be run, Metasploit needs to be opened:</p>
<ol class="calibre20">
<li value="1" class="calibre19">To open Metasploit in Kali Linux, we use the <kbd class="calibre16">msfconsole</kbd> command in a Terminal session, as follows:</li>
</ol>
<div class="p"><img class="image-border100" src="../images/00215.jpeg"/></div>
<ol start="2" class="calibre20">
<li value="2" class="calibre19">To run the UDP sweep module in Metasploit, we call the <kbd class="calibre16">use</kbd> command with the relative path of the <kbd class="calibre16">auxiliary</kbd> module. Once the module has been selected, the <kbd class="calibre16">show options</kbd> command can be used to identify and/or modify scan configurations. This command will display four column headers to include: <kbd class="calibre16">Name</kbd>, <kbd class="calibre16">Current Setting</kbd>, <kbd class="calibre16">Required</kbd>, and <kbd class="calibre16">Description</kbd>. The <kbd class="calibre16">Name</kbd> column identifies the name of each configurable variable. The <kbd class="calibre16">Current Setting</kbd> column lists the existing configuration for any given variable. The <kbd class="calibre16">Required</kbd> column identifies whether a value is required for any given variable. The <kbd class="calibre16">Description</kbd> column describes the function of each variable. The value for any given variable can be changed using the <kbd class="calibre16">set</kbd> command and by providing the new value as an argument:</li>
</ol>
<div class="p"><img class="image-border47" src="../images/00286.jpeg"/></div>
<ol start="3" class="calibre20">
<li value="3" class="calibre19">In the example provided, the <kbd class="calibre16">RHOSTS</kbd> value was changed to the IP address of the remote system that we wish to scan. Additionally, the number of threads has changed to <kbd class="calibre16">20</kbd>. The <kbd class="calibre16">THREADS</kbd> value defines the number of concurrent tasks that will be performed in the background. Determining thread values consists of finding a good balance that will noticeably improve the speed of the task without overly depleting system resources. For most systems, <kbd class="calibre16">20</kbd> threads is a fast and reasonably safe number of concurrent processes. After the necessary variables have been updated, the configurations can be verified using the <kbd class="calibre16">show options</kbd> command again. Once the desired configurations have been verified, the scan can be launched, as follows:</li>
</ol>
<div class="p"><img class="image-border47" src="../images/00469.jpeg"/></div>
<ol start="4" class="calibre20">
<li value="4" class="calibre19">The <kbd class="calibre16">run</kbd> command is used in Metasploit to execute the selected <kbd class="calibre16">auxiliary</kbd> module. In the example provided, the <kbd class="calibre16">run</kbd> command executed a UDP sweep against the specified IP address. The <kbd class="calibre16">udp_sweep</kbd> module can also be run against a sequential series of addresses using dash notation:</li>
</ol>
<div class="p"><img class="image-border101" src="../images/00621.jpeg"/></div>
<ol start="5" class="calibre20">
<li value="5" class="calibre19">In the example provided, a UDP scan was performed against ten host addresses that were specified by the <kbd class="calibre16">RHOSTS</kbd> variable. Similarly, <kbd class="calibre16">RHOSTS</kbd> can be used to define a network range using the CIDR notation, as follows:</li>
</ol>
<div class="p"><img class="image-border102" src="../images/00475.jpeg"/></div>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="523VK1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Stealth scanning with Metasploit</h1>
            

            <article>
                
<p class="calibre5">Metasploit has an <kbd class="calibre16">auxiliary</kbd> module that can be used to perform SYN scans on specified TCP ports:</p>
<ol class="calibre20">
<li value="1" class="calibre19">To open up Metasploit in Kali Linux, we use the <kbd class="calibre16">msfconsole</kbd> command in a Terminal session, as follows:</li>
</ol>
<div class="p"><img src="../images/00642.jpeg" class="calibre37"/></div>
<ol start="2" class="calibre20">
<li value="2" class="calibre19">To run the SYN scan module in Metasploit, call the <kbd class="calibre16">use</kbd> command with the relative path of the <kbd class="calibre16">auxiliary</kbd> module. Once the module has been selected, the <kbd class="calibre16">show options</kbd> command can be used to identify and/or modify scan configurations. This command will display four column headers to include <kbd class="calibre16">Name</kbd>, <kbd class="calibre16">Current Setting</kbd>, <kbd class="calibre16">Required</kbd>, and <kbd class="calibre16">Description</kbd>. The <kbd class="calibre16">Name</kbd> column identifies the name of each configurable variable. The <kbd class="calibre16">Current Setting</kbd> column lists the existing configuration for any given variable. The <kbd class="calibre16">Required</kbd> column identifies whether a value is required for any given variable. Finally, the <kbd class="calibre16">Description</kbd> column describes the function of each variable. The value for any given variable can be changed using the <kbd class="calibre16">set</kbd> command and by providing the new value as an argument:</li>
</ol>
<div class="p"><img class="image-border103" src="../images/00646.jpeg"/></div>
<ol start="3" class="calibre20">
<li value="3" class="calibre19">In the example provided, the <kbd class="calibre16">RHOSTS</kbd> value was changed to the IP address of the remote system that we wish to scan. Additionally, the number of threads is changed to <kbd class="calibre16">20</kbd>. The <kbd class="calibre16">THREADS</kbd> value defines the number of concurrent tasks that will be performed in the background. Determining thread values consists of finding a good balance that will noticeably improve the speed of the task without overly depleting system resources. For most systems, <kbd class="calibre16">20</kbd> threads is a fast and reasonably safe number of concurrent processes. The <kbd class="calibre16">PORTS</kbd> value is set to the TCP port <kbd class="calibre16">80</kbd> (HTTP). After the necessary variables have been updated, the configurations can again be verified using the <kbd class="calibre16">show options</kbd> command. Once the desired configurations have been verified, the scan can be launched as follows:</li>
</ol>
<div class="p"><img class="image-border47" src="../images/00481.jpeg"/></div>
<ol start="4" class="calibre20">
<li value="4" class="calibre19">The <kbd class="calibre16">run</kbd> command is used in Metasploit to execute the selected <kbd class="calibre16">auxiliary</kbd> module. In the example provided, the <kbd class="calibre16">run</kbd> command executed a TCP SYN scan against the port <kbd class="calibre16">80</kbd> of the specified IP address. We can also run this TCP SYN scan module against a sequential series of TCP ports by supplying the first and last values, separated using dash notation:</li>
</ol>
<div class="p"><img class="image-border104" src="../images/00669.jpeg"/></div>
<ol start="5" class="calibre20">
<li value="5" class="calibre19">In the example provided, a TCP SYN scan was performed on the first 100 TCP port addresses of the remote host that was specified. Although this scan identified multiple services on the target system, we cannot possibly be sure that all services have been identified unless all of the possible port addresses have been scanned. The portions of the TCP header that define the source and destination port addresses are both 16 bits in length. Furthermore, each bit can retain a value of 1 or 0. As such, there are 2<sup class="calibre33">16</sup>, or 65,536, possible TCP port addresses. For the total possible address space to be scanned, a port range of 0 to 65535 needs to be supplied, as follows:</li>
</ol>
<div class="p"><img class="image-border105" src="../images/00154.jpeg"/></div>
<ol start="6" class="calibre20">
<li value="6" class="calibre19">In the example provided, all of the open TCP ports on the remote system were identified by scanning all of the possible TCP port addresses. We can also modify the scan configurations to scan a sequential series of addresses using dash notation:</li>
</ol>
<div class="p"><img class="image-border47" src="../images/00014.jpeg"/></div>
<ol start="7" class="calibre20">
<li value="7" class="calibre19">In the example provided, a TCP SYN scan was performed on the port <kbd class="calibre16">80</kbd> against all of the host addresses specified by the <kbd class="calibre16">RHOSTS</kbd> variable. Similarly, <kbd class="calibre16">RHOSTS</kbd> can be used to define a network range using CIDR notation:</li>
</ol>
<div class="p"><img class="image-border47" src="../images/00303.jpeg"/></div>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="532G61-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Connect scanning with Metasploit</h1>
            

            <article>
                
<p class="calibre5">Metasploit has an <kbd class="calibre16">auxiliary</kbd> module that can be used to perform TCP connect scans on specified TCP ports:</p>
<ol class="calibre20">
<li value="1" class="calibre19">To open up Metasploit in Kali Linux, use the <kbd class="calibre16">msfconsole</kbd> command in a Terminal session, as follows:</li>
</ol>
<div class="p"><img src="../images/00389.jpeg" class="calibre38"/></div>
<ol start="2" class="calibre20">
<li value="2" class="calibre19">To call the TCP connect scan module in Metasploit, use the <kbd class="calibre16">use</kbd> command with the relative path of the <kbd class="calibre16">auxiliary</kbd> module. Once the module has been selected, the <kbd class="calibre16">show options</kbd> command can be used to identify and/or modify scan configurations. This command will display four column headers to include: <kbd class="calibre16">Name</kbd>, <kbd class="calibre16">Current Setting</kbd>, <kbd class="calibre16">Required</kbd>, and <kbd class="calibre16">Description</kbd>. The <kbd class="calibre16">Name</kbd> column identifies the name of each configurable variable. The <kbd class="calibre16">Current Setting</kbd> column lists the existing configuration for any given variable. The <kbd class="calibre16">Required</kbd> column identifies whether a value is required for any given variable. Finally, the <kbd class="calibre16">Description</kbd> column describes the function of each variable. We can change the value for any given variable using the <kbd class="calibre16">set</kbd> command and by providing the new value as an argument, as follows:</li>
</ol>
<div class="p"><img class="image-border47" src="../images/00474.jpeg"/></div>
<ol start="3" class="calibre20">
<li value="3" class="calibre19">In the example provided, the <kbd class="calibre16">RHOSTS</kbd> value was changed to the IP address of the remote system that we wish to scan. The <kbd class="calibre16">PORTS</kbd> value is set to the TCP port <kbd class="calibre16">80</kbd> (HTTP). After the necessary variables have been updated, the configurations can be verified again using the <kbd class="calibre16">show options</kbd> command. Once the desired configurations have been verified, the scan is launched. The <kbd class="calibre16">run</kbd> command is used in Metasploit to execute the selected <kbd class="calibre16">auxiliary</kbd> module. In the example provided, the <kbd class="calibre16">run</kbd> command executes a TCP connect scan against the port <kbd class="calibre16">80</kbd> of the specified IP address.</li>
</ol>
<p class="calibre39">This TCP connect scan can also be performed against a sequential series of TCP ports by supplying the first and last values, separated by a dash:</p>
<div class="p"><img class="image-border47" src="../images/00497.jpeg"/></div>
<ol start="4" class="calibre20">
<li value="4" class="calibre19">In the example provided, the first 100 TCP port addresses were set to be scanned. Additionally, the number of threads was changed to <kbd class="calibre16">20.</kbd> The <kbd class="calibre16">THREADS</kbd> value defines the number of concurrent tasks that will be performed in the background. Determining thread values consists of finding a good balance that will noticeably improve the speed of the task without overly depleting system resources. For most systems, <kbd class="calibre16">20</kbd> threads is a fast and reasonably safe number of concurrent processes. Although this scan identified multiple services on the target system, one cannot be sure that all services have been identified unless all of the possible port addresses have been scanned. The portions of the TCP header that define the source and destination port addresses are both 16 bits in length. Moreover, each bit can retain a value of 1 or 0. As such, there are 2<sup class="calibre33">16</sup>, or 65,536, possible TCP port addresses. For the total possible address space to be scanned, a port range of 0 to 65535 needs to be supplied, as follows:</li>
</ol>
<div class="p"><img class="image-border47" src="../images/00079.jpeg"/></div>
<ol start="5" class="calibre20">
<li value="5" class="calibre19">In the example provided, all of the open TCP ports on the remote system were identified by scanning all of the possible TCP port addresses. We can also modify the scan configurations to scan a sequential series of addresses using dash notation:</li>
</ol>
<div class="p"><img src="../images/00657.jpeg" class="calibre40"/></div>
<ol start="6" class="calibre20">
<li value="6" class="calibre19">In the example provided, a TCP connect scan is performed on the ports <kbd class="calibre16">22</kbd>, <kbd class="calibre16">80</kbd>, and <kbd class="calibre16">443</kbd> on all of the host addresses specified by the <kbd class="calibre16">RHOSTS</kbd> variable. Similarly, <kbd class="calibre16">RHOSTS</kbd> can be used to define a network range using CIDR notation:</li>
</ol>
<div class="p"><img src="../images/00506.jpeg" class="calibre41"/></div>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="5410O1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works…</h1>
            

            <article>
                
<p class="calibre5">UDP scanning with the Metasploit <kbd class="calibre16">auxiliary</kbd> module is less comprehensive than UDP scanning with Nmap. It only targets a limited number of services, but it is highly effective at identifying live services on these ports and faster than most other available UDP scanning solutions.</p>
<p class="calibre5">The underlying principle behind Metasploit's SYN scan the <kbd class="calibre16">auxiliary</kbd> module is essentially the same as any other SYN scanning tool. For each port that is scanned, a SYN packet is sent, and the SYN+ACK responses are used to identify live services. Using Metasploit might be more appealing to some because of the interactive console and also because it is a tool that is already well known by most penetration testers.</p>
<p class="calibre5">The underlying principle that defines how a TCP connect scan is performed by Metasploit is the same as previously discussed with other tools. The advantage of performing this type of scan using Metasploit is that it can cut down on the total number of tools that one needs to familiarize oneself with.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="54VHA1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Port scanning with hping3 (stealth)</h1>
            

            <article>
                
<p class="calibre5">In addition to the discovery techniques that we've learned, the <kbd class="calibre16">hping3</kbd> command can also be used to perform port scans. This specific recipe demonstrates how we can use the <kbd class="calibre16">hping3</kbd> command to perform a TCP stealth scan.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="55U1S1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre5">To use the <kbd class="calibre16">hping3</kbd> command to perform a TCP stealth scan, you will need to have a remote system that is running accessible network services over TCP. In the examples provided, an instance of Metasploitable2 is used to perform this task. For more information on how to set up Metasploitable2, refer to <a href="part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426" target="_blank" class="calibre6">Chapter 1</a>, <em class="calibre15">Getting Started</em>.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="56SIE1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it…</h1>
            

            <article>
                
<p class="calibre5">In addition to the discovery capabilities that have already been mentioned, the <kbd class="calibre16">hping3</kbd> command can also be used to perform a TCP port scan:</p>
<ol class="calibre20">
<li value="1" class="calibre19">To perform a port scan with <kbd class="calibre16">hping3</kbd>, we need to use the <kbd class="calibre16">--scan</kbd> mode with an integer value to indicate the port number to be scanned:</li>
</ol>
<div class="p"><img class="image-border106" src="../images/00121.jpeg"/></div>
<ol start="2" class="calibre20">
<li value="2" class="calibre19">In the example provided, a SYN scan was performed against the TCP port <kbd class="calibre16">80</kbd> of the IP address indicated. The <kbd class="calibre16">-S</kbd> option identifies the TCP flags activated in the packet sent to the remote system. The table indicates the attributes of the packet received in response. As indicated by the output, a SYN+ACK response was received, thereby indicating that port <kbd class="calibre16">80</kbd> is open on the target host. Additionally, we can scan multiple ports by passing a comma-delimited series of port numbers, as follows:</li>
</ol>
<div class="p"><img class="image-border107" src="../images/00511.jpeg"/></div>
<ol start="3" class="calibre20">
<li value="3" class="calibre19">In the scan output provided, you can see that the results are only displayed if a SYN+ACK response is received. Note that the response associated with the SYN request sent to the port <kbd class="calibre16">443</kbd> is not displayed. As indicated in the output, we can view all of the responses by increasing the verbosity with the <kbd class="calibre16">-v</kbd> option. Additionally, a sequential range of ports can be scanned by passing the first and last port address values separated with dash notation, as follows:</li>
</ol>
<div class="p"><img class="image-border108" src="../images/00513.jpeg"/></div>
<ol start="4" class="calibre20">
<li value="4" class="calibre19">In the example provided, the 100-port scan was sufficient to identify several services on the Metasploitable2 system. However, to perform a scan of all possible TCP ports, all of the possible port address values need to be scanned. The portions of the TCP header that define the source and destination port addresses are both 16 bits in length, and each bit can retain a value of 1 or 0. As such, there are 2<sup class="calibre33">16</sup>, or 65,536 possible TCP port addresses. For the total possible address space to be scanned, a port range of 0 to 65535 needs to be supplied, as follows:</li>
</ol>
<div class="p"><img class="image-border109" src="../images/00324.jpeg"/></div>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="57R301-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works…</h1>
            

            <article>
                
<p class="calibre5">The <kbd class="calibre16">hping3</kbd> utility differs from some of the other tools that have been mentioned since it doesn't have a SYN scanning mode, but rather it allows you to specify the TCP flag bits that are activated when the TCP packets are sent. In the example provided in this recipe, the <kbd class="calibre16">-S</kbd> option instructed <kbd class="calibre16">hping3</kbd> to use the SYN flag for the TCP packets that were sent.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="58PJI1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Port scanning with DMitry (connect)</h1>
            

            <article>
                
<p class="calibre5">Another alternative tool that can be used to perform TCP connect scans on remote systems is DMitry. Unlike Nmap and Metasploit, DMitry is a very simple tool that we can use to perform quick and easy scans without the overhead of managing configurations. This specific recipe demonstrates how we can use DMitry to perform a TCP connect scan.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="59O441-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre5">To use the <kbd class="calibre16">dmitry</kbd> command to perform a full connect scan, you will need to have a remote system that is running network services over TCP. In the examples provided, an instance of Metasploitable2 is used to perform this task. For more information on how to set up Metasploitable2, refer to <a href="part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426" target="_blank" class="calibre6">Chapter 1</a>, <em class="calibre15">Getting Started</em>.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="5AMKM1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it…</h1>
            

            <article>
                
<p class="calibre5">DMitry is a multipurpose tool that can be used to perform a TCP scan on a target system. Its capabilities are somewhat limited, but it is a simple tool that can be used quickly and effectively:</p>
<ol class="calibre20">
<li value="1" class="calibre19">To view the options available for the <kbd class="calibre16">dmitry</kbd> command, we execute the following program in a Terminal without any arguments:</li>
</ol>
<div class="p"><img class="image-border110" src="../images/00517.jpeg"/></div>
<ol start="2" class="calibre20">
<li value="2" class="calibre19">As indicated in the usage output, the <kbd class="calibre16">-p</kbd> option can be used to perform a TCP port scan. To do this, we use this option with the IP address of the system to be scanned. DMitry has 150 commonly used preconfigured ports that it will scan for. Out of these ports, it will display any that it finds open. Consider the following example:</li>
</ol>
<div class="p"><img class="image-border111" src="../images/00492.jpeg"/></div>
<ol start="3" class="calibre20">
<li value="3" class="calibre19">There is not much customization available for TCP port scanning with DMitry, but it can be a quick and effective way to assess the commonly used services on a single host. We can also output the results of a DMitry scan to a text file using the <kbd class="calibre16">-o</kbd> option and by specifying the name of the file to be output in the execution directory:</li>
</ol>
<div class="p"><img class="image-border112" src="../images/00522.jpeg"/></div>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="5BL581-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works…</h1>
            

            <article>
                
<p class="calibre5">The underlying principle that defines how a TCP connect scan is performed by the <kbd class="calibre16">dmitry</kbd> command is the same as was previously discussed with other tools. The usefulness of DMitry mostly lies in its simplicity in comparison with other tools. Rather than managing several configuration options, as we need to with Nmap or Metasploit, we can easily launch DMitry by specifying the appropriate mode and passing it the target IP address. It quickly scans the most commonly used 150 ports and outputs the values of all of the open ports among these.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="5CJLQ1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Port scanning with Netcat (connect)</h1>
            

            <article>
                
<p class="calibre5">Since Netcat is a network socket connection and management utility, it can easily be transformed into a TCP port-scanning utility. This specific recipe demonstrates how we can use Netcat to perform a TCP connect scan.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="5DI6C1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre5">To use Netcat to perform a full connect scan, you will need to have a remote system that is running network services over TCP. In the examples provided, an instance of Metasploitable2 is used to perform this task. For more information on how to set up Metasploitable2, refer to <a href="part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426" target="_blank" class="calibre6">Chapter 1</a>, <em class="calibre15">Getting Started</em>.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="5EGMU1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it…</h1>
            

            <article>
                
<p class="calibre5">Netcat is an extremely useful, multipurpose networking utility that can be used for a plethora of purposes. One effective use of Netcat is to perform port scans:</p>
<ol class="calibre20">
<li value="1" class="calibre19">To identify the usage options, Netcat (<kbd class="calibre16">nc</kbd>) should be called with the <kbd class="calibre16">-h</kbd> option, as follows:</li>
</ol>
<div class="p"><img class="image-border113" src="../images/00225.jpeg"/></div>
<ol start="2" class="calibre20">
<li value="2" class="calibre19">As indicated by the usage output, the <kbd class="calibre16">-z</kbd> option can effectively be used for scanning. To scan the TCP port <kbd class="calibre16">80</kbd> on a target system, we use the <kbd class="calibre16">-n</kbd> option to indicate that an IP address will be used, the <kbd class="calibre16">-v</kbd> option for verbose output, and the <kbd class="calibre16">-z</kbd> option for scanning, as follows:</li>
</ol>
<div class="p"><img class="image-border114" src="../images/00671.jpeg"/></div>
<ol start="3" class="calibre20">
<li value="3" class="calibre19">Performing a scan attempt against an open port will return the IP address, port address, and port status. Performing the same scan against a closed port on a live host will indicate that the connection was refused. We can automate this in a loop, as shown in the following command:</li>
</ol>
<div class="p"><img class="image-border115" src="../images/00527.jpeg"/></div>
<ol start="4" class="calibre20">
<li value="4" class="calibre19">A sequential series of port numbers can be passed through a loop, and all of the ports can be scanned easily and quickly. However, in the example provided, the output for both open and closed ports is included. This is acceptable only if a small number of ports are being scanned. However, if a large number of ports are being scanned, it might be inconvenient to sort through all of the closed ports to find the ones that are open. As such, we can instinctively try to pipe over the output and grep out the lines associated with the open ports, as follows:</li>
</ol>
<div class="p"><img class="image-border116" src="../images/00124.jpeg"/></div>
<ol start="5" class="calibre20">
<li value="5" class="calibre19">However, in attempting to pipe over the output and grepping from it, the total output is still returned. This is because Netcat outputs to <kbd class="calibre16">STDERR</kbd> instead of <kbd class="calibre16">STDOUT</kbd>. To effectively grep from the output of this tool, one must redirect the output to <kbd class="calibre16">STDOUT</kbd> with <kbd class="calibre16">2&gt;&amp;1</kbd>, as follows:</li>
</ol>
<div class="p"><img class="image-border47" src="../images/00532.jpeg"/></div>
<ol start="6" class="calibre20">
<li value="6" class="calibre19">By passing the output to <kbd class="calibre16">STDOUT</kbd> and then grepping from that output, we are able to isolate the lines of output that provide details on the open ports. We can be even more concise by only extracting the information that we need from these lines. If a single host is being scanned, we will likely only benefit from the third and fourth fields:</li>
</ol>
<div class="p"><img class="image-border47" src="../images/00543.jpeg"/></div>
<ol start="7" class="calibre20">
<li value="7" class="calibre19">To extract these fields from the output, the <kbd class="calibre16">cut</kbd> function can be used to separate the line with a space delimiter and then by specifying the fields to be output. However, there is also an effective way to specify a range of ports within Netcat without passing the tool through a loop. By passing <kbd class="calibre16">nc</kbd> as a sequential series of port address values, Netcat will automatically display only the open ports:</li>
</ol>
<div class="p"><img class="image-border47" src="../images/00536.jpeg"/></div>
<ol start="8" class="calibre20">
<li value="8" class="calibre19">Just the same, however, we need to pass its output to <kbd class="calibre16">STDOUT</kbd> to be able to pipe it over to the <kbd class="calibre16">cut</kbd> function. By displaying fields <kbd class="calibre16">2</kbd> through <kbd class="calibre16">4</kbd>, we can limit the output to the IP address, port address, and associated service, as follows:</li>
</ol>
<div class="p"><img class="image-border47" src="../images/00325.jpeg"/></div>
<ol start="9" class="calibre20">
<li value="9" class="calibre19">Using a loop function in bash, we can scan multiple sequential host addresses with Netcat and then extract the same details to identify which ports are open on the various scanned IP addresses:</li>
</ol>
<div class="p"><img class="image-border47" src="../images/00343.jpeg"/></div>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="5FF7G1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works…</h1>
            

            <article>
                
<p class="calibre5">Tools that perform TCP connect scans operate by performing a full three-way handshake to establish a connection with all of the scanned ports on the remote target system. A port's status is determined based on whether a connection was established or not. If a connection was established, the port is determined to be open. If a connection could not be established, the port is determined to be closed.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="5GDO21-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Port scanning with masscan (stealth)</h1>
            

            <article>
                
<p class="calibre5">The <kbd class="calibre16">masscan</kbd> utility is the fastest Internet port scanner; in fact, it is capable of scanning the entire Internet in under 6 minutes. This obviously requires adequate hardware and network bandwidth. The <kbd class="calibre16">masscan</kbd> utility runs using asynchronous transmission, which is what allows it to scan so quickly. One thing to be aware of with masscan is that it utilizes its own custom TCP/IP stack, so some care needs to be taken to avoid conflicts with the local TCP/IP stack. This specific recipe demonstrates how we can use the <kbd class="calibre16">masscan</kbd> command to perform a TCP stealth scan.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="5HC8K1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre5">To use the <kbd class="calibre16">masscan</kbd> command to perform a stealth scan, you will need to have a remote system that is running network services over TCP. In the examples provided, an instance of Metasploitable2 is used to perform this task. For more information on how to set up Metasploitable2, refer to <a href="part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426" target="_blank" class="calibre6">Chapter 1</a>, <em class="calibre15">Getting Started</em>.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="5IAP61-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it…</h1>
            

            <article>
                
<p class="calibre5">Follow along to <span>stealth scan using the <kbd class="calibre16">masscan</kbd> command:</span></p>
<ol class="calibre20">
<li value="1" class="calibre19">The <kbd class="calibre16">masscan</kbd> utility is an extraordinarily fast port scanner. To see the <kbd class="calibre16">masscan</kbd> help file, the <kbd class="calibre16">masscan</kbd> command should be called with the <kbd class="calibre16">-h</kbd> option, as follows:</li>
</ol>
<div class="p"><img class="image-border47" src="../images/00368.jpeg"/></div>
<ol start="2" class="calibre20">
<li value="2" class="calibre19">The makers of masscan did their best to make the usage similar to Nmap. To see <kbd class="calibre16">masscan</kbd> usage options, call the <kbd class="calibre16">masscan</kbd> command followed by the <kbd class="calibre16">--nmap</kbd> option, as follows:</li>
</ol>
<div class="p"><img class="image-border117" src="../images/00387.jpeg"/></div>
<ol start="3" class="calibre20">
<li value="3" class="calibre19">When using <kbd class="calibre16">masscan</kbd> instead of <kbd class="calibre16">nmap</kbd>, you can think of it as if the <kbd class="calibre16">-sS</kbd> flag were permanently set. So we do not need to tell it we are doing a stealth scan. One difference between <kbd class="calibre16">masscan</kbd> and <kbd class="calibre16">nmap</kbd> is there are no default ports set, so we must define what ports we want to check. A masscan scan will use the <kbd class="calibre16">masscan</kbd> command, the IP address of the host to be scanned, and <kbd class="calibre16">-p</kbd> (port/s) to be scanned, as follows:</li>
</ol>
<div class="p"><img class="image-border118" src="../images/00172.jpeg"/></div>
<ol start="4" class="calibre20">
<li value="4" class="calibre19">In the example provided, a SYN scan was performed on the TCP port <kbd class="calibre16">80</kbd> of the specified IP address. Similar to the technique explained with Nmap, <kbd class="calibre16">masscan</kbd> listens for a response and identifies the open ports by analyzing the TCP flags that are activated in any responses received. We can also use the <kbd class="calibre16">masscan</kbd> command to perform scans on multiple specified ports by passing a comma-delimited list of port numbers, as follows:</li>
</ol>
<div class="p"><img class="image-border119" src="../images/00425.jpeg"/></div>
<ol start="5" class="calibre20">
<li value="5" class="calibre19">In the example provided, a SYN scan was performed on the ports <kbd class="calibre16">21</kbd>, <kbd class="calibre16">80</kbd>, and <kbd class="calibre16">443</kbd> of the specified target IP address. We can also use Nmap to scan a sequential series of hosts by indicating the first and last port numbers to be scanned, separated using dash notation:</li>
</ol>
<div class="p"><img class="image-border120" src="../images/00443.jpeg"/></div>
<ol start="6" class="calibre20">
<li value="6" class="calibre19">If a scan is to be performed on all possible TCP ports, all of the possible port address values need to be scanned. The portions of the TCP header that define the source and destination port addresses are both 16 bits in length. Moreover, each bit can retain a value of 1 or 0. As such, there are 2<sup class="calibre33">16</sup>, or 65,536, possible TCP port addresses. For the total possible address space to be scanned, a port range of 0 to 65535 needs to be supplied, as follows:</li>
</ol>
<div class="p"><img class="image-border121" src="../images/00180.jpeg"/></div>
<ol start="7" class="calibre20">
<li value="7" class="calibre19">In the example provided, all of the 65,536 possible TCP addresses were scanned on the Metasploitable2 system. A full scan is always best practice when attempting to identify all of the possible attack surface on a target. The <kbd class="calibre16">masscan</kbd> command can also be used to scan TCP ports on a sequential series of hosts using dash notation:</li>
</ol>
<div class="p"><img class="image-border122" src="../images/00183.jpeg"/></div>
<ol start="8" class="calibre20">
<li value="8" class="calibre19">In the example provided, a SYN scan of the TCP port <kbd class="calibre16">80</kbd> was performed on all of the hosts within the range of addresses specified. Although this particular scan was only performed on a single port, <kbd class="calibre16">masscan</kbd> also has the ability to scan multiple ports and ranges of ports on multiple systems simultaneously. Additionally, masscan can also be configured to scan hosts based on an input list of IP addresses. This can be done using the <kbd class="calibre16">-iL</kbd> option and then specifying either the filename, if the file exists in the execution directory, or the path of the file. The <kbd class="calibre16">masscan</kbd> utility then cycles through each address in the input list and performs the specified scan against that address:</li>
</ol>
<div class="p"><img class="image-border123" src="../images/00487.jpeg"/></div>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    

        <section id="5J99O1-cf89710d791c4a3bb78ec273d9322426">

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works…</h1>
            

            <article>
                
<p class="calibre5">The underlying principle behind SYN scanning with <kbd class="calibre16">masscan</kbd> is the same as has already been discussed. However, with asynchronous mode, <kbd class="calibre16">masscan</kbd> is a fast and highly effective way to perform these types of scans. The <kbd class="calibre16">masscan</kbd> utility provides you with the fastest way to scan the Internet and collect information. It uses a custom TCP/IP stack to avoid conflicts and offer you the best compatibility and flexibility.</p>


            </article>

            <footer class="calibre7">
                
            </footer>

        </section>
    </body></html>